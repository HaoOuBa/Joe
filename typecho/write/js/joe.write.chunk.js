!function () {
	"use strict"; let r = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(t => t ? parseInt(t, 36) : 1); for (let t = 1; t < r.length; t++)r[t] += r[t - 1]; function s(t) { return 127462 <= t && t <= 127487 } const o = 8205; function b(t, e, i = !0) { return (i ? n : a)(t, e) } function n(i, n) { if (n == i.length) return n; n && l(i.charCodeAt(n)) && h(i.charCodeAt(n - 1)) && n--; let t = c(i, n); for (n += O(t); n < i.length;) { var e = c(i, n); if (t == o || e == o || function (e) { for (let t = 1; t < r.length; t += 2)if (r[t] > e) return r[t - 1] <= e }(e)) n += O(e), t = e; else { if (!s(e)) break; { let t = 0, e = n - 2; for (; 0 <= e && s(c(i, e));)t++, e -= 2; if (t % 2 == 0) break; n += 2 } } } return n } function a(t, e) { for (; 0 < e;) { var i = n(t, e - 2); if (i < e) return i; e-- } return 0 } function l(t) { return 56320 <= t && t < 57344 } function h(t) { return 55296 <= t && t < 56320 } function c(t, e) { var i = t.charCodeAt(e); if (!h(i) || e + 1 == t.length) return i; e = t.charCodeAt(e + 1); return l(e) ? e - 56320 + (i - 55296 << 10) + 65536 : i } function O(t) { return t < 65536 ? 1 : 2 } function x(e, i, n) { for (let t = 0; t < e.length;)9 == e.charCodeAt(t) ? (i += n - i % n, t++) : (i++, t = b(e, t)); return i } class d { constructor() { } lineAt(t) { if (t < 0 || t > this.length) throw new RangeError(`Invalid position ${t} in document of length ${this.length}`); return this.lineInner(t, !1, 1, 0) } line(t) { if (t < 1 || t > this.lines) throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`); return this.lineInner(t, !0, 1, 0) } replace(t, e, i) { var n = []; return this.decompose(0, t, n, 2), i.length && i.decompose(0, i.length, n, 3), this.decompose(e, this.length, n, 1), m.from(n, this.length - (e - t) + i.length) } append(t) { return this.replace(this.length, this.length, t) } slice(t, e = this.length) { var i = []; return this.decompose(t, e, i, 0), m.from(i, e - t) } eq(t) { if (t == this) return !0; if (t.length != this.length || t.lines != this.lines) return !1; let e = new g(this), i = new g(t); for (; ;) { if (e.next(), i.next(), e.lineBreak != i.lineBreak || e.done != i.done || e.value != i.value) return !1; if (e.done) return !0 } } iter(t = 1) { return new g(this, t) } iterRange(t, e = this.length) { return new i(this, t, e) } toString() { return this.sliceString(0) } toJSON() { var t = []; return this.flatten(t), t } static of(t) { if (0 == t.length) throw new RangeError("A document must have at least one line"); return 1 != t.length || t[0] ? t.length <= 32 ? new p(t) : m.from(p.split(t, [])) : d.empty } } "undefined" != typeof Symbol && (d.prototype[Symbol.iterator] = function () { return this.iter() }); class p extends d { constructor(t, e = function (t) { let e = -1; for (var i of t) e += i.length + 1; return e }(t)) { super(), this.text = t, this.length = e } get lines() { return this.text.length } get children() { return null } lineInner(e, i, n, r) { for (let t = 0; ; t++) { var s = this.text[t], o = r + s.length; if (e <= (i ? n : o)) return new Q(r, o, n, s); r = o + 1, n++ } } decompose(i, t, n, r) { i = i <= 0 && t >= this.length ? this : new p(f(this.text, i, t), Math.min(t, this.length) - Math.max(0, i)); if (1 & r) { let t = n.pop(), e = u(i.text, t.text.slice(), 0, i.length); e.length <= 32 ? n.push(new p(e, t.length + i.length)) : (r = e.length >> 1, n.push(new p(e.slice(0, r)), new p(e.slice(r)))) } else n.push(i) } replace(t, e, i) { if (!(i instanceof p)) return super.replace(t, e, i); var n = u(this.text, u(i.text, f(this.text, 0, t)), e), t = this.length + i.length - (e - t); return n.length <= 32 ? new p(n, t) : m.from(p.split(n, []), t) } sliceString(r, s = this.length, o = "\n") { let a = ""; for (let i = 0, n = 0; i <= s && n < this.text.length; n++) { let t = this.text[n], e = i + t.length; i > r && n && (a += o), r < e && s > i && (a += t.slice(Math.max(0, r - i), s - i)), i = e + 1 } return a } flatten(t) { for (var e of this.text) t.push(e) } static split(t, e) { let i = [], n = -1; for (var r of t) i.push(r), n += r.length + 1, 32 == i.length && (e.push(new p(i, n)), i = [], n = -1); return -1 < n && e.push(new p(i, n)), e } } class m extends d { constructor(t, e) { super(), this.children = t, this.length = e, this.lines = 0; for (var i of t) this.lines += i.lines } lineInner(r, s, o, a) { for (let n = 0; ; n++) { let t = this.children[n], e = a + t.length, i = o + t.lines - 1; if (r <= (s ? i : e)) return t.lineInner(r, s, o, a); a = e + 1, o = 1 + i } } decompose(r, s, o, a) { for (let i = 0, n = 0; n <= s && i < this.children.length; i++) { let t = this.children[i], e = n + t.length; var l; r <= e && s >= n && (l = a & ((n <= r ? 1 : 0) | (s <= e ? 2 : 0)), n >= r && e <= s && !l ? o.push(t) : t.decompose(r - n, s - n, o, l)), n = e + 1 } } replace(r, s, o) { if (o.lines < this.lines) for (let i = 0, n = 0; i < this.children.length; i++) { let t = this.children[i], e = n + t.length; if (r >= n && s <= e) { var a = t.replace(r - n, s - n, o), l = this.lines - t.lines + a.lines; if (a.lines < l >> 4 && a.lines > l >> 6) { let t = this.children.slice(); return t[i] = a, new m(t, this.length - (s - r) + o.length) } return super.replace(n, e, a) } n = e + 1 } return super.replace(r, s, o) } sliceString(r, s = this.length, o = "\n") { let a = ""; for (let i = 0, n = 0; i < this.children.length && n <= s; i++) { let t = this.children[i], e = n + t.length; n > r && i && (a += o), r < e && s > n && (a += t.sliceString(r - n, s - n, o)), n = e + 1 } return a } flatten(t) { for (var e of this.children) e.flatten(t) } static from(t, e = t.reduce((t, e) => t + e.length + 1, -1)) { let i = 0; for (var n of t) i += n.lines; if (i < 32) { var r, s = []; for (r of t) r.flatten(s); return new p(s, e) } let o = Math.max(32, i >> 5), a = o << 1, l = o >> 1, h = [], c = 0, O = -1, d = []; function u() { 0 != c && (h.push(1 == d.length ? d[0] : m.from(d, O)), O = -1, c = d.length = 0) } for (var f of t) !function t(e) { let i; if (e.lines > a && e instanceof m) for (var n of e.children) t(n); else e.lines > l && (c > l || !c) ? (u(), h.push(e)) : e instanceof p && c && (i = d[d.length - 1]) instanceof p && e.lines + i.lines <= 32 ? (c += e.lines, O += e.length + 1, d[d.length - 1] = new p(i.text.concat(e.text), i.length + 1 + e.length)) : (c + e.lines > o && u(), c += e.lines, O += e.length + 1, d.push(e)) }(f); return u(), 1 == h.length ? h[0] : new m(h, e) } } function u(s, o, a = 0, l = 1e9) { for (let i = 0, n = 0, r = !0; n < s.length && i <= l; n++) { let t = s[n], e = i + t.length; a <= e && (l < e && (t = t.slice(0, l - i)), i < a && (t = t.slice(a - i)), r ? (o[o.length - 1] += t, r = !1) : o.push(t)), i = e + 1 } return o } function f(t, e, i) { return u(t, [""], e, i) } d.empty = new p([""], 0); class g { constructor(t, e = 1) { this.dir = e, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [0 < e ? 0 : (t instanceof p ? t.text : t.children).length] } next(n = 0) { for (; ;) { var r = this.nodes.length - 1; if (r < 0) return this.done = !0, this.value = "", this.lineBreak = !1, this; let e = this.nodes[r], i = this.offsets[r]; var t = (e instanceof p ? e.text : e.children).length; if (i == (0 < this.dir ? t : 0)) this.nodes.pop(), this.offsets.pop(); else if (this.lineBreak || i == (0 < this.dir ? 0 : t)) if (e instanceof p) { let t = e.text[i - (this.dir < 0 ? 1 : 0)]; if (this.offsets[r] = i += this.dir, this.lineBreak = !1, t.length > Math.max(0, n)) return this.value = 0 == n ? t : 0 < this.dir ? t.slice(n) : t.slice(0, t.length - n), this; n -= t.length } else { t = e.children[0 < this.dir ? i : i - 1]; this.offsets[r] = i + this.dir, this.lineBreak = !1, n > t.length ? n -= t.length : (this.nodes.push(t), this.offsets.push(0 < this.dir ? 0 : (t instanceof p ? t.text : t.children).length)) } else { if (this.lineBreak = !0, 0 == n) return this.value = "\n", this; n-- } } } } class i { constructor(t, e, i) { this.value = "", this.cursor = new g(t, i < e ? -1 : 1), i < e ? (this.skip = t.length - e, this.limit = e - i) : (this.skip = e, this.limit = i - e) } next(n = 0) { if (this.limit <= 0) this.limit = -1; else { let { value: t, lineBreak: e, done: i } = this.cursor.next(this.skip + n); this.skip = 0, this.value = t; n = e ? 1 : t.length; n > this.limit && (this.value = 0 < this.cursor.dir ? t.slice(0, this.limit) : t.slice(n - this.limit)), i || 0 == this.value.length ? this.limit = -1 : this.limit -= this.value.length } return this } get lineBreak() { return this.cursor.lineBreak } get done() { return this.limit < 0 } } class Q { constructor(t, e, i, n) { this.from = t, this.to = e, this.number = i, this.text = n } get length() { return this.to - this.from } } const v = /\r\n?|\n/; var w = function (t) { return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t }(w = w || {}); class y { constructor(t) { this.sections = t } get length() { let e = 0; for (let t = 0; t < this.sections.length; t += 2)e += this.sections[t]; return e } get newLength() { let e = 0; for (let t = 0; t < this.sections.length; t += 2) { var i = this.sections[t + 1]; e += i < 0 ? this.sections[t] : i } return e } get empty() { return 0 == this.sections.length || 2 == this.sections.length && this.sections[1] < 0 } iterGaps(n) { for (let t = 0, e = 0, i = 0; t < this.sections.length;) { var r = this.sections[t++], s = this.sections[t++]; s < 0 ? (n(e, i, r), i += r) : i += s, e += r } } iterChangedRanges(t, e = !1) { T(this, t, e) } get invertedDesc() { let e = []; for (let t = 0; t < this.sections.length;) { var i = this.sections[t++], n = this.sections[t++]; n < 0 ? e.push(i, n) : e.push(n, i) } return new y(e) } composeDesc(t) { return this.empty ? t : t.empty ? this : e(this, t) } mapDesc(t, e = !1) { return t.empty ? this : W(this, t, e) } mapPos(e, i = -1, n = w.Simple) { let r = 0, s = 0; for (let t = 0; t < this.sections.length;) { var o = this.sections[t++], a = this.sections[t++], l = r + o; if (a < 0) { if (e < l) return s + (e - r); s += o } else { if (n != w.Simple && e <= l && (n == w.TrackDel && r < e && e < l || n == w.TrackBefore && r < e || n == w.TrackAfter && e < l)) return null; if (e < l || l == e && i < 0 && !o) return e == r || i < 0 ? s : s + a; s += a } r = l } if (e > r) throw new RangeError(`Position ${e} is out of range for changeset of length ${r}`); return s } touchesRange(i, n = i) { for (let t = 0, e = 0; t < this.sections.length && e <= n;) { var r = this.sections[t++], s = this.sections[t++], r = e + r; if (0 <= s && e <= n && i <= r) return !(e < i && n < r) || "cover"; e = r } return !1 } toString() { let e = ""; for (let t = 0; t < this.sections.length;) { var i = this.sections[t++], n = this.sections[t++]; e += (e ? " " : "") + i + (0 <= n ? ":" + n : "") } return e } toJSON() { return this.sections } static fromJSON(t) { if (!Array.isArray(t) || t.length % 2 || t.some(t => "number" != typeof t)) throw new RangeError("Invalid JSON representation of ChangeDesc"); return new y(t) } } class k extends y { constructor(t, e) { super(t), this.inserted = e } apply(s) { if (this.length != s.length) throw new RangeError("Applying change set to a document with the wrong length"); return T(this, (t, e, i, n, r) => s = s.replace(i, i + (e - t), r), !1), s } mapDesc(t, e = !1) { return W(this, t, e, !0) } invert(i) { let n = this.sections.slice(), r = []; for (let t = 0, e = 0; t < n.length; t += 2) { var s = n[t], o = n[t + 1]; if (0 <= o) { n[t] = o, n[t + 1] = s; for (var a = t >> 1; r.length < a;)r.push(d.empty); r.push(s ? i.slice(e, e + s) : d.empty) } e += s } return new k(n, r) } compose(t) { return this.empty ? t : t.empty ? this : e(this, t, !0) } map(t, e = !1) { return t.empty ? this : W(this, t, e, !0) } iterChanges(t, e = !1) { T(this, t, e) } get desc() { return new y(this.sections) } filter(i) { var n = [], r = [], s = []; let o = new X(this); t: for (let t = 0, e = 0; ;) { for (var a = t == i.length ? 1e9 : i[t++]; e < a || e == a && 0 == o.len;) { if (o.done) break t; var l = Math.min(o.len, a - e); S(s, l, -1); var h = -1 == o.ins ? -1 : 0 == o.off ? o.ins : 0; S(n, l, h), 0 < h && P(r, n, o.text), o.forward(l), e += l } for (var c = i[t++]; e < c;) { if (o.done) break t; var O = Math.min(o.len, c - e); S(n, O, -1), S(s, O, -1 == o.ins ? -1 : 0 == o.off ? o.ins : 0), o.forward(O), e += O } } return { changes: new k(n, r), filtered: new y(s) } } toJSON() { let n = []; for (let i = 0; i < this.sections.length; i += 2) { let t = this.sections[i], e = this.sections[i + 1]; e < 0 ? n.push(t) : 0 == e ? n.push([t]) : n.push([t].concat(this.inserted[i >> 1].toJSON())) } return n } static of(t, s, o) { let a = [], l = [], h = 0, i = null; function c(t = !1) { if (t || a.length) { h < s && S(a, s - h, -1); let t = new k(a, l); i = i ? i.compose(t.map(i)) : t, a = [], l = [], h = 0 } } return function t(n) { if (Array.isArray(n)) for (var e of n) t(e); else if (n instanceof k) { if (n.length != s) throw new RangeError(`Mismatched change set length (got ${n.length}, expected ${s})`); c(), i = i ? i.compose(n.map(i)) : n } else { let { from: t, to: e = t, insert: i } = n; if (e < t || t < 0 || s < e) throw new RangeError(`Invalid change range ${t} to ${e} (in doc of length ${s})`); var r = i ? "string" == typeof i ? d.of(i.split(o || v)) : i : d.empty, n = r.length; t == e && 0 == n || (t < h && c(), t > h && S(a, t - h, -1), S(a, e - t, n), P(l, a, r), h = e) } }(t), c(!i), i } static empty(t) { return new k(t ? [t, -1] : [], []) } static fromJSON(i) { if (!Array.isArray(i)) throw new RangeError("Invalid JSON representation of ChangeSet"); let n = [], r = []; for (let e = 0; e < i.length; e++) { let t = i[e]; if ("number" == typeof t) n.push(t, -1); else { if (!Array.isArray(t) || "number" != typeof t[0] || t.some((t, e) => e && "string" != typeof t)) throw new RangeError("Invalid JSON representation of ChangeSet"); if (1 == t.length) n.push(t[0], 0); else { for (; r.length < e;)r.push(d.empty); r[e] = d.of(t.slice(1)), n.push(t[0], r[e].length) } } } return new k(n, r) } } function S(t, e, i, n = !1) { var r; 0 == e && i <= 0 || (0 <= (r = t.length - 2) && i <= 0 && i == t[1 + r] ? t[r] += e : 0 == e && 0 == t[r] ? t[1 + r] += i : n ? (t[r] += e, t[1 + r] += i) : t.push(e, i)) } function P(t, e, i) { if (0 != i.length) { var n = e.length - 2 >> 1; if (n < t.length) t[t.length - 1] = t[t.length - 1].append(i); else { for (; t.length < n;)t.push(d.empty); t.push(i) } } } function T(l, h, c) { var O = l.inserted; for (let s = 0, o = 0, a = 0; a < l.sections.length;) { let n = l.sections[a++], r = l.sections[a++]; if (r < 0) s += n, o += n; else { let t = s, e = o, i = d.empty; for (; t += n, e += r, r && O && (i = i.append(O[a - 2 >> 1])), !(c || a == l.sections.length || l.sections[a + 1] < 0);)n = l.sections[a++], r = l.sections[a++]; h(s, t, o, e, i), s = t, o = e } } } function W(t, e, r, i = !1) { var s = [], o = i ? [] : null; let a = new X(t), l = new X(e); for (let i = 0, n = 0; ;)if (-1 == a.ins) i += a.len, a.next(); else if (-1 == l.ins && n < i) { var h = Math.min(l.len, i - n); l.forward(h), S(s, h, -1), n += h } else if (0 <= l.ins && (a.done || n < i || n == i && (l.len < a.len || l.len == a.len && !r))) { for (S(s, l.ins, -1); i > n && !a.done && i + a.len < n + l.len;)i += a.len, a.next(); n += l.len, l.next() } else { if (!(0 <= a.ins)) { if (a.done && l.done) return o ? new k(s, o) : new y(s); throw new Error("Mismatched change set lengths") } { let t = 0, e = i + a.len; for (; ;)if (0 <= l.ins && n > i && n + l.len < e) t += l.ins, n += l.len, l.next(); else { if (!(-1 == l.ins && n < e)) break; var c = Math.min(l.len, e - n); t += c, l.forward(c), n += c } S(s, t, a.ins), o && P(o, s, a.text), i = e, a.next() } } } function e(t, e, i = !1) { var n = [], r = i ? [] : null; let s = new X(t), o = new X(e); for (let t = !1; ;) { if (s.done && o.done) return r ? new k(n, r) : new y(n); if (0 == s.ins) S(n, s.len, 0, t), s.next(); else if (0 != o.len || o.done) { if (s.done || o.done) throw new Error("Mismatched change set lengths"); var a, l = Math.min(s.len2, o.len), h = n.length; -1 == s.ins ? (S(n, l, a = -1 == o.ins ? -1 : o.off ? 0 : o.ins, t), r && a && P(r, n, o.text)) : -1 == o.ins ? (S(n, s.off ? 0 : s.len, l, t), r && P(r, n, s.textBit(l))) : (S(n, s.off ? 0 : s.len, o.off ? 0 : o.ins, t), r && !o.off && P(r, n, o.text)), t = (s.ins > l || 0 <= o.ins && o.len > l) && (t || h < n.length), s.forward2(l), o.forward(l) } else S(n, 0, o.ins, t), r && P(r, n, o.text), o.next() } } class X { constructor(t) { this.set = t, this.i = 0, this.next() } next() { var { sections: t } = this.set; this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0 } get done() { return -2 == this.ins } get len2() { return this.ins < 0 ? this.len : this.ins } get text() { var { inserted: t } = this.set, e = this.i - 2 >> 1; return e >= t.length ? d.empty : t[e] } textBit(t) { let { inserted: e } = this.set, i = this.i - 2 >> 1; return i >= e.length && !t ? d.empty : e[i].slice(this.off, null == t ? void 0 : this.off + t) } forward(t) { t == this.len ? this.next() : (this.len -= t, this.off += t) } forward2(t) { -1 == this.ins ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t) } } class R { constructor(t, e, i) { this.from = t, this.to = e, this.flags = i } get anchor() { return 16 & this.flags ? this.to : this.from } get head() { return 16 & this.flags ? this.from : this.to } get empty() { return this.from == this.to } get assoc() { return 4 & this.flags ? -1 : 8 & this.flags ? 1 : 0 } get bidiLevel() { var t = 3 & this.flags; return 3 == t ? null : t } get goalColumn() { var t = this.flags >> 5; return 33554431 == t ? void 0 : t } map(t, e = -1) { var i = t.mapPos(this.from, e), e = t.mapPos(this.to, e); return i == this.from && e == this.to ? this : new R(i, e, this.flags) } extend(t, e = t) { if (t <= this.anchor && e >= this.anchor) return _.range(t, e); e = Math.abs(t - this.anchor) > Math.abs(e - this.anchor) ? t : e; return _.range(this.anchor, e) } eq(t) { return this.anchor == t.anchor && this.head == t.head } toJSON() { return { anchor: this.anchor, head: this.head } } static fromJSON(t) { if (!t || "number" != typeof t.anchor || "number" != typeof t.head) throw new RangeError("Invalid JSON representation for SelectionRange"); return _.range(t.anchor, t.head) } } class _ { constructor(t, e = 0) { this.ranges = t, this.mainIndex = e } map(e, i = -1) { return e.empty ? this : _.create(this.ranges.map(t => t.map(e, i)), this.mainIndex) } eq(e) { if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex) return !1; for (let t = 0; t < this.ranges.length; t++)if (!this.ranges[t].eq(e.ranges[t])) return !1; return !0 } get main() { return this.ranges[this.mainIndex] } asSingle() { return 1 == this.ranges.length ? this : new _([this.main]) } addRange(t, e = !0) { return _.create([t].concat(this.ranges), e ? 0 : this.mainIndex + 1) } replaceRange(t, e = this.mainIndex) { let i = this.ranges.slice(); return i[e] = t, _.create(i, this.mainIndex) } toJSON() { return { ranges: this.ranges.map(t => t.toJSON()), main: this.mainIndex } } static fromJSON(t) { if (!t || !Array.isArray(t.ranges) || "number" != typeof t.main || t.main >= t.ranges.length) throw new RangeError("Invalid JSON representation for EditorSelection"); return new _(t.ranges.map(t => R.fromJSON(t)), t.main) } static single(t, e = t) { return new _([_.range(t, e)], 0) } static create(i, n = 0) { if (0 == i.length) throw new RangeError("A selection needs at least one range"); for (let t = 0, e = 0; e < i.length; e++) { var r = i[e]; if (r.empty ? r.from <= t : r.from < t) return function (e, i = 0) { var t = e[i]; e.sort((t, e) => t.from - e.from), i = e.indexOf(t); for (let t = 1; t < e.length; t++) { var n, r = e[t], s = e[t - 1]; (r.empty ? r.from <= s.to : r.from < s.to) && (n = s.from, s = Math.max(r.to, s.to), t <= i && i--, e.splice(--t, 2, r.anchor > r.head ? _.range(s, n) : _.range(n, s))) } return new _(e, i) }(i.slice(), n); t = r.to } return new _(i, n) } static cursor(t, e = 0, i, n) { return new R(t, t, (0 == e ? 0 : e < 0 ? 4 : 8) | (null == i ? 3 : Math.min(2, i)) | (null != n ? n : 33554431) << 5) } static range(t, e, i) { i = (null != i ? i : 33554431) << 5; return e < t ? new R(e, t, 16 | i) : new R(t, e, i) } } function C(t, e) { for (var i of t.ranges) if (i.to > e) throw new RangeError("Selection points outside of document") } let A = 0; class L { constructor(t, e, i, n, r) { this.combine = t, this.compareInput = e, this.compare = i, this.isStatic = n, this.extensions = r, this.id = A++, this.default = t([]) } static define(t = {}) { return new L(t.combine || (t => t), t.compareInput || ((t, e) => t === e), t.compare || (t.combine ? (t, e) => t === e : z), !!t.static, t.enables) } of(t) { return new q([], this, 0, t) } compute(t, e) { if (this.isStatic) throw new Error("Can't compute a static facet"); return new q(t, this, 1, e) } computeN(t, e) { if (this.isStatic) throw new Error("Can't compute a static facet"); return new q(t, this, 2, e) } from(e, i) { return i = i || (t => t), this.compute([e], t => i(t.field(e))) } } function z(t, i) { return t == i || t.length == i.length && t.every((t, e) => t === i[e]) } class q { constructor(t, e, i, n) { this.dependencies = t, this.facet = e, this.type = i, this.value = n, this.id = A++ } dynamicSlot(t) { var e, i; let n = this.value, r = this.facet.compareInput, s = t[this.id] >> 1, o = 2 == this.type, a = !1, l = !1, h = []; for (i of this.dependencies) "doc" == i ? a = !0 : "selection" == i ? l = !0 : 0 == (1 & (null !== (e = t[i.id]) && void 0 !== e ? e : 1)) && h.push(t[i.id]); return (e, t) => { if (!t || t.reconfigured) return e.values[s] = n(e), 1; if (!(a && t.docChanged || l && (t.docChanged || t.selection) || h.some(t => 0 < (1 & G(e, t))))) return 0; var i = n(e), t = t.startState.values[s]; return (o ? function (e, i, n) { if (e.length != i.length) return !1; for (let t = 0; t < e.length; t++)if (!n(e[t], i[t])) return !1; return !0 }(i, t, r) : r(i, t)) ? 0 : (e.values[s] = i, 1) } } } function V(t, e) { e = t.config.address[e]; return null == e ? null : e >> 1 } const Y = L.define({ static: !0 }); class M { constructor(t, e, i, n, r) { this.id = t, this.createF = e, this.updateF = i, this.compareF = n, this.spec = r, this.provides = void 0 } static define(t) { let e = new M(A++, t.create, t.update, t.compare || ((t, e) => t === e), t); return t.provide && (e.provides = t.provide(e)), e } create(t) { let e = t.facet(Y).find(t => t.field == this); return ((null === e || void 0 === e ? void 0 : e.create) || this.createF)(t) } slot(t) { let r = t[this.id] >> 1; return (t, e) => { if (!e || e.reconfigured && null == V(e.startState, this.id)) return t.values[r] = this.create(t), 1; let i, n = 0; e.reconfigured ? (i = e.startState.values[V(e.startState, this.id)], n = 1) : i = e.startState.values[r]; e = this.updateF(i, e); return n || this.compareF(i, e) || (n = 1), n && (t.values[r] = e), n } } init(t) { return [this, Y.of({ field: this, create: t })] } get extension() { return this } } const Z = { fallback: 3, default: 2, extend: 1, override: 0 }; function t(e) { return t => new j(t, e) } const E = { fallback: t(Z.fallback), default: t(Z.default), extend: t(Z.extend), override: t(Z.override) }; class j { constructor(t, e) { this.inner = t, this.prec = e } } class D { of(t) { return new H(this, t) } reconfigure(t) { return D.reconfigure.of({ compartment: this, extension: t }) } get(t) { return t.config.compartments.get(this) } } class H { constructor(t, e) { this.compartment = t, this.inner = e } } class I { constructor(t, e, i, n, r) { for (this.base = t, this.compartments = e, this.dynamicSlots = i, this.address = n, this.staticValues = r, this.statusTemplate = []; this.statusTemplate.length < i.length;)this.statusTemplate.push(0) } staticFacet(t) { var e = this.address[t.id]; return null == e ? t.default : this.staticValues[e >> 1] } static resolve(t, e, n) { let i = [], r = Object.create(null); var s, o, a = new Map; for (s of function (t, a, l) { let h = [[], [], [], []], c = new Map; return function t(e, i) { var n = c.get(e); if (null != n) { if (i <= n) return; var r = h[n].indexOf(e); -1 < r && h[n].splice(r, 1), e instanceof H && l.delete(e.compartment) } if (c.set(e, i), Array.isArray(e)) for (var s of e) t(s, i); else if (e instanceof H) { if (l.has(e.compartment)) throw new RangeError("Duplicate use of compartment in extensions"); var o = a.get(e.compartment) || e.inner; l.set(e.compartment, o), t(o, i) } else if (e instanceof j) t(e.inner, e.prec); else if (e instanceof M) h[i].push(e), e.provides && t(e.provides, i); else if (e instanceof q) h[i].push(e), e.facet.extensions && t(e.facet.extensions, i); else { if (!(o = e.extension)) throw new Error(`Unrecognized extension value in extension set (${e}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`); t(o, i) } }(t, Z.default), h.reduce((t, e) => t.concat(e)) }(t, e, a)) (s instanceof M ? i : r[s.facet.id] || (r[s.facet.id] = [])).push(s); let l = Object.create(null), h = [], c = []; for (let e of i) l[e.id] = c.length << 1, c.push(t => e.slot(t)); for (o in r) { let i = r[o], e = i[0].facet; if (i.every(t => 0 == t.type)) { l[e.id] = h.length << 1 | 1; let t = e.combine(i.map(t => t.value)); var O = n ? n.config.address[e.id] : null; null != O && (O = B(n, O), e.compare(t, O) && (t = O)), h.push(t) } else { for (let e of i) 0 == e.type ? (l[e.id] = h.length << 1 | 1, h.push(e.value)) : (l[e.id] = c.length << 1, c.push(t => e.dynamicSlot(t))); l[e.id] = c.length << 1, c.push(t => function (e, h, t) { let c = t.map(t => e[t.id]), O = t.map(t => t.type), d = c.filter(t => !(1 & t)), u = e[h.id] >> 1; return (e, t) => { var i, n = t ? t.reconfigured ? t.startState.config.address[h.id] : u << 1 : null; let r = null == n; for (i of d) 1 & G(e, i) && (r = !0); if (!r) return 0; let s = []; for (let t = 0; t < c.length; t++) { var o = B(e, c[t]); if (2 == O[t]) for (var a of o) s.push(a); else s.push(o) } var l = h.combine(s); return null != n && h.compare(l, B(t.startState, n)) ? 0 : (e.values[u] = l, 1) } }(t, e, i)) } } return new I(t, a, c.map(t => t(l)), l, h) } } function G(t, e) { if (1 & e) return 2; var i = e >> 1, e = t.status[i]; if (4 == e) throw new Error("Cyclic dependency between fields and/or facets"); if (2 & e) return e; t.status[i] = 4; e = t.config.dynamicSlots[i](t, t.applying); return t.status[i] = 2 | e } function B(t, e) { return (1 & e ? t.config.staticValues : t.values)[e >> 1] } const N = L.define(), U = L.define({ combine: t => t.some(t => t), static: !0 }), F = L.define({ combine: t => t.length ? t[0] : void 0, static: !0 }), J = L.define(), K = L.define(), tt = L.define(); class et { constructor(t, e) { this.type = t, this.value = e } static define() { return new it } } class it { of(t) { return new et(this, t) } } class nt { constructor(t) { this.map = t } of(t) { return new rt(this, t) } } class rt { constructor(t, e) { this.type = t, this.value = e } map(t) { t = this.type.map(this.value, t); return void 0 === t ? void 0 : t == this.value ? this : new rt(this.type, t) } is(t) { return this.type == t } static define(t = {}) { return new nt(t.map || (t => t)) } static mapEffects(t, e) { if (!t.length) return t; let i = []; for (var n of t) { n = n.map(e); n && i.push(n) } return i } } rt.reconfigure = rt.define(), rt.appendConfig = rt.define(); class st { constructor(t, e, i, n, r, s) { this.startState = t, this.changes = e, this.selection = i, this.effects = n, this.annotations = r, this.scrollIntoView = s, this._doc = null, this._state = null, i && C(i, e.newLength), r.some(t => t.type == st.time) || (this.annotations = r.concat(st.time.of(Date.now()))) } get newDoc() { return this._doc || (this._doc = this.changes.apply(this.startState.doc)) } get newSelection() { return this.selection || this.startState.selection.map(this.changes) } get state() { return this._state || this.startState.applyTransaction(this), this._state } annotation(t) { for (var e of this.annotations) if (e.type == t) return e.value } get docChanged() { return !this.changes.empty } get reconfigured() { return this.startState.config != this.state.config } } function ot(t, e, i) { let n, r, s; return s = i ? (n = e.changes, r = k.empty(e.changes.length), t.changes.compose(e.changes)) : (n = e.changes.map(t.changes), r = t.changes.mapDesc(e.changes, !0), t.changes.compose(n)), { changes: s, selection: e.selection ? e.selection.map(r) : null === (i = t.selection) || void 0 === i ? void 0 : i.map(n), effects: rt.mapEffects(t.effects, n).concat(rt.mapEffects(e.effects, r)), annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations, scrollIntoView: t.scrollIntoView || e.scrollIntoView } } function at(t, e, i) { var n = e.selection; return { changes: e.changes instanceof k ? e.changes : k.of(e.changes || [], i, t.facet(F)), selection: n && (n instanceof _ ? n : _.single(n.anchor, n.head)), effects: ct(e.effects), annotations: ct(e.annotations), scrollIntoView: !!e.scrollIntoView } } function lt(e, i, n) { let r = at(e, i.length ? i[0] : {}, e.doc.length); i.length && !1 === i[0].filter && (n = !1); for (let t = 1; t < i.length; t++) { !1 === i[t].filter && (n = !1); var s = !!i[t].sequential; r = ot(r, at(e, i[t], s ? r.changes.newLength : e.doc.length), s) } var t = new st(e, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView); return function (e) { let i = e.startState, n = i.facet(tt), r = e; for (let t = n.length - 1; 0 <= t; t--) { var s = n[t](e); s && Object.keys(s).length && (r = ot(e, at(i, s, e.changes.newLength), !0)) } return r == e ? e : new st(i, e.changes, e.selection, r.effects, r.annotations, r.scrollIntoView) }(n ? function (i) { let n = i.startState, r = !0; for (var t of n.facet(J)) { t = t(i); if (!1 === t) { r = !1; break } Array.isArray(t) && (r = !0 === r ? t : function (r, s) { let o = []; for (let i = 0, n = 0; ;) { let t, e; if (i < r.length && (n == s.length || s[n] >= r[i])) t = r[i++], e = r[i++]; else { if (!(n < s.length)) return o; t = s[n++], e = s[n++] } !o.length || o[o.length - 1] < t ? o.push(t, e) : o[o.length - 1] < e && (o[o.length - 1] = e) } }(r, t)) } if (!0 !== r) { let t, e; var s; !1 === r ? (e = i.changes.invertedDesc, t = k.empty(n.doc.length)) : (s = i.changes.filter(r), t = s.changes, e = s.filtered.invertedDesc), i = new st(n, t, i.selection && i.selection.map(e), rt.mapEffects(i.effects, e), i.annotations, i.scrollIntoView) } let e = n.facet(K); for (let t = e.length - 1; 0 <= t; t--) { var o = e[t](i); i = o instanceof st ? o : Array.isArray(o) && 1 == o.length && o[0] instanceof st ? o[0] : lt(n, ct(o), !1) } return i }(t) : t) } st.time = et.define(), st.userEvent = et.define(), st.addToHistory = et.define(), st.remote = et.define(); const ht = []; function ct(t) { return null == t ? ht : Array.isArray(t) ? t : [t] } var Ot = function (t) { return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t }(Ot = Ot || {}); const dt = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/; let ut; try { ut = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u") } catch (t) { } function ft(i) { return e => { if (!/\S/.test(e)) return Ot.Space; if (function (i) { if (ut) return ut.test(i); for (let e = 0; e < i.length; e++) { let t = i[e]; if (/\w/.test(t) || "" < t && (t.toUpperCase() != t.toLowerCase() || dt.test(t))) return 1 } }(e)) return Ot.Word; for (let t = 0; t < i.length; t++)if (-1 < e.indexOf(i[t])) return Ot.Word; return Ot.Other } } class pt { constructor(t, e, i, n = null) { if (this.config = t, this.doc = e, this.selection = i, this.applying = null, this.status = t.statusTemplate.slice(), n && n.startState.config == t) this.values = n.startState.values.slice(); else if (this.values = t.dynamicSlots.map(t => null), n) for (var r in t.address) { var s = t.address[r], r = n.startState.config.address[r]; null != r && 0 == (1 & s) && (this.values[s >> 1] = B(n.startState, r)) } (this.applying = n) && (n._state = this); for (let t = 0; t < this.config.dynamicSlots.length; t++)G(this, t << 1); this.applying = null } field(t, e = !0) { t = this.config.address[t.id]; if (null != t) return G(this, t), B(this, t); if (e) throw new RangeError("Field is not present in this state") } update(...t) { return lt(this, t, !0) } applyTransaction(t) { let e = this.config, { base: i, compartments: n } = e; for (var r of t.effects) r.is(D.reconfigure) ? (e && (n = new Map, e.compartments.forEach((t, e) => n.set(e, t)), e = null), n.set(r.value.compartment, r.value.extension)) : r.is(rt.reconfigure) ? (e = null, i = r.value) : r.is(rt.appendConfig) && (e = null, i = ct(i).concat(r.value)); new pt(e || I.resolve(i, n, this), t.newDoc, t.newSelection, t) } replaceSelection(e) { return "string" == typeof e && (e = this.toText(e)), this.changeByRange(t => ({ changes: { from: t.from, to: t.to, insert: e }, range: _.cursor(t.from + e.length) })) } changeByRange(r) { var s = this.selection, t = r(s.ranges[0]); let o = this.changes(t.changes), a = [t.range], l = ct(t.effects); for (let n = 1; n < s.ranges.length; n++) { let t = r(s.ranges[n]), e = this.changes(t.changes), i = e.map(o); for (let t = 0; t < n; t++)a[t] = a[t].map(i); var h = o.mapDesc(e, !0); a.push(t.range.map(h)), o = o.compose(i), l = rt.mapEffects(l, i).concat(rt.mapEffects(ct(t.effects), h)) } return { changes: o, selection: _.create(a, s.mainIndex), effects: l } } changes(t = []) { return t instanceof k ? t : k.of(t, this.doc.length, this.facet(pt.lineSeparator)) } toText(t) { return d.of(t.split(this.facet(pt.lineSeparator) || v)) } sliceDoc(t = 0, e = this.doc.length) { return this.doc.sliceString(t, e, this.lineBreak) } facet(t) { var e = this.config.address[t.id]; return null == e ? t.default : (G(this, e), B(this, e)) } toJSON(e) { let i = { doc: this.sliceDoc(), selection: this.selection.toJSON() }; if (e) for (var n in e) { let t = e[n]; t instanceof M && (i[n] = t.spec.toJSON(this.field(e[n]), this)) } return i } static fromJSON(t, e = {}, n) { if (!t || "string" != typeof t.doc) throw new RangeError("Invalid JSON representation for EditorState"); let r = []; if (n) for (var s in n) { let e = n[s], i = t[s]; r.push(e.init(t => e.spec.fromJSON(i, t))) } return pt.create({ doc: t.doc, selection: _.fromJSON(t.selection), extensions: e.extensions ? r.concat([e.extensions]) : r }) } static create(t = {}) { let e = I.resolve(t.extensions || [], new Map); var i = t.doc instanceof d ? t.doc : d.of((t.doc || "").split(e.staticFacet(pt.lineSeparator) || v)); let n = t.selection ? t.selection instanceof _ ? t.selection : _.single(t.selection.anchor, t.selection.head) : _.single(0); return C(n, i.length), e.staticFacet(U) || (n = n.asSingle()), new pt(e, i, n) } get tabSize() { return this.facet(pt.tabSize) } get lineBreak() { return this.facet(pt.lineSeparator) || "\n" } phrase(t) { for (var e of this.facet(pt.phrases)) if (Object.prototype.hasOwnProperty.call(e, t)) return e[t]; return t } languageDataAt(t, e) { let i = []; for (var n of this.facet(N)) for (var r of n(this, e)) Object.prototype.hasOwnProperty.call(r, t) && i.push(r[t]); return i } charCategorizer(t) { return ft(this.languageDataAt("wordChars", t).join("")) } wordAt(t) { let { text: e, from: i, length: n } = this.doc.lineAt(t), r = this.charCategorizer(t), s = t - i, o = t - i; for (; 0 < s;) { var a = b(e, s, !1); if (r(e.slice(a, s)) != Ot.Word) break; s = a } for (; o < n;) { var l = b(e, o); if (r(e.slice(o, l)) != Ot.Word) break; o = l } return s == o ? _.range(s + i, o + i) : null } } function mt(t, e, i = {}) { let n = {}; for (var r of t) for (var s of Object.keys(r)) { var o = r[s], a = n[s]; if (void 0 === a) n[s] = o; else if (a !== o && void 0 !== o) { if (!Object.hasOwnProperty.call(i, s)) throw new Error("Config merge conflict for field " + s); n[s] = i[s](a, o) } } for (var l in e) void 0 === n[l] && (n[l] = e[l]); return n } pt.allowMultipleSelections = U, pt.tabSize = L.define({ combine: t => t.length ? t[0] : 4 }), pt.lineSeparator = F, pt.phrases = L.define(), pt.languageData = N, pt.changeFilter = J, pt.transactionFilter = K, pt.transactionExtender = tt, D.reconfigure = rt.define(); const gt = "undefined" == typeof Symbol ? "__ͼ" : Symbol.for("ͼ"), Qt = "undefined" == typeof Symbol ? "__styleSet" + Math.floor(1e8 * Math.random()) : Symbol("styleSet"), vt = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : {}; class wt { constructor(t, e) { this.rules = []; let { finish: c } = e || {}; function O(t) { return /^@/.test(t) ? [t] : t.split(/,\s*/) } for (var i in t) !function t(i, e, n, r) { let s = [], o = /^@(\w+)\b/.exec(i[0]), a = o && "keyframes" == o[1]; if (o && null == e) return n.push(i[0] + ";"); for (var l in e) { var h = e[l]; if (/&/.test(l)) t(l.split(/,\s*/).map(e => i.map(t => e.replace(/&/, t))).reduce((t, e) => t.concat(e)), h, n); else if (h && "object" == typeof h) { if (!o) throw new RangeError("The value of a property (" + l + ") should be a primitive value."); t(O(l), h, s, a) } else null != h && s.push(l.replace(/_.*/, "").replace(/[A-Z]/g, t => "-" + t.toLowerCase()) + ": " + h + ";") } (s.length || a) && n.push((!c || o || r ? i : i.map(c)).join(", ") + " {" + s.join(" ") + "}") }(O(i), t[i], this.rules) } getRules() { return this.rules.join("\n") } static newName() { let t = vt[gt] || 1; return vt[gt] = t + 1, "ͼ" + t.toString(36) } static mount(t, e) { (t[Qt] || new yt(t)).mount(Array.isArray(e) ? e : [e]) } } let $t = null; class yt { constructor(e) { if (!e.head && e.adoptedStyleSheets && "undefined" != typeof CSSStyleSheet) { if ($t) return e.adoptedStyleSheets = [$t.sheet].concat(e.adoptedStyleSheets), e[Qt] = $t; this.sheet = new CSSStyleSheet, e.adoptedStyleSheets = [this.sheet].concat(e.adoptedStyleSheets), $t = this } else { this.styleTag = (e.ownerDocument || e).createElement("style"); let t = e.head || e; t.insertBefore(this.styleTag, t.firstChild) } this.modules = [], e[Qt] = this } mount(n) { let r = this.sheet, s = 0, o = 0; for (let i = 0; i < n.length; i++) { let e = n[i], t = this.modules.indexOf(e); if (t < o && -1 < t && (this.modules.splice(t, 1), o--, t = -1), -1 == t) { if (this.modules.splice(o++, 0, e), r) for (let t = 0; t < e.rules.length; t++)r.insertRule(e.rules[t], s++) } else { for (; o < t;)s += this.modules[o++].rules.length; s += e.rules.length, o++ } } if (!r) { let e = ""; for (let t = 0; t < this.modules.length; t++)e += this.modules[t].getRules() + "\n"; this.styleTag.textContent = e } } } class bt { eq(t) { return this == t } range(t, e = t) { return new xt(t, e, this) } } bt.prototype.startSide = bt.prototype.endSide = 0, bt.prototype.point = !1, bt.prototype.mapMode = w.TrackDel; class xt { constructor(t, e, i) { this.from = t, this.to = e, this.value = i } } function kt(t, e) { return t.from - e.from || t.value.startSide - e.value.startSide } class St { constructor(t, e, i, n) { this.from = t, this.to = e, this.value = i, this.maxPoint = n } get length() { return this.to[this.to.length - 1] } findIndex(i, n, r = 1e9 * n, s = 0) { if (i <= 0) return s; var o = n < 0 ? this.to : this.from; for (let t = s, e = o.length; ;) { if (t == e) return t; var a = t + e >> 1, l = o[a] - i || (n < 0 ? this.value[a].startSide : this.value[a].endSide) - r; if (a == t) return 0 <= l ? t : e; 0 <= l ? e = a : t = 1 + a } } between(i, n, r, s) { for (let t = this.findIndex(n, -1), e = this.findIndex(r, 1, void 0, t); t < e; t++)if (!1 === s(this.from[t] + i, this.to[t] + i, this.value[t])) return !1 } map(o, a) { let l = [], h = [], c = [], O = -1, d = -1; for (let s = 0; s < this.value.length; s++) { let t = this.value[s], e = this.from[s] + o, i = this.to[s] + o, n, r; if (e == i) { var u = a.mapPos(e, t.startSide, t.mapMode); if (null == u) continue; n = r = u } else if (n = a.mapPos(e, t.startSide), r = a.mapPos(i, t.endSide), n > r || n == r && 0 < t.startSide && t.endSide <= 0) continue; (r - n || t.endSide - t.startSide) < 0 || (O < 0 && (O = n), t.point && (d = Math.max(d, r - n)), l.push(t), h.push(n - O), c.push(r - O)) } return { mapped: l.length ? new St(h, c, l, d) : null, pos: O } } } class Pt { constructor(t, e, i = Pt.empty, n) { this.chunkPos = t, this.chunk = e, this.nextLayer = i, this.maxPoint = n } get length() { var t = this.chunk.length - 1; return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length) } get size() { if (this == Pt.empty) return 0; let t = this.nextLayer.size; for (var e of this.chunk) t += e.value.length; return t } chunkEnd(t) { return this.chunkPos[t] + this.chunk[t].length } update(t) { let { add: e = [], sort: i = !1, filterFrom: n = 0, filterTo: r = this.length } = t, s = t.filter; if (0 == e.length && !s) return this; if (i && e.slice().sort(kt), this == Pt.empty) return e.length ? Pt.of(e) : this; let o = new Wt(this, null, -1).goto(0), a = 0, l = [], h = new Tt; for (; o.value || a < e.length;) { var c; a < e.length && 0 <= (o.from - e[a].from || o.startSide - e[a].value.startSide) ? (c = e[a++], h.addInner(c.from, c.to, c.value) || l.push(c)) : 1 == o.rangeIndex && o.chunkIndex < this.chunk.length && (a == e.length || this.chunkEnd(o.chunkIndex) < e[a].from) && (!s || n > this.chunkEnd(o.chunkIndex) || r < this.chunkPos[o.chunkIndex]) && h.addChunk(this.chunkPos[o.chunkIndex], this.chunk[o.chunkIndex]) ? o.nextChunk() : ((!s || n > o.to || r < o.from || s(o.from, o.to, o.value)) && (h.addInner(o.from, o.to, o.value) || l.push(new xt(o.from, o.to, o.value))), o.next()) } return h.finishInner(this.nextLayer != Pt.empty || l.length ? this.nextLayer.update({ add: l, filter: s, filterFrom: n, filterTo: r }) : Pt.empty) } map(n) { if (0 == n.length || this == Pt.empty) return this; let r = [], s = [], o = -1; for (let i = 0; i < this.chunk.length; i++) { let t = this.chunkPos[i], e = this.chunk[i]; var a, l = n.touchesRange(t, t + e.length); !1 === l ? (o = Math.max(o, e.maxPoint), r.push(e), s.push(n.mapPos(t))) : !0 === l && ({ mapped: a, pos: l } = e.map(t, n), a && (o = Math.max(o, a.maxPoint), r.push(a), s.push(l))) } var t = this.nextLayer.map(n); return 0 == r.length ? t : new Pt(s, r, t, o) } between(n, r, s) { if (this != Pt.empty) { for (let i = 0; i < this.chunk.length; i++) { let t = this.chunkPos[i], e = this.chunk[i]; if (t <= r && n <= t + e.length && !1 === e.between(t, n - t, r - t, s)) return } this.nextLayer.between(n, r, s) } } iter(t = 0) { return Xt.from([this]).goto(t) } static iter(t, e = 0) { return Xt.from(t).goto(e) } static compare(e, i, t, n, r = -1) { var s = e.filter(t => 500 <= t.maxPoint || t != Pt.empty && i.indexOf(t) < 0 && t.maxPoint >= r), o = i.filter(t => 500 <= t.maxPoint || t != Pt.empty && e.indexOf(t) < 0 && t.maxPoint >= r), a = function (t, e) { let i = new Map; for (var n of t) for (let t = 0; t < n.chunk.length; t++)n.chunk[t].maxPoint < 500 && i.set(n.chunk[t], n.chunkPos[t]); let r = new Set; for (var s of e) for (let t = 0; t < s.chunk.length; t++)i.get(s.chunk[t]) == s.chunkPos[t] && r.add(s.chunk[t]); return r }(s, o); let l = new _t(s, a, r), h = new _t(o, a, r); t.iterGaps((t, e, i) => Ct(l, t, h, e, i, n)), t.empty && 0 == t.length && Ct(l, 0, h, 0, 0, n) } static spans(t, e, i, n, r = -1) { let s = new _t(t, null, r).goto(e), o = e, a = s.openStart; for (; ;) { var l = Math.min(s.to, i); if (s.point ? (n.point(o, l, s.point, s.activeForPoint(s.to), a), a = s.openEnd(l) + (s.to > l ? 1 : 0)) : l > o && (n.span(o, l, s.active, a), a = s.openEnd(l)), s.to > i) break; o = s.to, s.next() } return a } static of(t, e = !1) { let i = new Tt; for (var n of t instanceof xt ? [t] : e ? t.slice().sort(kt) : t) i.add(n.from, n.to, n.value); return i.finish() } } Pt.empty = new Pt([], [], null, -1), Pt.empty.nextLayer = Pt.empty; class Tt { constructor() { this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null } finishChunk(t) { this.chunks.push(new St(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []) } add(t, e, i) { this.addInner(t, e, i) || (this.nextLayer || (this.nextLayer = new Tt)).add(t, e, i) } addInner(t, e, i) { var n = t - this.lastTo || i.startSide - this.last.endSide; if (n <= 0 && (t - this.lastFrom || i.startSide - this.last.startSide) < 0) throw new Error("Ranges must be added sorted by `from` position and `startSide`"); return !(n < 0) && (250 == this.from.length && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(e - this.chunkStart), this.last = i, this.lastFrom = t, this.lastTo = e, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, e - t)), !0) } addChunk(t, e) { if ((t - this.lastTo || e.value[0].startSide - this.last.endSide) < 0) return !1; this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, e.maxPoint), this.chunks.push(e), this.chunkPos.push(t); var i = e.value.length - 1; return this.last = e.value[i], this.lastFrom = e.from[i] + t, this.lastTo = e.to[i] + t, !0 } finish() { return this.finishInner(Pt.empty) } finishInner(t) { if (this.from.length && this.finishChunk(!1), 0 == this.chunks.length) return t; t = new Pt(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint); return this.from = null, t } } class Wt { constructor(t, e, i, n = 0) { this.layer = t, this.skip = e, this.minPoint = i, this.rank = n } get startSide() { return this.value ? this.value.startSide : 0 } get endSide() { return this.value ? this.value.endSide : 0 } goto(t, e = -1e9) { return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, e, !1), this } gotoInner(t, e, i) { for (; this.chunkIndex < this.layer.chunk.length;) { var n = this.layer.chunk[this.chunkIndex]; if (!(this.skip && this.skip.has(n) || this.layer.chunkEnd(this.chunkIndex) < t || n.maxPoint < this.minPoint)) break; this.chunkIndex++, i = !1 } e = this.chunkIndex == this.layer.chunk.length ? 0 : this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], -1, e); (!i || this.rangeIndex < e) && (this.rangeIndex = e), this.next() } forward(t, e) { (this.to - t || this.endSide - e) < 0 && this.gotoInner(t, e, !0) } next() { for (; ;) { if (this.chunkIndex == this.layer.chunk.length) { this.from = this.to = 1e9, this.value = null; break } var t = this.layer.chunkPos[this.chunkIndex], e = this.layer.chunk[this.chunkIndex], i = t + e.from[this.rangeIndex]; if (this.from = i, this.to = t + e.to[this.rangeIndex], this.value = e.value[this.rangeIndex], ++this.rangeIndex == e.value.length) { if (this.chunkIndex++, this.skip) for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]);)this.chunkIndex++; this.rangeIndex = 0 } if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break } } nextChunk() { this.chunkIndex++, this.rangeIndex = 0, this.next() } compare(t) { return this.from - t.from || this.startSide - t.startSide || this.to - t.to || this.endSide - t.endSide } } class Xt { constructor(t) { this.heap = t } static from(i, n = null, r = -1) { let s = []; for (let e = 0; e < i.length; e++)for (let t = i[e]; t != Pt.empty; t = t.nextLayer)t.maxPoint >= r && s.push(new Wt(t, n, r, e)); return 1 == s.length ? s[0] : new Xt(s) } get startSide() { return this.value ? this.value.startSide : 0 } goto(t, e = -1e9) { for (var i of this.heap) i.goto(t, e); for (let t = this.heap.length >> 1; 0 <= t; t--)Rt(this.heap, t); return this.next(), this } forward(t, e) { for (var i of this.heap) i.forward(t, e); for (let t = this.heap.length >> 1; 0 <= t; t--)Rt(this.heap, t); (this.to - t || this.value.endSide - e) < 0 && this.next() } next() { if (0 == this.heap.length) this.from = this.to = 1e9, this.value = null, this.rank = -1; else { let t = this.heap[0]; this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), Rt(this.heap, 0) } } } function Rt(n, r) { for (let i = n[r]; ;) { let t = 1 + (r << 1); if (t >= n.length) break; let e = n[t]; if (t + 1 < n.length && 0 <= e.compare(n[t + 1]) && (e = n[t + 1], t++), i.compare(e) < 0) break; n[t] = i, n[r] = e, r = t } } class _t { constructor(t, e, i) { this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Xt.from(t, e, i) } goto(t, e = -1e9) { return this.cursor.goto(t, e), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = e, this.openStart = -1, this.next(), this } forward(t, e) { for (; -1 < this.minActive && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - e) < 0;)this.removeActive(this.minActive); this.cursor.forward(t, e) } removeActive(t) { At(this.active, t), At(this.activeTo, t), At(this.activeRank, t), this.minActive = zt(this.active, this.activeTo) } addActive(t) { let e = 0, { value: i, to: n, rank: r } = this.cursor; for (; e < this.activeRank.length && this.activeRank[e] <= r;)e++; Lt(this.active, e, i), Lt(this.activeTo, e, n), Lt(this.activeRank, e, r), t && Lt(t, e, this.cursor.from), this.minActive = zt(this.active, this.activeTo) } next() { var e = this.to, t = this.point; this.point = null; let i = this.openStart < 0 ? [] : null, n = 0; for (; ;) { var r = this.minActive; if (-1 < r && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) { if (this.activeTo[r] > e) { this.to = this.activeTo[r], this.endSide = this.active[r].endSide; break } this.removeActive(r), i && At(i, r) } else { if (!this.cursor.value) { this.to = this.endSide = 1e9; break } if (this.cursor.from > e) { this.to = this.cursor.from, this.endSide = this.cursor.startSide; break } r = this.cursor.value; if (r.point) { if (!(t && this.cursor.to == this.to && this.cursor.from < this.cursor.to && r.endSide == this.endSide)) { this.point = r, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = r.endSide, this.cursor.from < e && (n = 1), this.cursor.next(), this.to > e && this.forward(this.to, this.endSide); break } this.cursor.next() } else this.addActive(i), this.cursor.next() } } if (i) { let t = 0; for (; t < i.length && i[t] < e;)t++; this.openStart = t + n } } activeForPoint(e) { if (!this.active.length) return this.active; let i = []; for (let t = 0; t < this.active.length && !(this.activeRank[t] > this.pointRank); t++)(this.activeTo[t] > e || this.activeTo[t] == e && this.active[t].endSide > this.point.endSide) && i.push(this.active[t]); return i } openEnd(t) { let e = 0; for (; e < this.activeTo.length && this.activeTo[e] > t;)e++; return e } } function Ct(t, e, i, n, r, s) { t.goto(e), i.goto(n); var o = n + r; let a = n, l = n - e; for (; ;) { var h = t.to + l - i.to || t.endSide - i.endSide, c = h < 0 ? t.to + l : i.to, O = Math.min(c, o); if (t.point || i.point ? t.point && i.point && (t.point == i.point || t.point.eq(i.point)) || s.comparePoint(a, O, t.point, i.point) : O > a && !function (e, i) { if (e.length != i.length) return !1; for (let t = 0; t < e.length; t++)if (e[t] != i[t] && !e[t].eq(i[t])) return !1; return !0 }(t.active, i.active) && s.compareRange(a, O, t.active, i.active), o < c) break; a = c, h <= 0 && t.next(), 0 <= h && i.next() } } function At(i, n) { for (let t = n, e = i.length - 1; t < e; t++)i[t] = i[t + 1]; i.pop() } function Lt(e, i, t) { for (let t = e.length - 1; t >= i; t--)e[t + 1] = e[t]; e[i] = t } function zt(e, i) { let n = -1, r = 1e9; for (let t = 0; t < i.length; t++)(i[t] - r || e[t].endSide - e[n].endSide) < 0 && (n = t, r = i[t]); return n } for (var qt = { 8: "Backspace", 9: "Tab", 10: "Enter", 12: "NumLock", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 44: "PrintScreen", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Meta", 92: "Meta", 106: "*", 107: "+", 108: ",", 109: "-", 110: ".", 111: "/", 144: "NumLock", 145: "ScrollLock", 160: "Shift", 161: "Shift", 162: "Control", 163: "Control", 164: "Alt", 165: "Alt", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'", 229: "q" }, Vt = { 48: ")", 49: "!", 50: "@", 51: "#", 52: "$", 53: "%", 54: "^", 55: "&", 56: "*", 57: "(", 59: ":", 61: "+", 173: "_", 186: ":", 187: "+", 188: "<", 189: "_", 190: ">", 191: "?", 192: "~", 219: "{", 220: "|", 221: "}", 222: '"', 229: "Q" }, Yt = "undefined" != typeof navigator && /Chrome\/(\d+)/.exec(navigator.userAgent), Mt = "undefined" != typeof navigator && /Apple Computer/.test(navigator.vendor), Zt = "undefined" != typeof navigator && /Gecko\/\d+/.test(navigator.userAgent), Et = "undefined" != typeof navigator && /Mac/.test(navigator.platform), jt = "undefined" != typeof navigator && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), Dt = Yt && (Et || +Yt[1] < 57) || Zt && Et, Ht = 0; Ht < 10; Ht++)qt[48 + Ht] = qt[96 + Ht] = String(Ht); for (Ht = 1; Ht <= 24; Ht++)qt[Ht + 111] = "F" + Ht; for (var It, Ht = 65; Ht <= 90; Ht++)qt[Ht] = String.fromCharCode(Ht + 32), Vt[Ht] = String.fromCharCode(Ht); for (It in qt) Vt.hasOwnProperty(It) || (Vt[It] = qt[It]); function Gt(t) { return (t.getSelection ? t : document).getSelection() } function Bt(t, e) { return !!e && t.contains(1 != e.nodeType ? e.parentNode : e) } function Nt(t, e) { if (!e.anchorNode) return !1; try { return Bt(t, e.anchorNode) } catch (t) { return !1 } } function Ut(t) { return 3 == t.nodeType ? ae(t, 0, t.nodeValue.length).getClientRects() : 1 == t.nodeType ? t.getClientRects() : [] } function Ft(t, e, i, n) { return i && (Kt(t, e, i, n, -1) || Kt(t, e, i, n, 1)) } function Jt(t) { for (var e = 0; ; e++)if (!(t = t.previousSibling)) return e } function Kt(t, e, i, n, r) { for (; ;) { if (t == i && e == n) return !0; if (e == (r < 0 ? 0 : te(t))) { if ("DIV" == t.nodeName) return !1; var s = t.parentNode; if (!s || 1 != s.nodeType) return !1; e = Jt(t) + (r < 0 ? 0 : 1), t = s } else { if (1 != t.nodeType) return !1; t = t.childNodes[e + (r < 0 ? -1 : 0)], e = r < 0 ? te(t) : 0 } } } function te(t) { return (3 == t.nodeType ? t.nodeValue : t.childNodes).length } const ee = { left: 0, right: 0, top: 0, bottom: 0 }; function ie(t, e) { e = e ? t.left : t.right; return { left: e, right: e, top: t.top, bottom: t.bottom } } class ne { constructor() { this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0 } eq(t) { return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset } set(t) { this.anchorNode = t.anchorNode, this.anchorOffset = t.anchorOffset, this.focusNode = t.focusNode, this.focusOffset = t.focusOffset } } let re = null; function se(e) { if (e.setActive) return e.setActive(); if (re) return e.focus(re); let r = []; for (let t = e; t && (r.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode); if (e.focus(null == re ? { get preventScroll() { return re = { preventScroll: !0 }, !0 } } : void 0), !re) { re = !1; for (let n = 0; n < r.length;) { let t = r[n++], e = r[n++], i = r[n++]; t.scrollTop != e && (t.scrollTop = e), t.scrollLeft != i && (t.scrollLeft = i) } } } let oe; function ae(t, e, i = e) { let n = oe = oe || document.createRange(); return n.setEnd(t, i), n.setStart(t, e), n } function le(t, e, i) { i = { key: e, code: e, keyCode: i, which: i, cancelable: !0 }; let n = new KeyboardEvent("keydown", i); n.synthetic = !0, t.dispatchEvent(n); let r = new KeyboardEvent("keyup", i); return r.synthetic = !0, t.dispatchEvent(r), n.defaultPrevented || r.defaultPrevented } class he { constructor(t, e, i = !0) { this.node = t, this.offset = e, this.precise = i } static before(t, e) { return new he(t.parentNode, Jt(t), e) } static after(t, e) { return new he(t.parentNode, Jt(t) + 1, e) } } const ce = []; class Oe { constructor() { this.parent = null, this.dom = null, this.dirty = 2 } get editorView() { if (!this.parent) throw new Error("Accessing view in orphan content view"); return this.parent.editorView } get overrideDOMText() { return null } get posAtStart() { return this.parent ? this.parent.posBefore(this) : 0 } get posAtEnd() { return this.posAtStart + this.length } posBefore(t) { let e = this.posAtStart; for (var i of this.children) { if (i == t) return e; e += i.length + i.breakAfter } throw new RangeError("Invalid child in posBefore") } posAfter(t) { return this.posBefore(t) + t.length } coordsAt(t, e) { return null } sync(n) { var r, s; if (2 & this.dirty) { let t = this.dom, e = null; for (var o of this.children) o.dirty && (s = e ? e.nextSibling : t.firstChild, o.dom || !s || null !== (r = Oe.get(s)) && void 0 !== r && r.parent || o.reuseDOM(s), o.sync(n), o.dirty = 0), n && n.node == t && e != o.dom && (n.written = !0), function (t, e, i) { let n = e ? e.nextSibling : t.firstChild; if (i.parentNode == t) for (; n != i;)n = de(n); else t.insertBefore(i, n) }(t, e, o.dom), e = o.dom; let i = e ? e.nextSibling : t.firstChild; for (i && n && n.node == t && (n.written = !0); i;)i = de(i) } else if (1 & this.dirty) for (var t of this.children) t.dirty && (t.sync(n), t.dirty = 0) } reuseDOM(t) { return !1 } localPosFromDOM(e, i) { let n; if (e == this.dom) n = this.dom.childNodes[i]; else { let t = 0 == te(e) ? 0 : 0 == i ? -1 : 1; for (; ;) { var r = e.parentNode; if (r == this.dom) break; 0 == t && r.firstChild != r.lastChild && (t = e == r.firstChild ? -1 : 1), e = r } n = t < 0 ? e : e.nextSibling } if (n == this.dom.firstChild) return 0; for (; n && !Oe.get(n);)n = n.nextSibling; if (!n) return this.length; for (let t = 0, e = 0; ; t++) { var s = this.children[t]; if (s.dom == n) return e; e += s.length + s.breakAfter } } domBoundsAround(s, o, t = 0) { let a = -1, l = -1, h = -1, c = -1; for (let i = 0, n = t, r = t; i < this.children.length; i++) { let t = this.children[i], e = n + t.length; if (n < s && o < e) return t.domBoundsAround(s, o, n); if (s <= e && -1 == a && (a = i, l = n), n > o && t.dom.parentNode == this.dom) { h = i, c = r; break } r = e, n = e + t.breakAfter } return { from: l, to: c < 0 ? t + this.length : c, startDOM: (a ? this.children[a - 1].dom.nextSibling : null) || this.dom.firstChild, endDOM: h < this.children.length && 0 <= h ? this.children[h].dom : null } } markDirty(t = !1) { 2 & this.dirty || (this.dirty |= 2, this.markParentsDirty(t)) } markParentsDirty(e) { for (let t = this.parent; t; t = t.parent) { if (e && (t.dirty |= 2), 1 & t.dirty) return; t.dirty |= 1, e = !1 } } setParent(t) { this.parent != t && (this.parent = t, this.dirty && this.markParentsDirty(!0)) } setDOM(t) { (this.dom = t).cmView = this } get rootView() { for (let t = this; ;) { var e = t.parent; if (!e) return t; t = e } } replaceChildren(t, i, e = ce) { this.markDirty(); for (let e = t; e < i; e++) { let t = this.children[e]; t.parent == this && (t.parent = null) } this.children.splice(t, i - t, ...e); for (let t = 0; t < e.length; t++)e[t].setParent(this) } ignoreMutation(t) { return !1 } ignoreEvent(t) { return !1 } childCursor(t = this.length) { return new ue(this.children, t, this.children.length) } childPos(t, e = 1) { return this.childCursor().findPos(t, e) } toString() { var t = this.constructor.name.replace("View", ""); return t + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + ("Text" == t ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "") } static get(t) { return t.cmView } } function de(t) { var e = t.nextSibling; return t.parentNode.removeChild(t), e } Oe.prototype.breakAfter = 0; class ue { constructor(t, e, i) { this.children = t, this.pos = e, this.i = i, this.off = 0 } findPos(t, e = 1) { for (; ;) { if (t > this.pos || t == this.pos && (0 < e || 0 == this.i || this.children[this.i - 1].breakAfter)) return this.off = t - this.pos, this; var i = this.children[--this.i]; this.pos -= i.length + i.breakAfter } } } var [fe, pe] = "undefined" != typeof navigator ? [navigator, document] : [{ userAgent: "", vendor: "", platform: "" }, { documentElement: { style: {} } }], me = /Edge\/(\d+)/.exec(fe.userAgent), ge = /MSIE \d/.test(fe.userAgent), Qe = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(fe.userAgent), ve = !!(ge || Qe || me), we = !ve && /gecko\/(\d+)/i.test(fe.userAgent), $e = !ve && /Chrome\/(\d+)/.exec(fe.userAgent), ye = "webkitFontSmoothing" in pe.documentElement.style, be = !ve && /Apple Computer/.test(fe.vendor), xe = { mac: /Mac/.test(fe.platform), ie: ve, ie_version: ge ? pe.documentMode || 6 : Qe ? +Qe[1] : me ? +me[1] : 0, gecko: we, gecko_version: we ? +(/Firefox\/(\d+)/.exec(fe.userAgent) || [0, 0])[1] : 0, chrome: !!$e, chrome_version: $e ? +$e[1] : 0, ios: be && (/Mobile\/\w+/.test(fe.userAgent) || 2 < fe.maxTouchPoints), android: /Android\b/.test(fe.userAgent), webkit: ye, safari: be, webkit_version: ye ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0, tabSize: null != pe.documentElement.style.tabSize ? "tab-size" : "-moz-tab-size" }; const ke = []; class Se extends Oe { become(t) { return !1 } getSide() { return 0 } } Se.prototype.children = ke; class Pe extends Se { constructor(t) { super(), this.text = t } get length() { return this.text.length } createDOM(t) { this.setDOM(t || document.createTextNode(this.text)) } sync(t) { this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text) } reuseDOM(t) { return 3 == t.nodeType && (this.createDOM(t), !0) } merge(t, e, i) { return (!i || i instanceof Pe && !(256 < this.length - (e - t) + i.length)) && (this.text = this.text.slice(0, t) + (i ? i.text : "") + this.text.slice(e), this.markDirty(), !0) } slice(t) { return new Pe(this.text.slice(t)) } localPosFromDOM(t, e) { return t == this.dom ? e : e ? this.text.length : 0 } domAtPos(t) { return new he(this.dom, t) } domBoundsAround(t, e, i) { return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling } } coordsAt(t, e) { return We(this.dom, t, e) } } class Te extends Se { constructor(t, e = [], i = 0) { super(), this.mark = t, this.children = e, this.length = i; for (var n of e) n.setParent(this) } createDOM() { let t = document.createElement(this.mark.tagName); if (this.mark.class && (t.className = this.mark.class), this.mark.attrs) for (var e in this.mark.attrs) t.setAttribute(e, this.mark.attrs[e]); this.setDOM(t) } sync(t) { this.dom || this.createDOM(), super.sync(t) } merge(t, e, i, n, r) { return (!i || !(!(i instanceof Te && i.mark.eq(this.mark)) || t && n <= 0 || e < this.length && r <= 0)) && (_e(this, t, e, i ? i.children : ke, n - 1, r - 1), this.markDirty(), !0) } slice(t) { return new Te(this.mark, function (t, e) { let i = [], n = 0; for (var r of t) { var s = n + r.length; e < s && i.push(n < e ? r.slice(e - n) : r), n = s } return i }(this.children, t), this.length - t) } domAtPos(t) { return Ce(this.dom, this.children, t) } coordsAt(t, e) { return Ae(this, t, e) } } function We(t, e, i) { var n = t.nodeValue.length; let r = e = n < e ? n : e, s = e, o = 0; 0 == e && i < 0 || e == n && 0 <= i ? xe.chrome || xe.gecko || (o = e ? (r--, 1) : (s++, -1)) : i < 0 ? r-- : s++; t = ae(t, r, s).getClientRects(); if (!t.length) return ee; let a = t[(o ? o < 0 : 0 <= i) ? 0 : t.length - 1]; return xe.safari && !o && 0 == a.width && (a = Array.prototype.find.call(t, t => t.width) || a), o ? ie(a, o < 0) : a } class Xe extends Se { constructor(t, e, i) { super(), this.widget = t, this.length = e, this.side = i } static create(t, e, i) { return new (t.customView || Xe)(t, e, i) } slice(t) { return Xe.create(this.widget, this.length - t, this.side) } sync() { this.dom && this.widget.updateDOM(this.dom) || (this.setDOM(this.widget.toDOM(this.editorView)), this.dom.contentEditable = "false") } getSide() { return this.side } merge(t, e, i, n, r) { return !(i && (!(i instanceof Xe && this.widget.compare(i.widget)) || 0 < t && n <= 0 || e < this.length && r <= 0)) && (this.length = t + (i ? i.length : 0) + (this.length - e), !0) } become(t) { return t.length == this.length && t instanceof Xe && t.side == this.side && this.widget.constructor == t.widget.constructor && (this.widget.eq(t.widget) || this.markDirty(!0), this.widget = t.widget, !0) } ignoreMutation() { return !0 } ignoreEvent(t) { return this.widget.ignoreEvent(t) } get overrideDOMText() { if (0 == this.length) return d.empty; let t = this; for (; t.parent;)t = t.parent; let e = t.editorView, i = e && e.state.doc, n = this.posAtStart; return i ? i.slice(n, n + this.length) : d.empty } domAtPos(t) { return 0 == t ? he.before(this.dom) : he.after(this.dom, t == this.length) } domBoundsAround() { return null } coordsAt(e, t) { let i = this.dom.getClientRects(), n = null; if (!i.length) return ee; for (let t = 0 < e ? i.length - 1 : 0; n = i[t], !(0 < e ? 0 == t : t == i.length - 1 || n.top < n.bottom); t += 0 < e ? -1 : 1); return 0 == e && 0 < t || e == this.length && t <= 0 ? n : ie(n, 0 == e) } } class Re extends Xe { domAtPos(t) { return new he(this.widget.text, t) } sync() { this.dom || this.setDOM(this.widget.toDOM()) } localPosFromDOM(t, e) { return e ? 3 == t.nodeType ? Math.min(e, this.length) : this.length : 0 } ignoreMutation() { return !1 } get overrideDOMText() { return null } coordsAt(t, e) { return We(this.widget.text, t, e) } } function _e(t, e, i, n, r, s) { let o = t.childCursor(), { i: a, off: l } = o.findPos(i, 1), { i: h, off: c } = o.findPos(e, -1), O = e - i; for (var d of n) O += d.length; t.length += O; let { children: u } = t; if (h == a && c) { let t = u[h]; if (1 == n.length && t.merge(c, l, n[0], r, s)) return; if (0 == n.length) return void t.merge(c, l, null, r, s); let e = t.slice(l); e.merge(0, 0, n[n.length - 1], 0, s) ? n[n.length - 1] = e : n.push(e), a++, s = l = 0 } if (l) { let t = u[a]; n.length && t.merge(0, l, n[n.length - 1], 0, s) ? (n.pop(), s = n.length ? 0 : r) : t.merge(0, l, null, 0, 0) } else a < u.length && n.length && u[a].merge(0, 0, n[n.length - 1], 0, s) && (n.pop(), s = n.length ? 0 : r); if (c) { let t = u[h]; n.length && t.merge(c, t.length, n[0], r, 0) ? (n.shift(), r = n.length ? 0 : s) : t.merge(c, t.length, null, 0, 0), h++ } else if (h && n.length) { let t = u[h - 1]; t.merge(t.length, t.length, n[0], r, 0) && (n.shift(), r = n.length ? 0 : s) } for (; h < a && n.length && u[a - 1].become(n[n.length - 1]);)n.pop(), a--, s = n.length ? 0 : r; for (; h < a && n.length && u[h].become(n[0]);)n.shift(), h++, r = n.length ? 0 : s; !n.length && h && a < u.length && r && s && u[a].merge(0, 0, u[h - 1], r, s) && h--, !n.length && h == a || t.replaceChildren(h, a, n) } function Ce(n, r, s) { let o = 0; for (let i = 0; o < r.length; o++) { let t = r[o], e = i + t.length; if (!(e == i && t.getSide() <= 0)) { if (s > i && s < e && t.dom.parentNode == n) return t.domAtPos(s - i); if (s <= i) break; i = e } } for (; 0 < o; o--) { var t = r[o - 1].dom; if (t.parentNode == n) return he.after(t) } return new he(n, 0) } function Ae(r, s, o) { for (let i = 0, n = 0; n < r.children.length; n++) { let t = r.children[n], e = i + t.length; if (!(e == i && t.getSide() <= 0)) { if (o <= 0 || e == r.length ? s <= e : s < e) return t.coordsAt(s - i, o); i = e } } var t = r.dom.lastChild; if (!t) return r.dom.getBoundingClientRect(); t = Ut(t); return t[t.length - 1] } function Le(t, e) { for (var i in t) "class" == i && e.class ? e.class += " " + t.class : "style" == i && e.style ? e.style += ";" + t.style : e[i] = t[i]; return e } function ze(t, e) { if (t == e) return !0; if (!t || !e) return !1; let i = Object.keys(t), n = Object.keys(e); if (i.length != n.length) return !1; for (var r of i) if (-1 == n.indexOf(r) || t[r] !== e[r]) return !1; return !0 } function qe(t, e, i) { if (e) for (var n in e) i && n in i || t.removeAttribute(n); if (i) for (var r in i) e && e[r] == i[r] || t.setAttribute(r, i[r]) } class Ve { eq(t) { return !1 } updateDOM(t) { return !1 } compare(t) { return this == t || this.constructor == t.constructor && this.eq(t) } get estimatedHeight() { return -1 } ignoreEvent(t) { return !0 } get customView() { return null } } var Ye = function (t) { return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t }(Ye = Ye || {}); class Me extends bt { constructor(t, e, i, n) { super(), this.startSide = t, this.endSide = e, this.widget = i, this.spec = n } get heightRelevant() { return !1 } static mark(t) { return new Ze(t) } static widget(t) { let e = t.side || 0; return t.block && (e += (2e8 + 1) * (0 < e ? 1 : -1)), new je(t, e, e, !!t.block, t.widget || null, !1) } static replace(t) { var e = !!t.block, { start: i, end: n } = De(t), i = e ? -2e8 * (i ? 2 : 1) : 1e8 * (i ? -1 : 1), n = e ? 2e8 * (n ? 2 : 1) : 1e8 * (n ? 1 : -1); return new je(t, i, n, e, t.widget || null, !0) } static line(t) { return new Ee(t) } static set(t, e = !1) { return Pt.of(t, e) } hasHeight() { return !!this.widget && -1 < this.widget.estimatedHeight } } Me.none = Pt.empty; class Ze extends Me { constructor(t) { var { start: e, end: i } = De(t); super(1e8 * (e ? -1 : 1), 1e8 * (i ? 1 : -1), null, t), this.tagName = t.tagName || "span", this.class = t.class || "", this.attrs = t.attributes || null } eq(t) { return this == t || t instanceof Ze && this.tagName == t.tagName && this.class == t.class && ze(this.attrs, t.attrs) } range(t, e = t) { if (e <= t) throw new RangeError("Mark decorations may not be empty"); return super.range(t, e) } } Ze.prototype.point = !1; class Ee extends Me { constructor(t) { super(-1e8, -1e8, null, t) } eq(t) { return t instanceof Ee && ze(this.spec.attributes, t.spec.attributes) } range(t, e = t) { if (e != t) throw new RangeError("Line decoration ranges must be zero-length"); return super.range(t, e) } } Ee.prototype.mapMode = w.TrackBefore, Ee.prototype.point = !0; class je extends Me { constructor(t, e, i, n, r, s) { super(e, i, r, t), this.block = n, this.isReplace = s, this.mapMode = n ? e < 0 ? w.TrackBefore : w.TrackAfter : w.TrackDel } get type() { return this.startSide < this.endSide ? Ye.WidgetRange : this.startSide < 0 ? Ye.WidgetBefore : Ye.WidgetAfter } get heightRelevant() { return this.block || !!this.widget && 5 <= this.widget.estimatedHeight } eq(t) { return t instanceof je && (e = this.widget, i = t.widget, e == i || !!(e && i && e.compare(i))) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide; var e, i } range(t, e = t) { if (this.isReplace && (e < t || t == e && 0 < this.startSide && this.endSide < 0)) throw new RangeError("Invalid range for replacement decoration"); if (!this.isReplace && e != t) throw new RangeError("Widget decorations can only have zero-length ranges"); return super.range(t, e) } } function De(t) { let { inclusiveStart: e, inclusiveEnd: i } = t; return null == e && (e = t.inclusive), null == i && (i = t.inclusive), { start: e || !1, end: i || !1 } } function He(t, e, i, n = 0) { var r = i.length - 1; 0 <= r && i[r] + n > t ? i[r] = Math.max(i[r], e) : i.push(t, e) } je.prototype.point = !0; class Ie extends Oe { constructor() { super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0 } merge(t, e, i, n, r, s) { if (i) { if (!(i instanceof Ie)) return !1; this.dom || i.transferDOM(this) } return n && this.setDeco(i ? i.attrs : null), _e(this, t, e, i ? i.children : Ge, r, s), !0 } split(t) { let e = new Ie; if (e.breakAfter = this.breakAfter, 0 == this.length) return e; let { i, off: n } = this.childPos(t); n && (e.append(this.children[i].slice(n), 0), this.children[i].merge(n, this.children[i].length, null, 0, 0), i++); for (let t = i; t < this.children.length; t++)e.append(this.children[t], 0); for (; 0 < i && 0 == this.children[i - 1].length;)this.children[i - 1].parent = null, i--; return this.children.length = i, this.markDirty(), this.length = t, e } transferDOM(t) { this.dom && (t.setDOM(this.dom), t.prevAttrs = void 0 === this.prevAttrs ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null) } setDeco(t) { ze(this.attrs, t) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t) } append(t, e) { !function t(e, i, n) { let r, { children: s } = e; 0 < n && i instanceof Te && s.length && (r = s[s.length - 1]) instanceof Te && r.mark.eq(i.mark) ? t(r, i.children[0], n - 1) : (s.push(i), i.setParent(e)), e.length += i.length }(this, t, e) } addLineDeco(t) { t = t.spec.attributes; t && (this.attrs = Le(t, this.attrs || {})) } domAtPos(t) { return Ce(this.dom, this.children, t) } sync(t) { this.dom || (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), void 0 !== this.prevAttrs && (qe(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t); t = this.dom.lastChild; if (!t || "BR" != t.nodeName && Oe.get(t) instanceof Xe && (!xe.ios || !this.children.some(t => t instanceof Pe))) { let t = document.createElement("BR"); t.cmIgnore = !0, this.dom.appendChild(t) } } measureTextSize() { if (0 == this.children.length || 20 < this.length) return null; let t = 0; for (var e of this.children) { if (!(e instanceof Pe)) return null; e = Ut(e.dom); if (1 != e.length) return null; t += e[0].width } return { lineHeight: this.dom.getBoundingClientRect().height, charWidth: t / this.length } } coordsAt(t, e) { return Ae(this, t, e) } match(t) { return !1 } get type() { return Ye.Text } static find(i, n) { for (let t = 0, e = 0; ; t++) { var r = i.children[t], s = e + r.length; if (n <= s) { if (r instanceof Ie) return r; if (r.length) return null } e = s + r.breakAfter } } } const Ge = []; class Be extends Oe { constructor(t, e, i) { super(), this.widget = t, this.length = e, this.type = i, this.breakAfter = 0 } merge(t, e, i, n, r, s) { return !(i && (!(i instanceof Be && this.widget.compare(i.widget)) || 0 < t && r <= 0 || e < this.length && s <= 0)) && (this.length = t + (i ? i.length : 0) + (this.length - e), !0) } domAtPos(t) { return 0 == t ? he.before(this.dom) : he.after(this.dom, t == this.length) } split(t) { var e = this.length - t; return this.length = t, new Be(this.widget, e, this.type) } get children() { return Ge } sync() { this.dom && this.widget.updateDOM(this.dom) || (this.setDOM(this.widget.toDOM(this.editorView)), this.dom.contentEditable = "false") } get overrideDOMText() { return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : d.empty } domBoundsAround() { return null } match(t) { return t instanceof Be && t.type == this.type && t.widget.constructor == this.widget.constructor && (t.widget.eq(this.widget) || this.markDirty(!0), this.widget = t.widget, this.length = t.length, this.breakAfter = t.breakAfter, !0) } ignoreMutation() { return !0 } ignoreEvent(t) { return this.widget.ignoreEvent(t) } } class Ne { constructor(t, e, i) { this.doc = t, this.pos = e, this.end = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t.iter(), this.skip = e } posCovered() { if (0 == this.content.length) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos; var t = this.content[this.content.length - 1]; return !(t.breakAfter || t instanceof Be && t.type == Ye.WidgetBefore) } getLine() { return this.curLine || this.content.push(this.curLine = new Ie), this.curLine } addWidget(t) { this.curLine = null, this.content.push(t) } finish() { this.posCovered() || this.getLine() } wrapMarks(e, i) { for (let t = i.length - 1; 0 <= t; t--)e = new Te(i[t], [e], e.length); return e } buildText(t, e, i) { for (; 0 < t;) { if (this.textOff == this.text.length) { var { value: n, lineBreak: r, done: s } = this.cursor.next(this.skip); if (this.skip = 0, s) throw new Error("Ran out of text content when drawing inline views"); if (r) { this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.curLine = null, t--; continue } this.text = n, this.textOff = 0 } n = Math.min(this.text.length - this.textOff, t, 512); this.getLine().append(this.wrapMarks(new Pe(this.text.slice(this.textOff, this.textOff + n)), e), i), this.textOff += n, t -= n, i = 0 } } span(t, e, i, n) { this.buildText(e - t, i, n), this.pos = e, this.openStart < 0 && (this.openStart = n) } point(t, e, i, n, r) { var s = e - t; i instanceof je ? i.block ? ({ type: t } = i, t != Ye.WidgetAfter || this.posCovered() || this.getLine(), this.addWidget(new Be(i.widget || new Ue("div"), s, t))) : (n = this.wrapMarks(Xe.create(i.widget || new Ue("span"), s, i.startSide), n), this.getLine().append(n, r)) : this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i), s && (this.textOff + s <= this.text.length ? this.textOff += s : (this.skip += s - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e), this.openStart < 0 && (this.openStart = r) } static build(t, e, i, n) { let r = new Ne(t, e, i); return r.openEnd = Pt.spans(n, e, i, r), r.openStart < 0 && (r.openStart = r.openEnd), r.finish(), r } } class Ue extends Ve { constructor(t) { super(), this.tag = t } eq(t) { return t.tag == this.tag } toDOM() { return document.createElement(this.tag) } updateDOM(t) { return t.nodeName.toLowerCase() == this.tag } } const Fe = [], Je = L.define(), Ke = L.define(), ti = L.define(), ei = L.define(), ii = L.define(), ni = L.define(); function ri(t, e, i) { let n = t.facet(ei); n.length ? n[0](e) : window.onerror ? window.onerror(String(e), i, void 0, void 0, e) : i ? console.error(i + ":", e) : console.error(e) } const si = L.define({ combine: t => !t.length || t[0] }); class oi { constructor(t, e) { this.field = t, this.get = e } } class ai { from(t) { return new oi(this, t) } static define() { return new ai } } ai.decorations = ai.define(), ai.scrollMargins = ai.define(); let li = 0; const hi = L.define(); class ci { constructor(t, e, i) { this.id = t, this.create = e, this.fields = i, this.extension = hi.of(this) } static define(t, e) { let { eventHandlers: i, provide: n, decorations: r } = e || {}, s = []; if (n) for (var o of Array.isArray(n) ? n : [n]) s.push(o); return i && s.push(Oi.from(t => ({ plugin: t, handlers: i }))), r && s.push(ai.decorations.from(r)), new ci(li++, t, s) } static fromClass(e, t) { return ci.define(t => new e(t), t) } } const Oi = ai.define(); class di { constructor(t) { this.spec = t, this.mustUpdate = null, this.value = null } takeField(t, e) { for (var { field: i, get: n } of this.spec.fields) i == t && e.push(n(this.value)) } update(e) { if (this.value) { if (this.mustUpdate) { var i = this.mustUpdate; if (this.mustUpdate = null, !this.value.update) return this; try { this.value.update(i) } catch (t) { if (ri(i.state, t, "CodeMirror plugin crashed"), this.value.destroy) try { this.value.destroy() } catch (t) { } return di.dummy } } } else try { this.value = this.spec.create(e) } catch (t) { return ri(e.state, t, "CodeMirror plugin crashed"), di.dummy } return this } destroy(e) { var t; if (null !== (t = this.value) && void 0 !== t && t.destroy) try { this.value.destroy() } catch (t) { ri(e.state, t, "CodeMirror plugin crashed") } } } di.dummy = new di(ci.define(() => ({}))); const ui = L.define({ combine: t => t.reduce((t, e) => Le(e, t), {}) }), fi = L.define({ combine: t => t.reduce((t, e) => Le(e, t), {}) }), pi = L.define(), mi = L.define(); class gi { constructor(t, e, i, n) { this.fromA = t, this.toA = e, this.fromB = i, this.toB = n } join(t) { return new gi(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB)) } addToSet(t) { let e = t.length, i = this; for (; 0 < e; e--) { var n = t[e - 1]; if (!(n.fromA > i.toA)) { if (n.toA < i.fromA) break; i = i.join(n), t.splice(e - 1, 1) } } return t.splice(e, 0, i), t } static extendWithRanges(r, s) { if (0 == s.length) return r; var o = []; for (let t = 0, e = 0, i = 0, n = 0; ; t++) { for (var a = t == r.length ? null : r[t], l = i - n, h = a ? a.fromB : 1e9; e < s.length && s[e] < h;) { var c = s[e], O = s[e + 1], d = Math.max(n, c), c = Math.min(h, O); if (d <= c && new gi(d + l, c + l, d, c).addToSet(o), h < O) break; e += 2 } if (!a) return o; new gi(a.fromA, a.toA, a.fromB, a.toB).addToSet(o), i = a.toA, n = a.toB } } } class Qi { constructor(t, e, i = Fe) { this.view = t, this.state = e, this.transactions = i, this.flags = 0, this.startState = t.state, this.changes = k.empty(this.startState.doc.length); for (var n of i) this.changes = this.changes.compose(n.changes); let r = []; this.changes.iterChangedRanges((t, e, i, n) => r.push(new gi(t, e, i, n))), this.changedRanges = r; i = t.hasFocus; i != t.inputState.notifiedFocused && (t.inputState.notifiedFocused = i, this.flags |= 1), this.docChanged && (this.flags |= 2) } get viewportChanged() { return 0 < (4 & this.flags) } get heightChanged() { return 0 < (2 & this.flags) } get geometryChanged() { return this.docChanged || 0 < (18 & this.flags) } get focusChanged() { return 0 < (1 & this.flags) } get docChanged() { return this.transactions.some(t => t.docChanged) } get selectionSet() { return this.transactions.some(t => t.selection) } get empty() { return 0 == this.flags && 0 == this.transactions.length } } class vi extends Oe { constructor(t) { super(), this.view = t, this.compositionDeco = Me.none, this.decorations = [], this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.setDOM(t.contentDOM), this.children = [new Ie], this.children[0].setParent(this), this.updateInner([new gi(0, 0, 0, t.state.doc.length)], this.updateDeco(), 0) } get root() { return this.view.root } get editorView() { return this.view } get length() { return this.view.state.doc.length } update(t) { let e = t.changedRanges; 0 < this.minWidth && e.length && (e.every(({ fromA: t, toA: e }) => e < this.minWidthFrom || t > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = 0), this.view.inputState.composing < 0 ? this.compositionDeco = Me.none : t.transactions.length && (this.compositionDeco = function (t, e) { var i = t.observer.selectionRange, i = i.focusNode && yi(i.focusNode, i.focusOffset, 0); if (!i) return Me.none; let n = t.docView.nearest(i), r, s, o = i; if (n instanceof Se) { for (; n.parent instanceof Se;)n = n.parent; r = n.posAtStart, s = r + n.length, o = n.dom } else { if (!(n instanceof Ie)) return Me.none; { for (; o.parentNode != n.dom;)o = o.parentNode; let t = o.previousSibling; for (; t && !Oe.get(t);)t = t.previousSibling; r = s = t ? Oe.get(t).posAtEnd : n.posAtStart } } let a = e.mapPos(r, 1), l = Math.max(a, e.mapPos(s, -1)), h = i.nodeValue, { state: c } = t; if (l - a < h.length) if (c.sliceDoc(a, Math.min(c.doc.length, a + h.length)) == h) l = a + h.length; else { if (c.sliceDoc(Math.max(0, l - h.length), l) != h) return Me.none; a = l - h.length } else if (c.sliceDoc(a, l) != h) return Me.none; return Me.set(Me.replace({ widget: new $i(o, i) }).range(a, l)) }(this.view, t.changes)); var i, n, r, s = (xe.ie || xe.chrome) && !this.compositionDeco.size && t && t.state.doc.lines != t.startState.doc.lines, o = this.decorations, a = this.updateDeco(), o = (i = o, n = a, r = t.changes, o = new xi, Pt.compare(i, n, r, o), o.changes); e = gi.extendWithRanges(e, o); o = t.transactions.some(t => "pointerselection" == t.annotation(st.userEvent)); return 0 == this.dirty && 0 == e.length && !(12 & t.flags) && t.state.selection.main.from >= this.view.viewport.from && t.state.selection.main.to <= this.view.viewport.to ? (this.updateSelection(s, o), !1) : (this.updateInner(e, a, t.startState.doc.length, s, o), !0) } updateInner(t, e, i, n = !1, r = !1) { this.updateChildren(t, e, i); let { observer: s } = this.view; s.ignore(() => { this.dom.style.height = this.view.viewState.domHeight + "px", this.dom.style.minWidth = this.minWidth ? this.minWidth + "px" : ""; var t = xe.chrome || xe.ios ? { node: s.selectionRange.focusNode, written: !1 } : void 0; this.sync(t), this.dirty = 0, t && (t.written || s.selectionRange.focusNode != t.node) && (n = !0), this.updateSelection(n, r), this.dom.style.height = "" }) } updateChildren(e, i, t) { let n = this.childCursor(t); for (let t = e.length - 1; ; t--) { var r = 0 <= t ? e[t] : null; if (!r) break; var { fromA: s, toA: o, fromB: a, toB: l } = r, { content: h, breakAtStart: c, openStart: O, openEnd: r } = Ne.build(this.view.state.doc, a, l, i), { i: a, off: l } = n.findPos(o, 1), { i: o, off: s } = n.findPos(s, -1); this.replaceRange(o, s, a, l, h, c, O, r) } } replaceRange(e, i, n, r, s, o, a, l) { let h = this.children[e], c = s.length ? s[s.length - 1] : null; var O = c ? c.breakAfter : o; if (e != n || o || O || !(s.length < 2) || !h.merge(i, r, s.length ? c : null, 0 == i, a, l)) { let t = this.children[n]; for (r < t.length || t.children.length && 0 == t.children[t.children.length - 1].length ? (e == n && (t = t.split(r), r = 0), !O && c && t.merge(0, r, c, !0, 0, l) ? s[s.length - 1] = t : ((r || t.children.length && 0 == t.children[0].length) && t.merge(0, r, null, !1, 0, l), s.push(t))) : t.breakAfter && (c ? c.breakAfter = 1 : o = 1), n++, h.breakAfter = o, 0 < i && (!o && s.length && h.merge(i, h.length, s[0], !1, a, 0) ? h.breakAfter = s.shift().breakAfter : (i < h.length || h.children.length && 0 == h.children[h.children.length - 1].length) && h.merge(i, h.length, null, !1, a, 0), e++); e < n && s.length;)if (this.children[n - 1].match(s[s.length - 1])) n--, s.pop(); else { if (!this.children[e].match(s[0])) break; e++, s.shift() } (e < n || s.length) && this.replaceChildren(e, n, s) } } updateSelection(e = !1, t = !1) { if (t || this.mayControlSelection()) { let n = this.view.state.selection.main, r = this.domAtPos(n.anchor), s = n.empty ? r : this.domAtPos(n.head); if (xe.gecko && n.empty && (1 == (t = r).node.nodeType && t.node.firstChild && (0 == t.offset || "false" == t.node.childNodes[t.offset - 1].contentEditable) && (t.offset < t.node.childNodes.length || "false" == t.node.childNodes[t.offset].contentEditable))) { let t = document.createTextNode(""); this.view.observer.ignore(() => r.node.insertBefore(t, r.node.childNodes[r.offset] || null)), r = s = new he(t, 0), e = !0 } let o = this.view.observer.selectionRange; !(e || !o.focusNode || xe.gecko && n.empty && bi(o.focusNode, o.focusOffset)) && Ft(r.node, r.offset, o.anchorNode, o.anchorOffset) && Ft(s.node, s.offset, o.focusNode, o.focusOffset) || (this.view.observer.ignore(() => { let e = Gt(this.root); var t, i; if (n.empty) xe.gecko && (!(t = bi(r.node, r.offset)) || 3 == t || (i = yi(r.node, r.offset, 1 == t ? 1 : -1)) && (r = new he(i, 1 == t ? 0 : i.nodeValue.length))), e.collapse(r.node, r.offset), null != n.bidiLevel && null != o.cursorBidiLevel && (o.cursorBidiLevel = n.bidiLevel); else if (e.extend) e.collapse(r.node, r.offset), e.extend(s.node, s.offset); else { let t = document.createRange(); n.anchor > n.head && ([r, s] = [s, r]), t.setEnd(s.node, s.offset), t.setStart(r.node, r.offset), e.removeAllRanges(), e.addRange(t) } }), this.view.observer.setSelectionRange(r, s)), this.impreciseAnchor = r.precise ? null : new he(o.anchorNode, o.anchorOffset), this.impreciseHead = s.precise ? null : new he(o.focusNode, o.focusOffset) } } enforceCursorAssoc() { var t, e, i = this.view.state.selection.main; let n = Gt(this.root); i.empty && i.assoc && n.modify && ((e = Ie.find(this, i.head)) && (t = e.posAtStart, i.head != t && i.head != t + e.length && (t = this.coordsAt(i.head, -1), e = this.coordsAt(i.head, 1), !t || !e || t.bottom > e.top || (e = this.domAtPos(i.head + i.assoc), n.collapse(e.node, e.offset), n.modify("move", i.assoc < 0 ? "forward" : "backward", "lineboundary"))))) } mayControlSelection() { return this.view.state.facet(si) ? this.root.activeElement == this.dom : Nt(this.dom, this.view.observer.selectionRange) } nearest(e) { for (let t = e; t;) { var i = Oe.get(t); if (i && i.rootView == this) return i; t = t.parentNode } return null } posFromDOM(t, e) { let i = this.nearest(t); if (!i) throw new RangeError("Trying to find position for a DOM position outside of the document"); return i.localPosFromDOM(t, e) + i.posAtStart } domAtPos(t) { let { i: e, off: i } = this.childCursor().findPos(t, -1); for (; e < this.children.length - 1;) { var n = this.children[e]; if (i < n.length || n instanceof Ie) break; e++, i = 0 } return this.children[e].domAtPos(i) } coordsAt(r, s) { for (let i = this.length, n = this.children.length - 1; ; n--) { let t = this.children[n], e = i - t.breakAfter - t.length; if (e < r || r == e && (t.type == Ye.Text || !n || this.children[n - 1].breakAfter)) return t.coordsAt(r - e, s); i = e } } measureVisibleLineHeights() { let r = [], { from: s, to: o } = this.view.viewState.viewport, a = Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1; for (let i = 0, n = 0; n < this.children.length; n++) { let t = this.children[n], e = i + t.length; if (o < e) break; var l; i >= s && (r.push(t.dom.getBoundingClientRect().height), (l = t.dom.scrollWidth) > a && (this.minWidth = a = l, this.minWidthFrom = i, this.minWidthTo = e)), i = e + t.breakAfter } return r } measureTextSize() { for (var t of this.children) if (t instanceof Ie) { t = t.measureTextSize(); if (t) return t } let e = document.createElement("div"), i, n; return e.className = "cm-line", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => { this.dom.appendChild(e); var t = Ut(e.firstChild)[0]; i = e.getBoundingClientRect().height, n = t ? t.width / 27 : 7, e.remove() }), { lineHeight: i, charWidth: n } } childCursor(t = this.length) { let e = this.children.length; return e && (t -= this.children[--e].length), new ue(this.children, t, e) } computeBlockGapDeco() { let i = [], n = this.view.viewState; for (let t = 0, e = 0; ; e++) { var r, s = e == n.viewports.length ? null : n.viewports[e], o = s ? s.from - 1 : this.length; if (o > t && (r = n.lineAt(o, 0).bottom - n.lineAt(t, 0).top, i.push(Me.replace({ widget: new wi(r), block: !0, inclusive: !0 }).range(t, o))), !s) break; t = s.to + 1 } return Me.set(i) } updateDeco() { return this.decorations = [this.computeBlockGapDeco(), this.view.viewState.lineGapDeco, this.compositionDeco, ...this.view.state.facet(pi), ...this.view.pluginField(ai.decorations)] } scrollPosIntoView(t, r) { var s, o, a, r = this.coordsAt(t, r); if (r) { let t = 0, e = 0, i = 0, n = 0; for (var l of this.view.pluginField(ai.scrollMargins)) l && ({ left: s, right: o, top: a, bottom: l } = l, null != s && (t = Math.max(t, s)), null != o && (e = Math.max(e, o)), null != a && (i = Math.max(i, a)), null != l && (n = Math.max(n, l))); !function (t, s) { let e = t.ownerDocument, o = e.defaultView; for (let r = t.parentNode; r;)if (1 == r.nodeType) { let t, e = r == document.body; if (e) t = { left: 0, right: (l = o).innerWidth, top: 0, bottom: l.innerHeight }; else { if (r.scrollHeight <= r.clientHeight && r.scrollWidth <= r.clientWidth) { r = r.parentNode; continue } l = r.getBoundingClientRect(); t = { left: l.left, right: l.left + r.clientWidth, top: l.top, bottom: l.top + r.clientHeight } } let i = 0, n = 0; var a; if (s.top < t.top ? n = -(t.top - s.top + 5) : s.bottom > t.bottom && (n = s.bottom - t.bottom + 5), s.left < t.left ? i = -(t.left - s.left + 5) : s.right > t.right && (i = s.right - t.right + 5), (i || n) && (e ? o.scrollBy(i, n) : (n && (a = r.scrollTop, r.scrollTop += n, n = r.scrollTop - a), i && (a = r.scrollLeft, r.scrollLeft += i, i = r.scrollLeft - a), s = { left: s.left - i, top: s.top - n, right: s.right - i, bottom: s.bottom - n })), e) break; r = r.assignedSlot || r.parentNode } else { if (11 != r.nodeType) break; r = r.host } var l }(this.dom, { left: r.left - t, top: r.top - i, right: r.right + e, bottom: r.bottom + n }) } } } class wi extends Ve { constructor(t) { super(), this.height = t } toDOM() { var t = document.createElement("div"); return this.updateDOM(t), t } eq(t) { return t.height == this.height } updateDOM(t) { return t.style.height = this.height + "px", !0 } get estimatedHeight() { return this.height } } class $i extends Ve { constructor(t, e) { super(), this.top = t, this.text = e } eq(t) { return this.top == t.top && this.text == t.text } toDOM() { return this.top } ignoreEvent() { return !1 } get customView() { return Re } } function yi(t, e, i) { for (; ;) { if (3 == t.nodeType) return t; if (1 == t.nodeType && 0 < e && i <= 0) e = te(t = t.childNodes[e - 1]); else { if (!(1 == t.nodeType && e < t.childNodes.length && 0 <= i)) return null; t = t.childNodes[e], e = 0 } } } function bi(t, e) { return 1 != t.nodeType ? 0 : (e && "false" == t.childNodes[e - 1].contentEditable ? 1 : 0) | (e < t.childNodes.length && "false" == t.childNodes[e].contentEditable ? 2 : 0) } class xi { constructor() { this.changes = [] } compareRange(t, e) { He(t, e, this.changes) } comparePoint(t, e) { He(t, e, this.changes) } } var ki, Si = function (t) { return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t }(Si = Si || {}); const Pi = Si.LTR, Ti = Si.RTL; function Wi(e) { let i = []; for (let t = 0; t < e.length; t++)i.push(1 << +e[t]); return i } const Xi = Wi("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), Ri = Wi("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), _i = Object.create(null), Ci = []; for (ki of ["()", "[]", "{}"]) { var Ai = ki.charCodeAt(0), Li = ki.charCodeAt(1); _i[Ai] = Li, _i[Li] = -Ai } const zi = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/; class qi { constructor(t, e, i) { this.from = t, this.to = e, this.level = i } get dir() { return this.level % 2 ? Ti : Pi } side(t, e) { return this.dir == e == t ? this.to : this.from } static find(e, i, n, r) { let s = -1; for (let t = 0; t < e.length; t++) { var o = e[t]; if (o.from <= i && o.to >= i) { if (o.level == n) return t; (s < 0 || (0 != r ? r < 0 ? o.from < i : o.to > i : e[s].level > o.level)) && (s = t) } } if (s < 0) throw new RangeError("Index out of range"); return s } } const Vi = []; function Yi(o, t) { var r, a = o.length, l = t == Pi ? 1 : 2, h = t == Pi ? 2 : 1; if (!o || 1 == l && !zi.test(o)) return Mi(a); for (let e = 0, i = l, n = l; e < a; e++) { let t = (r = o.charCodeAt(e)) <= 247 ? Xi[r] : 1424 <= r && r <= 1524 ? 2 : 1536 <= r && r <= 1785 ? Ri[r - 1536] : 1774 <= r && r <= 2220 ? 4 : 8192 <= r && r <= 8203 || 8204 == r ? 256 : 1; 512 == t ? t = i : 8 == t && 4 == n && (t = 16), Vi[e] = 4 == t ? 2 : t, 7 & t && (n = t), i = t } for (let i = 0, n = l, r = l; i < a; i++) { let t = Vi[i]; if (128 == t) i < a - 1 && n == Vi[i + 1] && 24 & n ? t = Vi[i] = n : Vi[i] = 256; else if (64 == t) { let e = i + 1; for (; e < a && 64 == Vi[e];)e++; var s = i && 8 == n || e < a && 8 == Vi[e] ? 1 == r ? 1 : 8 : 256; for (let t = i; t < e; t++)Vi[t] = s; i = e - 1 } else 8 == t && 1 == r && (Vi[i] = 1); n = t, 7 & t && (r = t) } for (let e = 0, i = 0, t = 0, n, r, s; e < a; e++)if (r = _i[n = o.charCodeAt(e)]) if (r < 0) { for (let t = i - 3; 0 <= t; t -= 3)if (Ci[t + 1] == -r) { var c = Ci[t + 2], c = 2 & c ? l : 4 & c ? 1 & c ? h : l : 0; c && (Vi[e] = Vi[Ci[t]] = c), i = t; break } } else { if (189 == Ci.length) break; Ci[i++] = e, Ci[i++] = n, Ci[i++] = t } else if (2 == (s = Vi[e]) || 1 == s) { var O = s == l; t = O ? 0 : 1; for (let t = i - 3; 0 <= t; t -= 3) { var d = Ci[t + 2]; if (2 & d) break; if (O) Ci[t + 2] |= 2; else { if (4 & d) break; Ci[t + 2] |= 4 } } } for (let i = 0; i < a; i++)if (256 == Vi[i]) { let e = i + 1; for (; e < a && 256 == Vi[e];)e++; var n = 1 == (i ? Vi[i - 1] : l), u = n == (1 == (e < a ? Vi[e] : l)) ? n ? 1 : 2 : l; for (let t = i; t < e; t++)Vi[t] = u; i = e - 1 } let i = []; if (1 == l) for (let e = 0; e < a;) { for (var f = e, p = 1 != Vi[e++]; e < a && p == (1 != Vi[e]);)e++; if (p) for (let t = e; t > f;) { for (var m = t, g = 2 != Vi[--t]; t > f && g == (2 != Vi[t - 1]);)t--; i.push(new qi(t, m, g ? 2 : 1)) } else i.push(new qi(f, e, 0)) } else for (let t = 0; t < a;) { for (var e = t, Q = 2 == Vi[t++]; t < a && Q == (2 == Vi[t]);)t++; i.push(new qi(e, t, Q ? 1 : 2)) } return i } function Mi(t) { return [new qi(0, t, 0)] } let Zi = ""; function Ei(t, e) { return t.top < e.bottom - 1 && t.bottom > e.top + 1 } function ji(t, e) { return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t } function Di(t, e) { return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t } function Hi(t, n, r) { let s, o, a, l, h, c, O, d; for (let i = t.firstChild; i; i = i.nextSibling) { var u = Ut(i); for (let e = 0; e < u.length; e++) { let t = u[e]; o && Ei(o, t) && (t = ji(Di(t, o.bottom), o.top)); var f = (m = n, (p = t).left > m ? p.left - m : Math.max(0, m - p.right)), p = (m = r, (p = t).top > m ? p.top - m : Math.max(0, m - p.bottom)); if (0 == f && 0 == p) return (3 == i.nodeType ? Ii : Hi)(i, n, r); (!s || l > p || l == p && a > f) && (s = i, o = t, a = f, l = p), 0 == f ? r > t.bottom && (!O || O.bottom < t.bottom) ? (h = i, O = t) : r < t.top && (!d || d.top > t.top) && (c = i, d = t) : O && Ei(O, t) ? O = Di(O, t.bottom) : d && Ei(d, t) && (d = ji(d, t.top)) } } var m, p; if (O && O.bottom >= r ? (s = h, o = O) : d && d.top <= r && (s = c, o = d), !s) return { node: t, offset: 0 }; var e = Math.max(o.left, Math.min(o.right, n)); return 3 == s.nodeType ? Ii(s, e, r) : a || "true" != s.contentEditable ? { node: t, offset: Array.prototype.indexOf.call(t.childNodes, s) + (n >= (o.left + o.right) / 2 ? 1 : 0) } : Hi(s, e, r) } function Ii(n, r, e) { var t = n.nodeValue.length; let s = -1, o = 1e9, a = 0; for (let i = 0; i < t; i++) { var l = ae(n, i, i + 1).getClientRects(); for (let t = 0; t < l.length; t++) { var h = l[t]; if (h.top != h.bottom) { a = a || r - h.left; var c = (h.top > e ? h.top - e : e - h.bottom) - 1; if (h.left - 1 <= r && h.right + 1 >= r && c < o) { let t = r >= (h.left + h.right) / 2, e = t; if ((xe.chrome || xe.gecko) && ae(n, i).getBoundingClientRect().left == h.right && (e = !t), c <= 0) return { node: n, offset: i + (e ? 1 : 0) }; s = i + (e ? 1 : 0), o = c } } } } return { node: n, offset: -1 < s ? s : 0 < a ? n.nodeValue.length : 0 } } function Gi(e, { x: t, y: i }, n = -1) { let r = e.contentDOM.getBoundingClientRect(), s; var o = e.defaultLineHeight / 2; for (let t = !1; ;) { if (s = e.blockAtHeight(i, r.top), s.top > i || s.bottom < i) { if (n = s.top > i ? -1 : 1, i = Math.min(s.bottom - o, Math.max(s.top + o, i)), t) return -1; t = !0 } if (s.type == Ye.Text) break; i = 0 < n ? s.bottom + o : s.top - o } var a, l = s.from; if (l < e.viewport.from) return 0 == e.viewport.from ? 0 : null; if (l > e.viewport.to) return e.viewport.to == e.state.doc.length ? e.state.doc.length : null; t = Math.max(r.left + 1, Math.min(r.right - 1, t)); let h = e.root, c = h.elementFromPoint(t, i), O, d = -1; return !c || !e.contentDOM.contains(c) || e.docView.nearest(c) instanceof Xe || (h.caretPositionFromPoint ? (a = h.caretPositionFromPoint(t, i)) && ({ offsetNode: O, offset: d } = a) : !h.caretRangeFromPoint || (a = h.caretRangeFromPoint(t, i)) && ({ startContainer: O, startOffset: d } = a, xe.safari && function (e, t, i) { let n; if (3 != e.nodeType || t != (n = e.nodeValue.length)) return !1; for (let t = e.nextSibling; t; t = e.nextSibling)if (1 != t.nodeType || "BR" != t.nodeName) return !1; return ae(e, n - 1, n).getBoundingClientRect().left > i }(O, d, t) && (O = void 0))), O && e.docView.dom.contains(O) || (l = Ie.find(e.docView, l), { node: O, offset: d } = Hi(l.dom, t, i)), e.docView.posFromDOM(O, d) } function Bi(r, t, s, o) { let a = r.state.doc.lineAt(t.head), l = r.bidiSpans(a); for (let i = t, n = null; ;) { let t = function (t, e, i, n, r) { let s = n.head - t.from, o = -1; if (0 == s) { if (!r || !t.length) return null; e[0].level != i && (s = e[0].side(!1, i), o = 0) } else if (s == t.length) { if (r) return null; let t = e[e.length - 1]; t.level != i && (s = t.side(!0, i), o = e.length - 1) } o < 0 && (o = qi.find(e, s, null !== (l = n.bidiLevel) && void 0 !== l ? l : -1, n.assoc)); let a = e[o]; s == a.side(r, i) && (a = e[o += r ? 1 : -1], s = a.side(!r, i)); var l = r == (a.dir == i), n = b(t.text, s, l); if (Zi = t.text.slice(Math.min(s, n), Math.max(s, n)), n != a.side(r, i)) return _.cursor(n + t.from, l ? -1 : 1, a.level); let h = o == (r ? e.length - 1 : 0) ? null : e[o + (r ? 1 : -1)]; return h || a.level == i ? h && h.level < a.level ? _.cursor(h.side(!r, i) + t.from, r ? 1 : -1, h.level) : _.cursor(n + t.from, r ? -1 : 1, a.level) : _.cursor(r ? t.to : t.from, r ? -1 : 1, i) }(a, l, r.textDirection, i, s), e = Zi; if (!t) { if (a.number == (s ? r.state.doc.lines : 1)) return i; e = "\n", a = r.state.doc.line(a.number + (s ? 1 : -1)), l = r.bidiSpans(a), t = _.cursor(s ? a.from : a.to) } if (n) { if (!n(e)) return i } else { if (!o) return t; n = o(e) } i = t } } function Ni(i, t, e, n) { var r = t.head, s = e ? 1 : -1; if (r == (e ? i.state.doc.length : 0)) return _.cursor(r); var o = i.coordsAtPos(r); if (o) { var a = i.dom.getBoundingClientRect(), l = null !== (e = t.goalColumn) && void 0 !== e ? e : o.left - a.left, h = a.left + l, c = null != n ? n : i.defaultLineHeight >> 1; for (let t = s < 0 ? o.top : o.bottom, e = 0; e < 50; e += 10) { var O = Gi(i, { x: h, y: t + (c + e) * s }, s); if (null == O) break; if (O != r) return _.cursor(O, void 0, void 0, l) } } let { doc: d } = i.state, u = d.lineAt(r), f = i.state.tabSize, p = t.goalColumn, m = 0; if (null == p) { for (const $ = d.iterRange(u.from, r); !$.next().done;)m = x($.value, m, f); p = m * i.defaultCharacterWidth } else m = Math.round(p / i.defaultCharacterWidth); if (s < 0 && 0 == u.from) return _.cursor(0); if (0 < s && u.to == d.length) return _.cursor(u.to); t = d.line(u.number + s); let g = t.from, Q = 0; for (const y = d.iterRange(t.from, t.to); Q >= m && !y.next().done;) { var { offset: v, leftOver: w } = function (e, i, n, r) { for (let t = 0; t < e.length;) { if (n <= i) return { offset: t, leftOver: 0 }; i += 9 == e.charCodeAt(t) ? r - i % r : 1, t = b(e, t) } return { offset: e.length, leftOver: n - i } }(y.value, Q, m, f); Q = m - w, g += v } return _.cursor(g, void 0, void 0, p) } class Ui { constructor(n) { this.lastKeyCode = 0, this.lastKeyTime = 0, this.pendingIOSKey = null, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.registeredEvents = [], this.customHandlers = [], this.composing = -1, this.compositionEndedAt = 0, this.mouseSelection = null; for (let i in tn) { let e = tn[i]; n.contentDOM.addEventListener(i, t => { "keydown" == i && this.keydown(n, t) || Ki(n, t) && !this.ignoreDuringComposition(t) && (this.mustFlushObserver(t) && n.observer.forceFlush(), this.runCustomHandlers(i, n, t) ? t.preventDefault() : e(n, t)) }), this.registeredEvents.push(i) } this.notifiedFocused = n.hasFocus, this.ensureHandlers(n), xe.safari && n.contentDOM.addEventListener("input", () => null) } setSelectionOrigin(t) { this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now() } ensureHandlers(i) { var t; for (t of this.customHandlers = i.pluginField(Oi)) for (let e in t.handlers) this.registeredEvents.indexOf(e) < 0 && "scroll" != e && (this.registeredEvents.push(e), i.contentDOM.addEventListener(e, t => { Ki(i, t) && this.runCustomHandlers(e, i, t) && t.preventDefault() })) } runCustomHandlers(i, n, r) { for (var s of this.customHandlers) { let t = s.handlers[i], e = !1; if (t) { try { e = t.call(s.plugin, r, n) } catch (t) { ri(n.state, t) } if (e || r.defaultPrevented) return xe.android && "keydown" == i && 13 == r.keyCode && n.observer.flushSoon(), !0 } } return !1 } runScrollHandlers(e, i) { for (var n of this.customHandlers) { let t = n.handlers.scroll; if (t) try { t.call(n.plugin, i, e) } catch (t) { ri(e.state, t) } } } keydown(t, e) { return this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), !!this.screenKeyEvent(t, e) || !(!xe.ios || 13 != e.keyCode && 8 != e.keyCode || e.ctrlKey || e.altKey || e.metaKey || e.synthetic) && (this.pendingIOSKey = 13 == e.keyCode ? "enter" : "backspace", setTimeout(() => this.flushIOSKey(t), 250), !0) } flushIOSKey(t) { if (!this.pendingIOSKey) return !1; var e = t.contentDOM, t = this.pendingIOSKey; return this.pendingIOSKey = null, "enter" == t ? le(e, "Enter", 13) : le(e, "Backspace", 8) } ignoreDuringComposition(t) { return !!/^key/.test(t.type) && (0 < this.composing || !!(xe.safari && Date.now() - this.compositionEndedAt < 500) && !(this.compositionEndedAt = 0)) } screenKeyEvent(t, e) { var i = 9 == e.keyCode && Date.now() < this.lastEscPress + 2e3; return 27 == e.keyCode ? this.lastEscPress = Date.now() : Fi.indexOf(e.keyCode) < 0 && (this.lastEscPress = 0), i } mustFlushObserver(t) { return "keydown" == t.type && 229 != t.keyCode || "compositionend" == t.type && !xe.ios } startMouseSelection(t, e, i) { this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = new Ji(this, t, e, i) } update(t) { this.mouseSelection && this.mouseSelection.update(t), this.lastKeyCode = this.lastSelectionTime = 0 } destroy() { this.mouseSelection && this.mouseSelection.destroy() } } const Fi = [16, 17, 18, 20, 91, 92, 224, 225]; class Ji { constructor(t, e, i, n) { this.inputState = t, this.view = e, this.startEvent = i, this.style = n; let r = e.contentDOM.ownerDocument; r.addEventListener("mousemove", this.move = this.move.bind(this)), r.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = i.shiftKey, this.multiple = e.state.facet(pt.allowMultipleSelections) && function (t, e) { let i = t.state.facet(Je); return i.length ? i[0](e) : xe.mac ? e.metaKey : e.ctrlKey }(e, i), this.dragMove = function (t, e) { let i = t.state.facet(Ke); return i.length ? i[0](e) : xe.mac ? !e.altKey : !e.ctrlKey }(e, i), this.dragging = !!function (t, e) { var { main: i } = t.state.selection; if (i.empty) return !1; let n = Gt(t.root); if (0 == n.rangeCount) return !0; var r = n.getRangeAt(0).getClientRects(); for (let t = 0; t < r.length; t++) { var s = r[t]; if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY) return !0 } return !1 }(e, i) && null, !1 === this.dragging && (i.preventDefault(), this.select(i)) } move(t) { if (0 == t.buttons) return this.destroy(); !1 === this.dragging && this.select(t) } up(t) { null == this.dragging && this.select(this.startEvent), this.dragging || t.preventDefault(), this.destroy() } destroy() { let t = this.view.contentDOM.ownerDocument; t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.inputState.mouseSelection = null } select(t) { let e = this.style.get(t, this.extend, this.multiple); e.eq(this.view.state.selection) && e.main.assoc == this.view.state.selection.main.assoc || this.view.dispatch({ selection: e, annotations: st.userEvent.of("pointerselection"), scrollIntoView: !0 }) } update(t) { t.docChanged && this.dragging && (this.dragging = this.dragging.map(t.changes)), this.style.update(t) } } function Ki(i, n) { if (!n.bubbles) return 1; if (!n.defaultPrevented) { for (let t = n.target, e; t != i.contentDOM; t = t.parentNode)if (!t || 11 == t.nodeType || (e = Oe.get(t)) && e.ignoreEvent(n)) return; return 1 } } const tn = Object.create(null), en = xe.ie && xe.ie_version < 15 || xe.ios && xe.webkit_version < 604; function nn(t, r) { let { state: s } = t, e, o = 1, a = s.toText(r), l = a.lines == s.selection.ranges.length; if (fn && s.selection.ranges.every(t => t.empty) && fn == a.toString()) { let n = -1; e = s.changeByRange(t => { var e = s.doc.lineAt(t.from); if (e.from == n) return { range: t }; n = e.from; var i = s.toText((l ? a.line(o++).text : r) + s.lineBreak); return { changes: { from: e.from, insert: i }, range: _.cursor(t.from + i.length) } }) } else e = l ? s.changeByRange(t => { var e = a.line(o++); return { changes: { from: t.from, to: t.to, insert: e.text }, range: _.cursor(t.from + e.length) } }) : s.replaceSelection(a); t.dispatch(e, { annotations: st.userEvent.of("paste"), scrollIntoView: !0 }) } tn.keydown = (t, e) => { t.inputState.setSelectionOrigin("keyboardselection") }; let rn = 0; function sn(i, n, r, t) { if (1 == t) return _.cursor(n, r); if (2 == t) return function (t, e, i = 1) { let n = t.charCategorizer(e), r = t.doc.lineAt(e), s = e - r.from; if (0 == r.length) return _.cursor(e); 0 == s ? i = 1 : s == r.length && (i = -1); let o = s, a = s; i < 0 ? o = b(r.text, s, !1) : a = b(r.text, s); for (var l = n(r.text.slice(o, a)); 0 < o;) { var h = b(r.text, o, !1); if (n(r.text.slice(h, o)) != l) break; o = h } for (; a < r.length;) { var c = b(r.text, a); if (n(r.text.slice(a, c)) != l) break; a = c } return _.range(o + r.from, a + r.from) }(i.state, n, r); { r = Ie.find(i.docView, n), n = i.state.doc.lineAt(r ? r.posAtEnd : n); let t = r ? r.posAtStart : n.from, e = r ? r.posAtEnd : n.to; return e < i.state.doc.length && e == n.to && e++, _.range(t, e) } } tn.touchstart = (t, e) => { rn = Date.now(), t.inputState.setSelectionOrigin("pointerselection") }, tn.touchmove = t => { t.inputState.setSelectionOrigin("pointerselection") }, tn.mousedown = (e, i) => { if (e.observer.flush(), !(rn > Date.now() - 2e3)) { let t = null; for (var n of e.state.facet(ti)) if (t = n(e, i), t) break; t || 0 != i.button || (t = function (o, t) { let a = ln(o, t), l = function (t) { if (!hn) return t.detail; var e = cn, i = dn; return cn = t, dn = Date.now(), On = !e || i > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (On + 1) % 3 : 1 }(t), h = o.state.selection, c = a, O = t; return { update(t) { t.changes && (a && (a.pos = t.changes.mapPos(a.pos)), h = h.map(t.changes)) }, get(t, e, i) { let n; if (t.clientX == O.clientX && t.clientY == O.clientY ? n = c : (n = c = ln(o, t), O = t), !n || !a) return h; let r = sn(o, n.pos, n.bias, l); var s; return a.pos == n.pos || e || (s = sn(o, a.pos, a.bias, l), t = Math.min(s.from, r.from), s = Math.max(s.to, r.to), r = t < r.from ? _.range(t, s) : _.range(s, t)), e ? h.replaceRange(h.main.extend(r.from, r.to)) : i ? h.addRange(r) : _.create([r]) } } }(e, i)), t && (e.root.activeElement != e.contentDOM && e.observer.ignore(() => se(e.contentDOM)), e.inputState.startMouseSelection(e, i, t)) } }; let on = (t, e) => t >= e.top && t <= e.bottom, an = (t, e, i) => on(e, i) && t >= i.left && t <= i.right; function ln(t, e) { var i = t.posAtCoords({ x: e.clientX, y: e.clientY }); return null == i ? null : { pos: i, bias: function (t, e, i, n) { let r = Ie.find(t.docView, e); return r && 0 != (t = e - r.posAtStart) && (t == r.length || (e = r.coordsAt(t, -1)) && an(i, n, e) || (!(t = r.coordsAt(t, 1)) || !an(i, n, t)) && e && on(n, e)) ? -1 : 1 }(t, i, e.clientX, e.clientY) } } const hn = xe.ie && xe.ie_version <= 11; let cn = null, On = 0, dn = 0; function un(e, i, n, r) { var s = e.posAtCoords({ x: i.clientX, y: i.clientY }); if (null != s && n) { i.preventDefault(); var { mouseSelection: i } = e.inputState, i = r && i && i.dragging && i.dragMove ? { from: i.dragging.from, to: i.dragging.to } : null, n = { from: s, insert: n }; let t = e.state.changes(i ? [i, n] : n); e.focus(), e.dispatch({ changes: t, selection: { anchor: t.mapPos(s, -1), head: t.mapPos(s, 1) }, annotations: st.userEvent.of("drop") }) } } tn.dragstart = (t, e) => { var { selection: { main: i } } = t.state; let { mouseSelection: n } = t.inputState; n && (n.dragging = i), e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(i.from, i.to)), e.dataTransfer.effectAllowed = "copyMove") }, tn.drop = (e, s) => { if (s.dataTransfer && e.state.facet(si)) { let r = s.dataTransfer.files; if (r && r.length) { s.preventDefault(); let i = Array(r.length), t = 0, n = () => { ++t == r.length && un(e, s, i.filter(t => null != t).join(e.state.lineBreak), !1) }; for (let e = 0; e < r.length; e++) { let t = new FileReader; t.onerror = n, t.onload = () => { /[\x00-\x08\x0e-\x1f]{2}/.test(t.result) || (i[e] = t.result), n() }, t.readAsText(r[e]) } } else un(e, s, s.dataTransfer.getData("Text"), !0) } }, tn.paste = (e, i) => { if (e.state.facet(si)) { e.observer.flush(); let t = en ? null : i.clipboardData; var n = t && t.getData("text/plain"); n ? (nn(e, n), i.preventDefault()) : function (e) { let i = e.dom.parentNode; if (i) { let t = i.appendChild(document.createElement("textarea")); t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => { e.focus(), t.remove(), nn(e, t.value) }, 50) } }(e) } }; let fn = null; function pn(t) { t.docView.compositionDeco.size && t.update([]) } tn.copy = tn.cut = (e, i) => { var { text: n, ranges: r, linewise: s } = function (e) { let i = [], n = [], r = !1; for (var t of e.selection.ranges) t.empty || (i.push(e.sliceDoc(t.from, t.to)), n.push(t)); if (!i.length) { let t = -1; for (var { from: s } of e.selection.ranges) { s = e.doc.lineAt(s); s.number > t && (i.push(s.text), n.push({ from: s.from, to: Math.min(e.doc.length, s.to + 1) })), t = s.number } r = !0 } return { text: i.join(e.lineBreak), ranges: n, linewise: r } }(e.state); if (n) { fn = s ? n : null; let t = en ? null : i.clipboardData; t ? (i.preventDefault(), t.clearData(), t.setData("text/plain", n)) : function (e, i) { let n = e.dom.parentNode; if (n) { let t = n.appendChild(document.createElement("textarea")); t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.value = i, t.focus(), t.selectionEnd = i.length, t.selectionStart = 0, setTimeout(() => { t.remove(), e.focus() }, 50) } }(e, n), "cut" == i.type && e.state.facet(si) && e.dispatch({ changes: r, scrollIntoView: !0, annotations: st.userEvent.of("cut") }) } }, tn.focus = tn.blur = t => { setTimeout(() => { t.hasFocus != t.inputState.notifiedFocused && t.update([]) }, 10) }, tn.beforeprint = t => { t.viewState.printing = !0, t.requestMeasure(), setTimeout(() => { t.viewState.printing = !1, t.requestMeasure() }, 2e3) }, tn.compositionstart = tn.compositionupdate = t => { t.inputState.composing < 0 && (t.docView.compositionDeco.size && (t.observer.flush(), pn(t)), t.inputState.composing = 0) }, tn.compositionend = t => { t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), setTimeout(() => { t.inputState.composing < 0 && pn(t) }, 50) }, tn.contextmenu = t => { t.inputState.lastContextMenu = Date.now() }; const mn = ["pre-wrap", "normal", "pre-line"]; class gn { constructor() { this.doc = d.empty, this.lineWrapping = !1, this.direction = Si.LTR, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.lineLength = 30, this.heightChanged = !1 } heightForGap(t, e) { let i = this.doc.lineAt(e).number - this.doc.lineAt(t).number + 1; return this.lineWrapping && (i += Math.ceil((e - t - i * this.lineLength * .5) / this.lineLength)), this.lineHeight * i } heightForLine(t) { return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight } setDoc(t) { return this.doc = t, this } mustRefresh(e, t, i) { let n = !1; for (let t = 0; t < e.length; t++) { var r = e[t]; r < 0 ? t++ : this.heightSamples[Math.floor(10 * r)] || (n = !0, this.heightSamples[Math.floor(10 * r)] = !0) } return n || -1 < mn.indexOf(t) != this.lineWrapping || this.direction != i } refresh(t, e, i, n, r, s) { var o = -1 < mn.indexOf(t), t = Math.round(i) != Math.round(this.lineHeight) || this.lineWrapping != o || this.direction != e; if (this.lineWrapping = o, this.direction = e, this.lineHeight = i, this.charWidth = n, this.lineLength = r, t) { this.heightSamples = {}; for (let t = 0; t < s.length; t++) { var a = s[t]; a < 0 ? t++ : this.heightSamples[Math.floor(10 * a)] = !0 } } return t } } class Qn { constructor(t, e) { this.from = t, this.heights = e, this.index = 0 } get more() { return this.index < this.heights.length } } class vn { constructor(t, e, i, n, r) { this.from = t, this.length = e, this.top = i, this.height = n, this.type = r } get to() { return this.from + this.length } get bottom() { return this.top + this.height } join(t) { var e = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(t.type) ? t.type : [t]); return new vn(this.from, this.length + t.length, this.top, this.height + t.height, e) } } var wn = function (t) { return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t }(wn = wn || {}); class $n { constructor(t, e, i = 2) { this.length = t, this.height = e, this.flags = i } get outdated() { return 0 < (2 & this.flags) } set outdated(t) { this.flags = (t ? 2 : 0) | -3 & this.flags } setHeight(t, e) { this.height != e && (1e-4 < Math.abs(this.height - e) && (t.heightChanged = !0), this.height = e) } replace(t, e, i) { return $n.of(i) } decomposeLeft(t, e) { e.push(this) } decomposeRight(t, e) { e.push(this) } applyChanges(o, a, l, h) { let c = this; for (let s = h.length - 1; 0 <= s; s--) { let { fromA: t, toA: e, fromB: i, toB: n } = h[s], r = c.lineAt(t, wn.ByPosNoHeight, a, 0, 0); var O = r.to >= e ? r : c.lineAt(e, wn.ByPosNoHeight, a, 0, 0); for (n += O.to - e, e = O.to; 0 < s && r.from <= h[s - 1].toA;)t = h[s - 1].fromA, i = h[s - 1].fromB, s--, t < r.from && (r = c.lineAt(t, wn.ByPosNoHeight, a, 0, 0)); i += r.from - t, t = r.from; O = Pn.build(l, o, i, n); c = c.replace(t, e, O) } return c.updateHeight(l, 0) } static empty() { return new bn(0, 0) } static of(t) { if (1 == t.length) return t[0]; let e = 0, i = t.length, n = 0, r = 0; for (; ;) { var s; if (e == i) if (n > 2 * r) { var o = t[e - 1]; o.break ? t.splice(--e, 1, o.left, null, o.right) : t.splice(--e, 1, o.left, o.right), i += 1 + o.break, n -= o.size } else { if (!(r > 2 * n)) break; o = t[i]; o.break ? t.splice(i, 1, o.left, null, o.right) : t.splice(i, 1, o.left, o.right), i += 2 + o.break, r -= o.size } else n < r ? (s = t[e++]) && (n += s.size) : (s = t[--i]) && (r += s.size) } let a = 0; return null == t[e - 1] ? (a = 1, e--) : null == t[e] && (a = 1, i++), new kn($n.of(t.slice(0, e)), a, $n.of(t.slice(i))) } } $n.prototype.size = 1; class yn extends $n { constructor(t, e, i) { super(t, e), this.type = i } blockAt(t, e, i, n) { return new vn(n, this.length, i, this.height, this.type) } lineAt(t, e, i, n, r) { return this.blockAt(0, i, n, r) } forEachLine(t, e, i, n, r, s) { s(this.blockAt(0, i, n, r)) } updateHeight(t, e = 0, i, n) { return n && n.from <= e && n.more && this.setHeight(t, n.heights[n.index++]), this.outdated = !1, this } toString() { return `block(${this.length})` } } class bn extends yn { constructor(t, e) { super(t, e, Ye.Text), this.collapsed = 0, this.widgetHeight = 0 } replace(t, e, i) { let n = i[0]; return 1 == i.length && (n instanceof bn || n instanceof xn && 4 & n.flags) && Math.abs(this.length - n.length) < 10 ? (n instanceof xn ? n = new bn(n.length, this.height) : n.height = this.height, this.outdated || (n.outdated = !1), n) : $n.of(i) } updateHeight(t, e = 0, i = !1, n) { return n && n.from <= e && n.more ? this.setHeight(t, n.heights[n.index++]) : (i || this.outdated) && this.setHeight(t, Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed))), this.outdated = !1, this } toString() { return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})` } } class xn extends $n { constructor(t) { super(t, 0) } lines(t, e) { var i = t.lineAt(e).number, e = t.lineAt(e + this.length).number; return { firstLine: i, lastLine: e, lineHeight: this.height / (e - i + 1) } } blockAt(t, e, i, n) { var { firstLine: r, lastLine: s, lineHeight: n } = this.lines(e, n), t = Math.max(0, Math.min(s - r, Math.floor((t - i) / n))), { from: e, length: r } = e.line(r + t); return new vn(e, r, i + n * t, n, Ye.Text) } lineAt(t, e, i, n, r) { if (e == wn.ByHeight) return this.blockAt(t, i, n, r); if (e == wn.ByPosNoHeight) { var { from: s, to: o } = i.lineAt(t); return new vn(s, o - s, 0, 0, Ye.Text) } var { firstLine: o, lineHeight: s } = this.lines(i, r), { from: r, length: i, number: t } = i.lineAt(t); return new vn(r, i, n + s * (t - o), s, Ye.Text) } forEachLine(i, n, r, s, o, a) { var { firstLine: l, lineHeight: h } = this.lines(r, o); for (let t = Math.max(i, o), e = Math.min(o + this.length, n); t <= e;) { var c = r.lineAt(t); t == i && (s += h * (c.number - l)), a(new vn(c.from, c.length, s, h, Ye.Text)), s += h, t = c.to + 1 } } replace(t, e, i) { var n = this.length - e; return 0 < n && ((e = i[i.length - 1]) instanceof xn ? i[i.length - 1] = new xn(e.length + n) : i.push(null, new xn(n - 1))), 0 < t && ((n = i[0]) instanceof xn ? i[0] = new xn(t + n.length) : i.unshift(new xn(t - 1), null)), $n.of(i) } decomposeLeft(t, e) { e.push(new xn(t - 1), null) } decomposeRight(t, e) { e.push(null, new xn(this.length - t - 1)) } updateHeight(n, t = 0, e = !1, r) { var s = t + this.length; if (r && r.from <= t + this.length && r.more) { let e = [], i = Math.max(t, r.from); for (r.from > t && e.push(new xn(r.from - t - 1).updateHeight(n, t)); i <= s && r.more;) { var o = n.doc.lineAt(i).length; e.length && e.push(null); let t = new bn(o, r.heights[r.index++]); t.outdated = !1, e.push(t), i += o + 1 } return i <= s && e.push(null, new xn(s - i).updateHeight(n, i)), n.heightChanged = !0, $n.of(e) } return (e || this.outdated) && (this.setHeight(n, n.heightForGap(t, t + this.length)), this.outdated = !1), this } toString() { return `gap(${this.length})` } } class kn extends $n { constructor(t, e, i) { super(t.length + e + i.length, t.height + i.height, e | (t.outdated || i.outdated ? 2 : 0)), this.left = t, this.right = i, this.size = t.size + i.size } get break() { return 1 & this.flags } blockAt(t, e, i, n) { var r = i + this.left.height; return t < r || 0 == this.right.height ? this.left.blockAt(t, e, i, n) : this.right.blockAt(t, e, r, n + this.left.length + this.break) } lineAt(t, e, i, n, r) { var s = n + this.left.height, o = r + this.left.length + this.break, a = e == wn.ByHeight ? t < s || 0 == this.right.height : t < o; let l = a ? this.left.lineAt(t, e, i, n, r) : this.right.lineAt(t, e, i, s, o); if (this.break || (a ? l.to < o : l.from > o)) return l; e = e == wn.ByPosNoHeight ? wn.ByPosNoHeight : wn.ByPos; return a ? l.join(this.right.lineAt(o, e, i, s, o)) : this.left.lineAt(o, e, i, n, r).join(l) } forEachLine(t, e, i, n, r, s) { var o, a = n + this.left.height, l = r + this.left.length + this.break; this.break ? (t < l && this.left.forEachLine(t, e, i, n, r, s), l <= e && this.right.forEachLine(t, e, i, a, l, s)) : (t < (o = this.lineAt(l, wn.ByPos, i, n, r)).from && this.left.forEachLine(t, o.from - 1, i, n, r, s), o.to >= t && o.from <= e && s(o), e > o.to && this.right.forEachLine(o.to + 1, e, i, a, l, s)) } replace(t, e, i) { var n = this.left.length + this.break; if (e < n) return this.balanced(this.left.replace(t, e, i), this.right); if (t > this.left.length) return this.balanced(this.left, this.right.replace(t - n, e - n, i)); let r = []; 0 < t && this.decomposeLeft(t, r); var s, n = r.length; for (s of i) r.push(s); return 0 < t && Sn(r, n - 1), e < this.length && (n = r.length, this.decomposeRight(e, r), Sn(r, n)), $n.of(r) } decomposeLeft(t, e) { let i = this.left.length; if (t <= i) return this.left.decomposeLeft(t, e); e.push(this.left), this.break && (i++, t >= i && e.push(null)), t > i && this.right.decomposeLeft(t - i, e) } decomposeRight(t, e) { var i = this.left.length, n = i + this.break; if (n <= t) return this.right.decomposeRight(t - n, e); t < i && this.left.decomposeRight(t, e), this.break && t < n && e.push(null), e.push(this.right) } balanced(t, e) { return t.size > 2 * e.size || e.size > 2 * t.size ? $n.of(this.break ? [t, null, e] : [t, e]) : (this.left = t, this.right = e, this.height = t.height + e.height, this.outdated = t.outdated || e.outdated, this.size = t.size + e.size, this.length = t.length + this.break + e.length, this) } updateHeight(t, e = 0, i = !1, n) { let { left: r, right: s } = this, o = e + r.length + this.break, a = null; return n && n.from <= e + r.length && n.more ? a = r = r.updateHeight(t, e, i, n) : r.updateHeight(t, e, i), n && n.from <= o + s.length && n.more ? a = s = s.updateHeight(t, o, i, n) : s.updateHeight(t, o, i), a ? this.balanced(r, s) : (this.height = this.left.height + this.right.height, this.outdated = !1, this) } toString() { return this.left + (this.break ? " " : "-") + this.right } } function Sn(t, e) { let i, n; null == t[e] && (i = t[e - 1]) instanceof xn && (n = t[e + 1]) instanceof xn && t.splice(e - 1, 3, new xn(i.length + 1 + n.length)) } class Pn { constructor(t, e) { this.pos = t, this.oracle = e, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t } get isCovered() { return this.covering && this.nodes[this.nodes.length - 1] == this.covering } span(t, i) { if (-1 < this.lineStart) { let t = Math.min(i, this.lineEnd), e = this.nodes[this.nodes.length - 1]; e instanceof bn ? e.length += t - this.pos : (t > this.pos || !this.isCovered) && this.nodes.push(new bn(t - this.pos, -1)), (this.writtenTo = t) < i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1) } this.pos = i } point(t, e, i) { var n, r; t < e || i.heightRelevant ? (n = i.widget ? Math.max(0, i.widget.estimatedHeight) : 0, r = e - t, i.block ? this.addBlock(new yn(r, n, i.type)) : (r || 5 <= n) && this.addLineDeco(n, r)) : t < e && this.span(t, e), -1 < this.lineEnd && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to) } enterLine() { var t, e; -1 < this.lineStart || ({ from: t, to: e } = this.oracle.doc.lineAt(this.pos), this.lineStart = t, this.lineEnd = e, this.writtenTo < t && ((this.writtenTo < t - 1 || null == this.nodes[this.nodes.length - 1]) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new bn(this.pos - t, -1)), this.writtenTo = this.pos) } blankContent(t, e) { let i = new xn(e - t); return this.oracle.doc.lineAt(t).to == e && (i.flags |= 4), i } ensureLine() { this.enterLine(); var t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null; if (t instanceof bn) return t; t = new bn(0, -1); return this.nodes.push(t), t } addBlock(t) { this.enterLine(), t.type != Ye.WidgetAfter || this.isCovered || this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, t.type != Ye.WidgetBefore && (this.covering = t) } addLineDeco(t, e) { let i = this.ensureLine(); i.length += e, i.collapsed += e, i.widgetHeight = Math.max(i.widgetHeight, t), this.writtenTo = this.pos = this.pos + e } finish(t) { var e, i = 0 == this.nodes.length ? null : this.nodes[this.nodes.length - 1]; !(-1 < this.lineStart) || i instanceof bn || this.isCovered ? (this.writtenTo < this.pos || null == i) && this.nodes.push(this.blankContent(this.writtenTo, this.pos)) : this.nodes.push(new bn(0, -1)); let n = t; for (e of this.nodes) e instanceof bn && e.updateHeight(this.oracle, n), n += e ? e.length : 1; return this.nodes } static build(t, e, i, n) { let r = new Pn(i, t); return Pt.spans(e, i, n, r, 0), r.finish(i) } } class Tn { constructor() { this.changes = [] } compareRange() { } comparePoint(t, e, i, n) { (t < e || i && i.heightRelevant || n && n.heightRelevant) && He(t, e, this.changes, 5) } } class Wn { constructor(t, e, i) { this.from = t, this.to = e, this.size = i } static same(e, i) { if (e.length != i.length) return !1; for (let t = 0; t < e.length; t++) { var n = e[t], r = i[t]; if (n.from != r.from || n.to != r.to || n.size != r.size) return !1 } return !0 } draw(t) { return Me.replace({ widget: new Xn(this.size, t) }).range(this.from, this.to) } } class Xn extends Ve { constructor(t, e) { super(), this.size = t, this.vertical = e } eq(t) { return t.size == this.size && t.vertical == this.vertical } toDOM() { let t = document.createElement("div"); return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t } get estimatedHeight() { return this.vertical ? this.size : -1 } } class Rn { constructor(t) { this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentWidth = 0, this.heightOracle = new gn, this.scaler = zn, this.scrollTo = null, this.printing = !1, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1, this.heightMap = $n.empty().applyChanges(t.facet(pi), d.empty, this.heightOracle.setDoc(t.doc), [new gi(0, 0, 0, t.doc.length)]), this.viewport = this.getViewport(0, null), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Me.set(this.lineGaps.map(t => t.draw(!1))), this.computeVisibleRanges() } updateForViewport() { let e = [this.viewport], { main: n } = this.state.selection; for (let t = 0; t <= 1; t++) { let i = t ? n.head : n.anchor; var r, s; e.some(({ from: t, to: e }) => i >= t && i <= e) || ({ from: r, to: s } = this.lineAt(i, 0), e.push(new _n(r, s))) } this.viewports = e.sort((t, e) => t.from - e.from), this.scaler = this.heightMap.height <= 7e6 ? zn : new qn(this.heightOracle.doc, this.heightMap, this.viewports) } update(t, e = null) { var i = this.state; this.state = t.state; var n, r, s, o = this.state.facet(pi), a = t.changedRanges, s = gi.extendWithRanges(a, (n = t.startState.facet(pi), r = o, s = t ? t.changes : k.empty(this.state.doc.length), a = new Tn, Pt.compare(n, r, s, a, 0), a.changes)), a = this.heightMap.height; this.heightMap = this.heightMap.applyChanges(o, i.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != a && (t.flags |= 2); let l = s.length ? this.mapViewport(this.viewport, t.changes) : this.viewport; (e && (e.head < l.from || e.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, e)), l.eq(this.viewport) || (this.viewport = l, t.flags |= 4), this.updateForViewport(), (this.lineGaps.length || 15e3 < this.viewport.to - this.viewport.from) && (t.flags |= this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes)))), this.computeVisibleRanges(), e && (this.scrollTo = e), !this.mustEnforceCursorAssoc && t.selectionSet && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && (this.mustEnforceCursorAssoc = !0) } measure(t, e) { let i = t.dom, n = "", r = Si.LTR; e || (l = window.getComputedStyle(i), n = l.whiteSpace, r = "rtl" == l.direction ? Si.RTL : Si.LTR, this.paddingTop = parseInt(l.paddingTop) || 0, this.paddingBottom = parseInt(l.paddingBottom) || 0); var s = this.printing ? { top: -1e8, bottom: 1e8, left: -1e8, right: 1e8 } : function (e, t) { var i = e.getBoundingClientRect(); let n = Math.max(0, i.left), r = Math.min(innerWidth, i.right), s = Math.max(0, i.top), o = Math.min(innerHeight, i.bottom); for (let t = e.parentNode; t;)if (1 == t.nodeType) { var a, l = window.getComputedStyle(t); (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth) && "visible" != l.overflow && (a = t.getBoundingClientRect(), n = Math.max(n, a.left), r = Math.min(r, a.right), s = Math.max(s, a.top), o = Math.min(o, a.bottom)), t = "absolute" == l.position || "fixed" == l.position ? t.offsetParent : t.parentNode } else { if (11 != t.nodeType) break; t = t.host } return { left: n - i.left, right: r - i.left, top: s - (i.top + t), bottom: o - (i.top + t) } }(i, this.paddingTop), o = s.top - this.pixelViewport.top, a = s.bottom - this.pixelViewport.bottom; if (this.pixelViewport = s, this.inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left, !this.inView) return 0; var l, h = t.measureVisibleLineHeights(); let c = !1, O = 0, d = 0, u = this.heightOracle; return e || (l = t.dom.clientWidth, (u.mustRefresh(h, n, r) || u.lineWrapping && Math.abs(l - this.contentWidth) > u.charWidth) && ({ lineHeight: s, charWidth: e } = t.measureTextSize(), c = u.refresh(n, r, s, e, l / e, h), c && (t.minWidth = 0, d |= 16)), this.contentWidth != l && (this.contentWidth = l, d |= 16), 0 < o && 0 < a ? O = Math.max(o, a) : o < 0 && a < 0 && (O = Math.min(o, a))), u.heightChanged = !1, this.heightMap = this.heightMap.updateHeight(u, 0, c, new Qn(this.viewport.from, h)), u.heightChanged && (d |= 2), (!this.viewportIsAppropriate(this.viewport, O) || this.scrollTo && (this.scrollTo.head < this.viewport.from || this.scrollTo.head > this.viewport.to)) && ((h = this.getViewport(O, this.scrollTo)).from == this.viewport.from && h.to == this.viewport.to || (this.viewport = h, d |= 4)), this.updateForViewport(), (this.lineGaps.length || 15e3 < this.viewport.to - this.viewport.from) && (d |= this.updateLineGaps(this.ensureLineGaps(c ? [] : this.lineGaps))), this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.enforceCursorAssoc()), d } get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top, 0) } get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom, 0) } getViewport(t, e) { t = .5 - Math.max(-.5, Math.min(.5, t / 1e3 / 2)); let i = this.heightMap, n = this.state.doc, { visibleTop: r, visibleBottom: s } = this, o = new _n(i.lineAt(r - 1e3 * t, wn.ByHeight, n, 0, 0).from, i.lineAt(s + 1e3 * (1 - t), wn.ByHeight, n, 0, 0).to); return e && (e.head < o.from ? ({ top: t } = i.lineAt(e.head, wn.ByPos, n, 0, 0), o = new _n(i.lineAt(t - 500, wn.ByHeight, n, 0, 0).from, i.lineAt(t + (s - r) + 500, wn.ByHeight, n, 0, 0).to)) : e.head > o.to && ({ bottom: e } = i.lineAt(e.head, wn.ByPos, n, 0, 0), o = new _n(i.lineAt(e - (s - r) - 500, wn.ByHeight, n, 0, 0).from, i.lineAt(e + 500, wn.ByHeight, n, 0, 0).to))), o } mapViewport(t, e) { var i = e.mapPos(t.from, -1), t = e.mapPos(t.to, 1); return new _n(this.heightMap.lineAt(i, wn.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(t, wn.ByPos, this.state.doc, 0, 0).to) } viewportIsAppropriate({ from: t, to: e }, i = 0) { var { top: n } = this.heightMap.lineAt(t, wn.ByPos, this.state.doc, 0, 0), { bottom: r } = this.heightMap.lineAt(e, wn.ByPos, this.state.doc, 0, 0), { visibleTop: s, visibleBottom: o } = this; return (0 == t || n <= s - Math.max(10, Math.min(-i, 250))) && (e == this.state.doc.length || r >= o + Math.max(10, Math.min(i, 250))) && s - 2e3 < n && r < o + 2e3 } mapLineGaps(t, e) { if (!t.length || e.empty) return t; let i = []; for (var n of t) e.touchesRange(n.from, n.to) || i.push(new Wn(e.mapPos(n.from), e.mapPos(n.to), n.size)); return i } ensureLineGaps(a) { let l = []; return this.heightOracle.direction != Si.LTR || this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, r => { if (!(r.length < 1e4)) { var s = function (t, e, i) { let n = [], r = t, s = 0; Pt.spans(i.facet(pi), t, e, { span() { }, point(t, e) { t > r && (n.push({ from: r, to: t }), s += t - r), r = e } }, 20), r < e && (n.push({ from: r, to: e }), s += e - r); return { total: s, ranges: n } }(r.from, r.to, this.state); if (!(s.total < 1e4)) { let t, e; e = this.heightOracle.lineWrapping ? (t = r.from != this.viewport.from ? r.from : Cn(s, (this.visibleTop - r.top) / r.height), r.to != this.viewport.to ? r.to : Cn(s, (this.visibleBottom - r.top) / r.height)) : (o = s.total * this.heightOracle.charWidth, t = Cn(s, this.pixelViewport.left / o), Cn(s, this.pixelViewport.right / o)); var o = this.state.selection.main; o.from <= t && o.to >= r.from && (t = o.from), o.from <= r.to && o.to >= e && (e = o.to); let i = t - 1e4, n = e + 1e4; i > r.from + 5e3 && l.push(Ln(a, t => t.from == r.from && t.to > i - 5e3 && t.to < 5e3 + i) || new Wn(r.from, i, this.gapSize(r, i, !0, s))), n < r.to - 5e3 && l.push(Ln(a, t => t.to == r.to && t.from > n - 5e3 && t.from < n + 5e3) || new Wn(n, r.to, this.gapSize(r, n, !1, s))) } } }), l } gapSize(t, e, i, n) { if (this.heightOracle.lineWrapping) { var r = t.height * An(n, e); return i ? r : t.height - r } e = An(n, e); return n.total * this.heightOracle.charWidth * (i ? e : 1 - e) } updateLineGaps(t) { return Wn.same(t, this.lineGaps) ? 0 : (this.lineGaps = t, this.lineGapDeco = Me.set(t.map(t => t.draw(this.heightOracle.lineWrapping))), 8) } computeVisibleRanges() { let t = this.state.facet(pi); this.lineGaps.length && (t = t.concat(this.lineGapDeco)); let i = []; Pt.spans(t, this.viewport.from, this.viewport.to, { span(t, e) { i.push({ from: t, to: e }) }, point() { } }, 20), this.visibleRanges = i } lineAt(t, e) { return e += this.paddingTop, Vn(this.heightMap.lineAt(t, wn.ByPos, this.state.doc, e, 0), this.scaler, e) } lineAtHeight(t, e) { return e += this.paddingTop, Vn(this.heightMap.lineAt(this.scaler.fromDOM(t, e), wn.ByHeight, this.state.doc, e, 0), this.scaler, e) } blockAtHeight(t, e) { return e += this.paddingTop, Vn(this.heightMap.blockAt(this.scaler.fromDOM(t, e), this.state.doc, e, 0), this.scaler, e) } forEachLine(t, e, i, n) { return n += this.paddingTop, this.heightMap.forEachLine(t, e, this.state.doc, n, 0, 1 == this.scaler.scale ? i : t => i(Vn(t, this.scaler, n))) } get contentHeight() { return this.domHeight + this.paddingTop + this.paddingBottom } get domHeight() { return this.scaler.toDOM(this.heightMap.height, this.paddingTop) } } class _n { constructor(t, e) { this.from = t, this.to = e } eq(t) { return this.from == t.from && this.to == t.to } } function Cn({ total: t, ranges: e }, i) { if (i <= 0) return e[0].from; if (1 <= i) return e[e.length - 1].to; let n = Math.floor(t * i); for (let t = 0; ; t++) { var { from: r, to: s } = e[t], s = s - r; if (n <= s) return r + n; n -= s } } function An(t, e) { let i = 0; for (var { from: n, to: r } of t.ranges) { if (e <= r) { i += e - n; break } i += r - n } return i / t.total } function Ln(t, e) { for (var i of t) if (e(i)) return i } const zn = { toDOM(t) { return t }, fromDOM(t) { return t }, scale: 1 }; class qn { constructor(r, s, t) { let o = 0, e = 0, i = 0; this.viewports = t.map(({ from: t, to: e }) => { var i = s.lineAt(t, wn.ByPos, r, 0, 0).top, n = s.lineAt(e, wn.ByPos, r, 0, 0).bottom; return o += n - i, { from: t, to: e, top: i, bottom: n, domTop: 0, domBottom: 0 } }), this.scale = (7e6 - o) / (s.height - o); for (var n of this.viewports) n.domTop = i + (n.top - e) * this.scale, i = n.domBottom = n.domTop + (n.bottom - n.top), e = n.bottom } toDOM(n, r) { n -= r; for (let t = 0, e = 0, i = 0; ; t++) { var s = t < this.viewports.length ? this.viewports[t] : null; if (!s || n < s.top) return i + (n - e) * this.scale + r; if (n <= s.bottom) return s.domTop + (n - s.top) + r; e = s.bottom, i = s.domBottom } } fromDOM(n, r) { n -= r; for (let t = 0, e = 0, i = 0; ; t++) { var s = t < this.viewports.length ? this.viewports[t] : null; if (!s || n < s.domTop) return e + (n - i) / this.scale + r; if (n <= s.domBottom) return s.top + (n - s.domTop) + r; e = s.bottom, i = s.domBottom } } } function Vn(t, e, i) { if (1 == e.scale) return t; var n = e.toDOM(t.top, i), r = e.toDOM(t.bottom, i); return new vn(t.from, t.length, n, r - n, Array.isArray(t.type) ? t.type.map(t => Vn(t, e, i)) : t.type) } const Yn = L.define({ combine: t => t.join(" ") }), Mn = L.define({ combine: t => -1 < t.indexOf(!0) }), Zn = wt.newName(), En = wt.newName(), jn = wt.newName(), Dn = { "&light": "." + En, "&dark": "." + jn }; function Hn(e, t, i) { return new wt(t, { finish(t) { return /&/.test(t) ? t.replace(/&\w*/, t => { if ("&" == t) return e; if (!i || !i[t]) throw new RangeError(`Unsupported selector: ${t}`); return i[t] }) : e + " " + t } }) } const In = Hn("." + Zn, { "&": { position: "relative !important", boxSizing: "border-box", "&.cm-focused": { outline: "1px dotted #212121" }, display: "flex !important", flexDirection: "column" }, ".cm-scroller": { display: "flex !important", alignItems: "flex-start !important", fontFamily: "monospace", lineHeight: 1.4, height: "100%", overflowX: "auto", position: "relative", zIndex: 0 }, ".cm-content": { margin: 0, flexGrow: 2, minHeight: "100%", display: "block", whiteSpace: "pre", wordWrap: "normal", boxSizing: "border-box", padding: "4px 0", outline: "none" }, ".cm-lineWrapping": { whiteSpace: "pre-wrap", overflowWrap: "anywhere" }, "&light .cm-content": { caretColor: "black" }, "&dark .cm-content": { caretColor: "white" }, ".cm-line": { display: "block", padding: "0 2px 0 4px" }, ".cm-selectionLayer": { zIndex: -1, contain: "size style" }, ".cm-selectionBackground": { position: "absolute" }, "&light .cm-selectionBackground": { background: "#d9d9d9" }, "&dark .cm-selectionBackground": { background: "#222" }, "&light.cm-focused .cm-selectionBackground": { background: "#d7d4f0" }, "&dark.cm-focused .cm-selectionBackground": { background: "#233" }, ".cm-cursorLayer": { zIndex: 100, contain: "size style", pointerEvents: "none" }, "&.cm-focused .cm-cursorLayer": { animation: "steps(1) cm-blink 1.2s infinite" }, "@keyframes cm-blink": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} }, "@keyframes cm-blink2": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} }, ".cm-cursor": { position: "absolute", borderLeft: "1.2px solid black", marginLeft: "-0.6px", pointerEvents: "none", display: "none" }, "&dark .cm-cursor": { borderLeftColor: "#444" }, "&.cm-focused .cm-cursor": { display: "block" }, "&light .cm-activeLine": { backgroundColor: "#f3f9ff" }, "&dark .cm-activeLine": { backgroundColor: "#223039" }, "&light .cm-specialChar": { color: "red" }, "&dark .cm-specialChar": { color: "#f78" }, ".cm-tab": { display: "inline-block", overflow: "hidden", verticalAlign: "bottom" }, ".cm-placeholder": { color: "#888", display: "inline-block" }, ".cm-button": { verticalAlign: "middle", color: "inherit", fontSize: "70%", padding: ".2em 1em", borderRadius: "3px" }, "&light .cm-button": { backgroundImage: "linear-gradient(#eff1f5, #d9d9df)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)" } }, "&dark .cm-button": { backgroundImage: "linear-gradient(#393939, #111)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#111, #333)" } }, ".cm-textfield": { verticalAlign: "middle", color: "inherit", fontSize: "70%", border: "1px solid silver", padding: ".2em .5em" }, "&light .cm-textfield": { backgroundColor: "white" }, "&dark .cm-textfield": { border: "1px solid #555", backgroundColor: "inherit" } }, Dn), Gn = { childList: !0, characterData: !0, subtree: !0, characterDataOldValue: !0 }, Bn = xe.ie && xe.ie_version <= 11; class Nn { constructor(i, t, e) { this.view = i, this.onChange = t, this.onScrollChanged = e, this.active = !1, this.ignoreSelection = new ne, this.delayedFlush = -1, this.queue = [], this.lastFlush = 0, this.scrollTargets = [], this.intersection = null, this.intersecting = !1, this._selectionRange = null, this.parentCheck = -1, this.dom = i.contentDOM, this.observer = new MutationObserver(t => { for (var e of t) this.queue.push(e); this._selectionRange = null, (xe.ie && xe.ie_version <= 11 || xe.ios && i.composing) && t.some(t => "childList" == t.type && t.removedNodes.length || "characterData" == t.type && t.oldValue.length > t.target.nodeValue.length) ? this.flushSoon() : this.flush() }), Bn && (this.onCharData = t => { this.queue.push({ target: t.target, type: "characterData", oldValue: t.prevValue }), this.flushSoon() }), this.onSelectionChange = this.onSelectionChange.bind(this), this.start(), this.onScroll = this.onScroll.bind(this), window.addEventListener("scroll", this.onScroll), "function" == typeof IntersectionObserver && (this.intersection = new IntersectionObserver(t => { this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), 0 < t[t.length - 1].intersectionRatio != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event"))) }, {}), this.intersection.observe(this.dom)), this.listenForScroll() } onScroll(t) { this.intersecting && this.flush(), this.onScrollChanged(t) } onSelectionChange(e) { this.lastFlush < Date.now() - 50 && (this._selectionRange = null); let { view: i } = this, n = this.selectionRange; if (i.state.facet(si) ? i.root.activeElement == this.dom : Nt(i.dom, n)) { let t = n.anchorNode && i.docView.nearest(n.anchorNode); t && t.ignoreEvent(e) || (xe.ie && xe.ie_version <= 11 && !i.state.selection.main.empty && n.focusNode && Ft(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset) ? this.flushSoon() : this.flush()) } } get selectionRange() { if (!this._selectionRange) { let { root: t } = this.view, e = Gt(t); xe.safari && 11 == t.nodeType && function () { let t = document.activeElement; for (; t && t.shadowRoot;)t = t.shadowRoot.activeElement; return t }() == this.view.contentDOM && (e = function (t) { let e = null; function i(t) { t.preventDefault(), t.stopImmediatePropagation(), e = t.getTargetRanges()[0] } if (t.contentDOM.addEventListener("beforeinput", i, !0), document.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", i, !0), !e) return null; let n = e.startContainer, r = e.startOffset, s = e.endContainer, o = e.endOffset, a = t.docView.domAtPos(t.state.selection.main.anchor); Ft(a.node, a.offset, s, o) && ([n, r, s, o] = [s, o, n, r]); return { anchorNode: n, anchorOffset: r, focusNode: s, focusOffset: o } }(this.view) || e), this._selectionRange = e } return this._selectionRange } setSelectionRange(t, e) { var i; null !== (i = this._selectionRange) && void 0 !== i && i.type || (this._selectionRange = { anchorNode: t.node, anchorOffset: t.offset, focusNode: e.node, focusOffset: e.offset }) } listenForScroll() { this.parentCheck = -1; let e = 0, i = null; for (let t = this.dom; t;)if (1 == t.nodeType) !i && e < this.scrollTargets.length && this.scrollTargets[e] == t ? e++ : i = i || this.scrollTargets.slice(0, e), i && i.push(t), t = t.assignedSlot || t.parentNode; else { if (11 != t.nodeType) break; t = t.host } if (e < this.scrollTargets.length && !i && (i = this.scrollTargets.slice(0, e)), i) { for (var t of this.scrollTargets) t.removeEventListener("scroll", this.onScroll); for (var n of this.scrollTargets = i) n.addEventListener("scroll", this.onScroll) } } ignore(t) { if (!this.active) return t(); try { return this.stop(), t() } finally { this.start(), this.clear() } } start() { this.active || (this.observer.observe(this.dom, Gn), this.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange), Bn && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0) } stop() { this.active && (this.active = !1, this.observer.disconnect(), this.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange), Bn && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData)) } clearSelection() { this.ignoreSelection.set(this.selectionRange) } clear() { this.observer.takeRecords(), this.queue.length = 0, this.clearSelection() } flushSoon() { this.delayedFlush < 0 && (this.delayedFlush = window.setTimeout(() => { this.delayedFlush = -1, this.flush() }, 20)) } forceFlush() { 0 <= this.delayedFlush && (window.clearTimeout(this.delayedFlush), this.delayedFlush = -1, this.flush()) } flush() { if (!(0 <= this.delayedFlush)) { this.lastFlush = Date.now(); let n = this.queue; for (var t of this.observer.takeRecords()) n.push(t); n.length && (this.queue = []); var r = this.selectionRange, s = !this.ignoreSelection.eq(r) && Nt(this.dom, r); if (0 != n.length || s) { let t = -1, e = -1, i = !1; for (var o of n) { o = this.readMutation(o); o && (o.typeOver && (i = !0), -1 == t ? { from: t, to: e } = o : (t = Math.min(o.from, t), e = Math.max(o.to, e))) } r = this.view.state; (-1 < t || s) && this.onChange(t, e, i), this.view.state == r && (this.view.docView.dirty && (this.ignore(() => this.view.docView.sync()), this.view.docView.dirty = 0), this.view.docView.updateSelection()), this.clearSelection() } } } readMutation(t) { let e = this.view.docView.nearest(t.target); if (!e || e.ignoreMutation(t)) return null; if (e.markDirty(), "childList" != t.type) return { from: e.posAtStart, to: e.posAtEnd, typeOver: t.target.nodeValue == t.oldValue }; var i = Un(e, t.previousSibling || t.target.previousSibling, -1), t = Un(e, t.nextSibling || t.target.nextSibling, 1); return { from: i ? e.posAfter(i) : e.posAtStart, to: t ? e.posBefore(t) : e.posAtEnd, typeOver: !1 } } destroy() { this.stop(), this.intersection && this.intersection.disconnect(); for (var t of this.scrollTargets) t.removeEventListener("scroll", this.onScroll); window.removeEventListener("scroll", this.onScroll), clearTimeout(this.parentCheck) } } function Un(t, e, i) { for (; e;) { var n = Oe.get(e); if (n && n.parent == t) return n; n = e.parentNode; e = n != t.dom ? n : 0 < i ? e.nextSibling : e.previousSibling } return null } function Fn(n, t, e, r) { let s, o, a = n.state.selection.main, l; if (-1 < t && (l = n.docView.domBoundsAround(t, e, 0))) { var { from: h, to: c } = l, O = n.docView.impreciseHead || n.docView.impreciseAnchor ? [] : function (t) { let e = []; if (t.root.activeElement != t.contentDOM) return e; var { anchorNode: i, anchorOffset: n, focusNode: r, focusOffset: t } = t.observer.selectionRange; i && (e.push(new tr(i, n)), r == i && t == n || e.push(new tr(r, t))); return e }(n); let t = new Jn(O, n); t.readRange(l.startDOM, l.endDOM), o = function (t, e) { if (0 == t.length) return null; var i = t[0].pos, t = 2 == t.length ? t[1].pos : i; return -1 < i && -1 < t ? _.single(i + e, t + e) : null }(O, h); let e = a.from, i = null; (8 === n.inputState.lastKeyCode && n.inputState.lastKeyTime > Date.now() - 100 || xe.android && t.text.length < c - h) && (e = a.to, i = "end"); O = function (t, e, i, n) { let r = Math.min(t.length, e.length), s = 0; for (; s < r && t.charCodeAt(s) == e.charCodeAt(s);)s++; if (s == r && t.length == e.length) return null; let o = t.length, a = e.length; for (; 0 < o && 0 < a && t.charCodeAt(o - 1) == e.charCodeAt(a - 1);)o--, a--; "end" == n && (l = Math.max(0, s - Math.min(o, a)), i -= o + l - s); { var l; o < s && t.length < e.length ? (l = i <= s && i >= o ? s - i : 0, s -= l, a = s + (a - o), o = s) : a < s && (i = i <= s && i >= a ? s - i : 0, s -= i, o = s + (o - a), a = s) } return { from: s, toA: o, toB: a } }(n.state.sliceDoc(h, c), t.text, e - h, i); O && (s = { from: h + O.from, to: h + O.toA, insert: n.state.toText(t.text.slice(O.from, O.toB)) }) } else !n.hasFocus && n.state.facet(si) || (c = n.observer.selectionRange, { impreciseHead: h, impreciseAnchor: O } = n.docView, h = h && h.node == c.focusNode && h.offset == c.focusOffset || !Bt(n.contentDOM, c.focusNode) ? n.state.selection.main.head : n.docView.posFromDOM(c.focusNode, c.focusOffset), c = O && O.node == c.anchorNode && O.offset == c.anchorOffset || !Bt(n.contentDOM, c.anchorNode) ? n.state.selection.main.anchor : n.docView.posFromDOM(c.anchorNode, c.anchorOffset), h == a.head && c == a.anchor || (o = _.single(c, h))); if (s || o) if (!s && r && !a.empty && o && o.main.empty ? s = { from: a.from, to: a.to, insert: n.state.doc.slice(a.from, a.to) } : s && s.from >= a.from && s.to <= a.to && (s.from != a.from || s.to != a.to) && a.to - a.from - (s.to - s.from) <= 4 && (s = { from: a.from, to: a.to, insert: n.state.doc.slice(a.from, s.from).append(s.insert).append(n.state.doc.slice(s.to, a.to)) }), s) { let i = n.state; if (!(xe.android && (s.from == a.from && s.to == a.to && 1 == s.insert.length && 2 == s.insert.lines && le(n.contentDOM, "Enter", 13) || s.from == a.from - 1 && s.to == a.to && 0 == s.insert.length && le(n.contentDOM, "Backspace", 8) || s.from == a.from && s.to == a.to + 1 && 0 == s.insert.length && le(n.contentDOM, "Delete", 46)) || xe.ios && n.inputState.flushIOSKey(n))) { let e = s.insert.toString(); if (!n.state.facet(ni).some(t => t(n, s.from, s.to, e))) { 0 <= n.inputState.composing && n.inputState.composing++; let t; var d; t = s.from >= a.from && s.to <= a.to && s.to - s.from >= (a.to - a.from) / 3 && (!o || o.main.empty && o.main.from == s.from + s.insert.length) ? (r = a.from < s.from ? i.sliceDoc(a.from, s.from) : "", d = a.to > s.to ? i.sliceDoc(s.to, a.to) : "", i.replaceSelection(n.state.toText(r + s.insert.sliceString(0, void 0, n.state.lineBreak) + d))) : { changes: d = i.changes(s), selection: o && !i.selection.main.eq(o.main) && o.main.to <= d.newLength ? i.selection.replaceRange(o.main) : void 0 }, n.dispatch(t, { scrollIntoView: !0, annotations: st.userEvent.of("input") }) } } } else if (o && !o.main.eq(a)) { let t = !1, e; n.inputState.lastSelectionTime > Date.now() - 50 && ("keyboardselection" == n.inputState.lastSelectionOrigin ? t = !0 : e = st.userEvent.of(n.inputState.lastSelectionOrigin)), n.dispatch({ selection: o, scrollIntoView: t, annotations: e }) } } class Jn { constructor(t, e) { this.points = t, this.view = e, this.text = "", this.lineBreak = e.state.lineBreak } readRange(e, i) { if (e) { var n = e.parentNode; for (let t = e; ;) { this.findPointBefore(n, t), this.readNode(t); var r = t.nextSibling; if (r == i) break; var s = Oe.get(t), o = Oe.get(r); ((s ? s.breakAfter : Kn(t)) || (o ? o.breakAfter : Kn(r)) && ("BR" != t.nodeName || t.cmIgnore)) && (this.text += this.lineBreak), t = r } this.findPointBefore(n, i) } } readNode(i) { if (!i.cmIgnore) { var n = Oe.get(i); let t = n && n.overrideDOMText, e; null != t ? e = t.sliceString(0, void 0, this.lineBreak) : 3 == i.nodeType ? e = i.nodeValue : "BR" == i.nodeName ? e = i.nextSibling ? this.lineBreak : "" : 1 == i.nodeType && this.readRange(i.firstChild, null), null != e && (this.findPointIn(i, e.length), this.text += e, xe.chrome && 13 == this.view.inputState.lastKeyCode && !i.nextSibling && /\n\n$/.test(this.text) && (this.text = this.text.slice(0, -1))) } } findPointBefore(t, e) { for (var i of this.points) i.node == t && t.childNodes[i.offset] == e && (i.pos = this.text.length) } findPointIn(t, e) { for (var i of this.points) i.node == t && (i.pos = this.text.length + Math.min(i.offset, e)) } } function Kn(t) { return 1 == t.nodeType && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName) } class tr { constructor(t, e) { this.node = t, this.offset = e, this.pos = -1 } } class er { constructor(t = {}) { this.plugins = [], this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.style.cssText = "position: absolute; top: -10000px", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), this._dispatch = t.dispatch || (t => this.update([t])), this.dispatch = this.dispatch.bind(this), this.root = t.root || document, this.viewState = new Rn(t.state || pt.create()), this.plugins = this.state.facet(hi).map(t => new di(t).update(this)), this.observer = new Nn(this, (t, e, i) => { Fn(this, t, e, i) }, t => { this.inputState.runScrollHandlers(this, t), this.observer.intersecting && this.measure() }), this.inputState = new Ui(this), this.docView = new vi(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, window.addEventListener("resize", () => { -1 == rr && (rr = setTimeout(sr, 50)) }), this.requestMeasure(), t.parent && t.parent.appendChild(this.dom) } get state() { return this.viewState.state } get viewport() { return this.viewState.viewport } get visibleRanges() { return this.viewState.visibleRanges } get inView() { return this.viewState.inView } get composing() { return 0 < this.inputState.composing } dispatch(...t) { this._dispatch(1 == t.length && t[0] instanceof st ? t[0] : this.state.update(...t)) } update(t) { if (0 != this.updateState) throw new Error("Calls to EditorView.update are not allowed while an update is in progress"); let e = !1, i, n = this.state; for (var r of t) { if (r.startState != n) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state."); n = r.state } if (n.facet(pt.phrases) != this.state.facet(pt.phrases)) return this.setState(n); i = new Qi(this, n, t); try { this.updateState = 2; var s = t.some(t => t.scrollIntoView) ? n.selection.main : null; this.viewState.update(i, s), this.bidiCache = ar.update(this.bidiCache, i.changes), i.empty || this.updatePlugins(i), e = this.docView.update(i), this.state.facet(mi) != this.styleModules && this.mountStyles(), this.updateAttrs(), this.showAnnouncements(t) } finally { this.updateState = 0 } if ((e || scrollTo || this.viewState.mustEnforceCursorAssoc) && this.requestMeasure(), !i.empty) for (var o of this.state.facet(ii)) o(i) } setState(t) { if (0 != this.updateState) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress"); this.updateState = 2; try { for (var e of this.plugins) e.destroy(this); this.viewState = new Rn(t), this.plugins = t.facet(hi).map(t => new di(t).update(this)), this.docView = new vi(this), this.inputState.ensureHandlers(this), this.mountStyles(), this.updateAttrs(), this.bidiCache = [] } finally { this.updateState = 0 } this.requestMeasure() } updatePlugins(i) { let t = i.startState.facet(hi), n = i.state.facet(hi); if (t != n) { let e = []; for (var r of n) { var s = t.indexOf(r); if (s < 0) e.push(new di(r)); else { let t = this.plugins[s]; t.mustUpdate = i, e.push(t) } } for (var o of this.plugins) o.mustUpdate != i && o.destroy(this); this.plugins = e, this.inputState.ensureHandlers(this) } else for (var e of this.plugins) e.mustUpdate = i; for (let t = 0; t < this.plugins.length; t++)this.plugins[t] = this.plugins[t].update(this) } measure() { -1 < this.measureScheduled && cancelAnimationFrame(this.measureScheduled), this.measureScheduled = -1; let n = null; try { for (let i = 0; ; i++) { this.updateState = 1; var r = this.viewState.measure(this.docView, 0 < i); let e = this.measureRequests; if (!r && !e.length && null == this.viewState.scrollTo) break; if (this.measureRequests = [], 5 < i) { console.warn("Viewport failed to stabilize"); break } var s = e.map(t => { try { return t.read(this) } catch (t) { return ri(this.state, t), or } }); let t = new Qi(this, this.state); t.flags |= r, n ? n.flags |= r : n = t, this.updateState = 2, t.empty || this.updatePlugins(t), this.updateAttrs(), r && this.docView.update(t); for (let t = 0; t < e.length; t++)if (s[t] != or) try { e[t].write(s[t], this) } catch (t) { ri(this.state, t) } if (this.viewState.scrollTo && (this.docView.scrollPosIntoView(this.viewState.scrollTo.head, this.viewState.scrollTo.assoc), this.viewState.scrollTo = null), !(4 & r) && 0 == this.measureRequests.length) break } } finally { this.updateState = 0 } if (this.measureScheduled = -1, n && !n.empty) for (var t of this.state.facet(ii)) t(n) } get themeClasses() { return Zn + " " + (this.state.facet(Mn) ? jn : En) + " " + this.state.facet(Yn) } updateAttrs() { var t = Le(this.state.facet(ui), { class: "cm-editor cm-wrap" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses }); qe(this.dom, this.editorAttrs, t), this.editorAttrs = t; t = Le(this.state.facet(fi), { spellcheck: "false", autocorrect: "off", autocapitalize: "off", contenteditable: String(this.state.facet(si)), class: "cm-content", style: `${xe.tabSize}: ${this.state.tabSize}`, role: "textbox", "aria-multiline": "true" }); qe(this.contentDOM, this.contentAttrs, t), this.contentAttrs = t } showAnnouncements(t) { let e = !0; for (var i of t) for (var n of i.effects) if (n.is(er.announce)) { e && (this.announceDOM.textContent = ""), e = !1; let t = this.announceDOM.appendChild(document.createElement("div")); t.textContent = n.value } } mountStyles() { this.styleModules = this.state.facet(mi), wt.mount(this.root, this.styleModules.concat(In).reverse()) } readMeasured() { if (2 == this.updateState) throw new Error("Reading the editor layout isn't allowed during an update"); 0 == this.updateState && -1 < this.measureScheduled && this.measure() } requestMeasure(e) { if (this.measureScheduled < 0 && (this.measureScheduled = requestAnimationFrame(() => this.measure())), e) { if (null != e.key) for (let t = 0; t < this.measureRequests.length; t++)if (this.measureRequests[t].key === e.key) return void (this.measureRequests[t] = e); this.measureRequests.push(e) } } pluginField(t) { var e, i = []; for (e of this.plugins) e.update(this).takeField(t, i); return i } plugin(t) { for (var e of this.plugins) if (e.spec == t) return e.update(this).value; return null } blockAtHeight(t, e) { return this.readMeasured(), this.viewState.blockAtHeight(t, nr(e, this.contentDOM)) } visualLineAtHeight(t, e) { return this.readMeasured(), this.viewState.lineAtHeight(t, nr(e, this.contentDOM)) } viewportLines(t, e) { var { from: i, to: n } = this.viewport; this.viewState.forEachLine(i, n, t, nr(e, this.contentDOM)) } visualLineAt(t, e = 0) { return this.viewState.lineAt(t, e) } get contentHeight() { return this.viewState.contentHeight } moveByChar(t, e, i) { return Bi(this, t, e, i) } moveByGroup(e, t) { return Bi(this, e, t, t => function (t, e, i) { let n = t.state.charCategorizer(e), r = n(i); return t => { t = n(t); return r == Ot.Space && (r = t), r == t } }(this, e.head, t)) } moveToLineBoundary(t, e, i = !0) { return function (t, e, i, n) { var r = t.state.doc.lineAt(e.head), s = n && t.lineWrapping ? t.coordsAtPos(e.assoc < 0 && e.head > r.from ? e.head - 1 : e.head) : null; if (s) { n = t.dom.getBoundingClientRect(), s = t.posAtCoords({ x: i == (t.textDirection == Si.LTR) ? n.right - 1 : n.left + 1, y: (s.top + s.bottom) / 2 }); if (null != s) return _.cursor(s, i ? -1 : 1) } return e = Ie.find(t.docView, e.head), r = e ? i ? e.posAtEnd : e.posAtStart : i ? r.to : r.from, _.cursor(r, i ? -1 : 1) }(this, t, e, i) } moveVertically(t, e, i) { return Ni(this, t, e, i) } scrollPosIntoView(t) { this.viewState.scrollTo = _.cursor(t), this.requestMeasure() } domAtPos(t) { return this.docView.domAtPos(t) } posAtDOM(t, e = 0) { return this.docView.posFromDOM(t, e) } posAtCoords(t) { return this.readMeasured(), Gi(this, t) } coordsAtPos(t, e = 1) { this.readMeasured(); var i = this.docView.coordsAt(t, e); if (!i || i.left == i.right) return i; var n = this.state.doc.lineAt(t), r = this.bidiSpans(n); return ie(i, r[qi.find(r, t - n.from, -1, e)].dir == Si.LTR == 0 < e) } get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth } get defaultLineHeight() { return this.viewState.heightOracle.lineHeight } get textDirection() { return this.viewState.heightOracle.direction } get lineWrapping() { return this.viewState.heightOracle.lineWrapping } bidiSpans(t) { if (t.length > ir) return Mi(t.length); var e, i = this.textDirection; for (e of this.bidiCache) if (e.from == t.from && e.dir == i) return e.order; var n = Yi(t.text, this.textDirection); return this.bidiCache.push(new ar(t.from, t.to, i, n)), n } get hasFocus() { var t; return (document.hasFocus() || xe.safari && (null === (t = this.inputState) || void 0 === t ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM } focus() { this.observer.ignore(() => { se(this.contentDOM), this.docView.updateSelection() }) } destroy() { for (var t of this.plugins) t.destroy(this); this.inputState.destroy(), this.dom.remove(), this.observer.destroy(), -1 < this.measureScheduled && cancelAnimationFrame(this.measureScheduled) } static domEventHandlers(t) { return ci.define(() => ({}), { eventHandlers: t }) } static theme(t, e) { var i = wt.newName(); let n = [Yn.of(i), mi.of(Hn(`.${i}`, t))]; return e && e.dark && n.push(Mn.of(!0)), n } static baseTheme(t) { return E.fallback(mi.of(Hn("." + Zn, t, Dn))) } } er.styleModule = mi, er.inputHandler = ni, er.exceptionSink = ei, er.updateListener = ii, er.editable = si, er.mouseSelectionStyle = ti, er.dragMovesSelection = Ke, er.clickAddsSelectionRange = Je, er.decorations = pi, er.contentAttributes = fi, er.editorAttributes = ui, er.lineWrapping = er.contentAttributes.of({ class: "cm-lineWrapping" }), er.announce = rt.define(); const ir = 4096; function nr(t, e) { return null == t ? e.getBoundingClientRect().top : t } let rr = -1; function sr() { rr = -1; var i = document.querySelectorAll(".cm-content"); for (let e = 0; e < i.length; e++) { let t = Oe.get(i[e]); t && t.editorView.requestMeasure() } } const or = {}; class ar { constructor(t, e, i, n) { this.from = t, this.to = e, this.dir = i, this.order = n } static update(e, i) { if (i.empty) return e; let n = [], r = e.length ? e[e.length - 1].dir : Si.LTR; for (let t = Math.max(0, e.length - 10); t < e.length; t++) { var s = e[t]; s.dir != r || i.touchesRange(s.from, s.to) || n.push(new ar(i.mapPos(s.from, 1), i.mapPos(s.to, -1), s.dir, s.order)) } return n } } const lr = "undefined" == typeof navigator ? "key" : /Mac/.test(navigator.platform) ? "mac" : /Win/.test(navigator.platform) ? "win" : /Linux|X11/.test(navigator.platform) ? "linux" : "key"; function hr(t, e, i) { return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), t = !1 !== i && e.shiftKey ? "Shift-" + t : t } const cr = L.define({ enables: er.domEventHandlers({ keydown(t, e) { return function (t, e, i, n) { let r = function (t) { return t = "Down" == (t = "Right" == (t = "Up" == (t = "Left" == (t = "Del" == (t = "Esc" == (t = !(Dt && (t.ctrlKey || t.altKey || t.metaKey) || (Mt || jt) && t.shiftKey && t.key && 1 == t.key.length) && t.key || (t.shiftKey ? Vt : qt)[t.keyCode] || t.key || "Unidentified") ? "Escape" : t) ? "Delete" : t) ? "ArrowLeft" : t) ? "ArrowUp" : t) ? "ArrowRight" : t) ? "ArrowDown" : t }(e), s = 1 == r.length && " " != r, o = "", a = !1; dr && dr.view == i && dr.scope == n && (o = dr.prefix + " ", (a = Fi.indexOf(e.keyCode) < 0) && (dr = null)); let l = t => { if (t) { for (var e of t.commands) if (e(i)) return !0; t.preventDefault && (a = !0) } return !1 }, h = t[n], c; if (h) { if (l(h[o + hr(r, e, !s)])) return !0; if (s && (e.shiftKey || e.altKey || e.metaKey) && (c = qt[e.keyCode]) && c != r) { if (l(h[o + hr(c, e, !0)])) return !0 } else if (s && e.shiftKey && l(h[o + hr(r, e, !0)])) return !0 } return a }(function (t) { let e = t.facet(cr), i = Or.get(e); i || Or.set(e, i = function (t, a = lr) { let l = Object.create(null), n = Object.create(null), h = (t, e) => { var i = n[t]; if (null == i) n[t] = e; else if (i != e) throw new Error("Key binding " + t + " is used both as a regular binding and as a multi-stroke prefix") }, e = (n, t, e, i) => { let r = l[n] || (l[n] = Object.create(null)), s = t.split(/ (?!$)/).map(t => function (t, e) { var i = t.split(/-(?!$)/); let n = i[i.length - 1]; "Space" == n && (n = " "); let r, s, o, a; for (let t = 0; t < i.length - 1; ++t) { var l = i[t]; if (/^(cmd|meta|m)$/i.test(l)) a = !0; else if (/^a(lt)?$/i.test(l)) r = !0; else if (/^(c|ctrl|control)$/i.test(l)) s = !0; else if (/^s(hift)?$/i.test(l)) o = !0; else { if (!/^mod$/i.test(l)) throw new Error("Unrecognized modifier name: " + l); "mac" == e ? a = !0 : s = !0 } } return r && (n = "Alt-" + n), s && (n = "Ctrl-" + n), a && (n = "Meta-" + n), o && (n = "Shift-" + n), n }(t, a)); for (let t = 1; t < s.length; t++) { let i = s.slice(0, t).join(" "); h(i, !0), r[i] || (r[i] = { preventDefault: !0, commands: [t => { let e = dr = { view: t, prefix: i, scope: n }; return setTimeout(() => { dr == e && (dr = null) }, ur), !0 }] }) } t = s.join(" "); h(t, !1); let o = r[t] || (r[t] = { preventDefault: !1, commands: [] }); o.commands.push(e), i && (o.preventDefault = !0) }; for (var i of t) { var r = i[a] || i.key; if (r) for (var s of i.scope ? i.scope.split(" ") : ["editor"]) e(s, r, i.run, i.preventDefault), i.shift && e(s, "Shift-" + r, i.shift, i.preventDefault) } return l }(e.reduce((t, e) => t.concat(e), []))); return i }(e.state), t, e, "editor") } }) }), Or = new WeakMap; let dr = null; const ur = 4e3; xe.ios; let fr = 0; const pr = new WeakMap; class mr { constructor({ deserialize: t } = {}) { this.id = fr++, this.deserialize = t || (() => { throw new Error("This node type doesn't define a deserialize function") }) } static string() { return new mr({ deserialize: t => t }) } static number() { return new mr({ deserialize: Number }) } static flag() { return new mr({ deserialize: () => !0 }) } set(t, e) { return t[this.id] = e, t } add(e) { return "function" != typeof e && (e = Qr.match(e)), t => { t = e(t); return void 0 === t ? null : [this, t] } } } mr.closedBy = new mr({ deserialize: t => t.split(" ") }), mr.openedBy = new mr({ deserialize: t => t.split(" ") }), mr.group = new mr({ deserialize: t => t.split(" ") }); const gr = Object.create(null); class Qr { constructor(t, e, i, n = 0) { this.name = t, this.props = e, this.id = i, this.flags = n } static define(t) { var e = t.props && t.props.length ? Object.create(null) : gr, i = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (null == t.name ? 8 : 0), n = new Qr(t.name || "", e, t.id, i); if (t.props) for (var r of t.props) Array.isArray(r) || (r = r(n)), r && r[0].set(e, r[1]); return n } prop(t) { return this.props[t.id] } get isTop() { return 0 < (1 & this.flags) } get isSkipped() { return 0 < (2 & this.flags) } get isError() { return 0 < (4 & this.flags) } get isAnonymous() { return 0 < (8 & this.flags) } is(e) { if ("string" != typeof e) return this.id == e; { if (this.name == e) return !0; let t = this.prop(mr.group); return !!t && -1 < t.indexOf(e) } } static match(t) { let r = Object.create(null); for (var e in t) for (var i of e.split(" ")) r[i] = t[e]; return i => { for (let t = i.prop(mr.group), e = -1; e < (t ? t.length : 0); e++) { var n = r[e < 0 ? i.name : t[e]]; if (n) return n } } } } Qr.none = new Qr("", Object.create(null), 0, 8); class vr { constructor(e) { this.types = e; for (let t = 0; t < e.length; t++)if (e[t].id != t) throw new RangeError("Node type ids should correspond to array positions when creating a node set") } extend(...t) { let i = []; for (var n of this.types) { let e = null; for (var r of t) { let t = r(n); t && (e = e || Object.assign({}, n.props), t[0].set(e, t[1])) } i.push(e ? new Qr(n.name, e, n.id, n.flags) : n) } return new vr(i) } } class wr { constructor(t, e, i, n) { this.type = t, this.children = e, this.positions = i, this.length = n } toString() { var t = this.children.map(t => t.toString()).join(); return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t } cursor(t, e = 0) { var i = null != t && pr.get(this) || this.topNode; let n = new Pr(i); return null != t && (n.moveTo(t, e), pr.set(this, n._tree)), n } fullCursor() { return new Pr(this.topNode, !0) } get topNode() { return new br(this, 0, 0, null) } resolve(t, e = 0) { return this.cursor(t, e).node } iterate(t) { let { enter: i, leave: n, from: r = 0, to: s = this.length } = t; for (let e = this.cursor(); ;) { let t = !1; if (e.from <= s && e.to >= r && (e.type.isAnonymous || !1 !== i(e.type, e.from, e.to))) { if (e.firstChild()) continue; e.type.isAnonymous || (t = !0) } for (; t && n && n(e.type, e.from, e.to), t = e.type.isAnonymous, !e.nextSibling();) { if (!e.parent()) return; t = !0 } } } balance(t = 1024) { return this.children.length <= Xr ? this : Rr(this.type, Qr.none, this.children, this.positions, 0, this.children.length, 0, t, this.length, 0) } static build(t) { let { buffer: e, nodeSet: m, topID: i = 0, maxBufferLength: g = 1024, reused: Q = [], minRepeatType: v = m.types.length } = t, w = Array.isArray(e) ? new Wr(e, e.length) : e, $ = m.types, y = 0; function b(i, t, e, n, r) { var { id: s, start: o, end: a, size: l } = w; let h = o - i; if (l < 0) return -1 == l ? (e.push(Q[s]), n.push(h)) : y = s, void w.next(); let c = $[s], O, d; if (a - o <= g && (d = function (t, e) { let i = w.fork(), n = 0, r = 0, s = 0, o = i.end - g, a = { size: 0, start: 0, skip: 0 }; t: for (var l = i.pos - t; i.pos > l;)if (i.id != e) { var h = i.size, c = i.pos - h; if (h < 0 || c < l || i.start < o) break; let t = i.id >= v ? 4 : 0; var O = i.start; for (i.next(); i.pos > c;) { if (i.size < 0) break t; i.id >= v && (t += 4), i.next() } r = O, n += h, s += t } else a.size = n, a.start = r, a.skip = s, s += 4, n += 4, i.next(); (e < 0 || n == t) && (a.size = n, a.start = r, a.skip = s); return 4 < a.size ? a : void 0 }(w.pos - t, r))) { var u = new Uint16Array(d.size - d.skip); let t = w.pos - d.size, e = u.length; for (; w.pos > t;)e = function e(i, n, r, s) { let { id: t, start: o, end: a, size: l } = w; w.next(); if (t == s) return r; let h = r; if (4 < l) { let t = w.pos - (l - 4); for (; w.pos > t;)r = e(i, n, r, s) } t < v && (n[--r] = h, n[--r] = a - i, n[--r] = o - i, n[--r] = t); return r }(d.start, u, e, r); O = new yr(u, a - d.start, m, r < 0 ? Qr.none : $[r]), h = d.start - i } else { var f = w.pos - l; w.next(); let t = [], e = []; for (var p = s >= v ? s : -1; w.pos > f;)w.id == p ? w.next() : b(o, f, t, e, p); t.reverse(), e.reverse(), O = -1 < p && t.length > Xr ? Rr(c, c, t, e, 0, t.length, 0, g, a - o, y) : $r(new wr(c, t, e, a - o), y) } e.push(O), n.push(h) } let n = [], r = []; for (; 0 < w.pos;)b(t.start || 0, 0, n, r, -1); var s = null !== (s = t.length) && void 0 !== s ? s : n.length ? r[0] + n[0].length : 0; return new wr($[i], n.reverse(), r.reverse(), s) } } function $r(t, e) { return e && (t.contextHash = e), t } wr.empty = new wr(Qr.none, [], [], 0); class yr { constructor(t, e, i, n = Qr.none) { this.buffer = t, this.length = e, this.set = i, this.type = n } toString() { let e = []; for (let t = 0; t < this.buffer.length;)e.push(this.childString(t)), t = this.buffer[t + 3]; return e.join(",") } childString(t) { var e = this.buffer[t], i = this.buffer[t + 3]; let n = this.set.types[e], r = n.name; if (/\W/.test(r) && !n.isError && (r = JSON.stringify(r)), i == (t += 4)) return r; let s = []; for (; t < i;)s.push(this.childString(t)), t = this.buffer[t + 3]; return r + "(" + s.join(",") + ")" } findChild(e, i, n, r) { let { buffer: s } = this, o = -1; for (let t = e; t != i; t = s[t + 3])if (-1e8 != r) { var a = s[t + 1], l = s[t + 2]; if (0 < n) { if (r < l && (o = t), r < l) break } else if (a < r && (o = t), r <= l) break } else if (o = t, 0 < n) break; return o } } class br { constructor(t, e, i, n) { this.node = t, this.from = e, this.index = i, this._parent = n } get type() { return this.node.type } get name() { return this.node.type.name } get to() { return this.from + this.node.length } nextChild(r, s, o, a = !1) { for (let n = this; ;) { for (var { children: t, positions: l } = n.node, e = 0 < s ? t.length : -1; r != e; r += s) { let e = t[r], i = l[r] + n.from; if (-1e8 == o || !(s < 0 ? o <= i : i + e.length <= o)) if (e instanceof yr) { var h = e.findChild(0, e.buffer.length, s, -1e8 == o ? -1e8 : o - i); if (-1 < h) return new Sr(new kr(n, e, r, i), null, h) } else if (a || !e.type.isAnonymous || Tr(e)) { let t = new br(e, i, r, n); return a || !t.type.isAnonymous ? t : t.nextChild(s < 0 ? e.children.length - 1 : 0, s, o) } } if (a || !n.type.isAnonymous) return null; if (r = n.index + s, n = n._parent, !n) return null } } get firstChild() { return this.nextChild(0, 1, -1e8) } get lastChild() { return this.nextChild(this.node.children.length - 1, -1, -1e8) } childAfter(t) { return this.nextChild(0, 1, t) } childBefore(t) { return this.nextChild(this.node.children.length - 1, -1, t) } nextSignificantParent() { let t = this; for (; t.type.isAnonymous && t._parent;)t = t._parent; return t } get parent() { return this._parent ? this._parent.nextSignificantParent() : null } get nextSibling() { return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null } get prevSibling() { return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null } get cursor() { return new Pr(this) } resolve(t, e = 0) { return this.cursor.moveTo(t, e).node } getChild(t, e = null, i = null) { i = xr(this, t, e, i); return i.length ? i[0] : null } getChildren(t, e = null, i = null) { return xr(this, t, e, i) } toString() { return this.node.toString() } } function xr(t, e, i, n) { let r = t.cursor, s = []; if (!r.firstChild()) return s; if (null != i) for (; !r.type.is(i);)if (!r.nextSibling()) return s; for (; ;) { if (null != n && r.type.is(n)) return s; if (r.type.is(e) && s.push(r.node), !r.nextSibling()) return null == n ? s : [] } } class kr { constructor(t, e, i, n) { this.parent = t, this.buffer = e, this.index = i, this.start = n } } class Sr { constructor(t, e, i) { this.context = t, this._parent = e, this.index = i, this.type = t.buffer.set.types[t.buffer.buffer[i]] } get name() { return this.type.name } get from() { return this.context.start + this.context.buffer.buffer[this.index + 1] } get to() { return this.context.start + this.context.buffer.buffer[this.index + 2] } child(t, e) { let { buffer: i } = this.context; e = i.findChild(this.index + 4, i.buffer[this.index + 3], t, -1e8 == e ? -1e8 : e - this.context.start); return e < 0 ? null : new Sr(this.context, this, e) } get firstChild() { return this.child(1, -1e8) } get lastChild() { return this.child(-1, -1e8) } childAfter(t) { return this.child(1, t) } childBefore(t) { return this.child(-1, t) } get parent() { return this._parent || this.context.parent.nextSignificantParent() } externalSibling(t) { return this._parent ? null : this.context.parent.nextChild(this.context.index + t, t, -1) } get nextSibling() { var { buffer: t } = this.context, e = t.buffer[this.index + 3]; return e < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new Sr(this.context, this._parent, e) : this.externalSibling(1) } get prevSibling() { let { buffer: t } = this.context; var e = this._parent ? this._parent.index + 4 : 0; return this.index == e ? this.externalSibling(-1) : new Sr(this.context, this._parent, t.findChild(e, this.index, -1, -1e8)) } get cursor() { return new Pr(this) } resolve(t, e = 0) { return this.cursor.moveTo(t, e).node } toString() { return this.context.buffer.childString(this.index) } getChild(t, e = null, i = null) { i = xr(this, t, e, i); return i.length ? i[0] : null } getChildren(t, e = null, i = null) { return xr(this, t, e, i) } } class Pr { constructor(e, t = !1) { if (this.full = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof br) this.yieldNode(e); else { this._tree = e.context.parent, this.buffer = e.context; for (let t = e._parent; t; t = t._parent)this.stack.unshift(t.index); this.bufferNode = e, this.yieldBuf(e.index) } } get name() { return this.type.name } yieldNode(t) { return !!t && (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) } yieldBuf(t, e) { this.index = t; var { start: i, buffer: n } = this.buffer; return this.type = e || n.set.types[n.buffer[t]], this.from = i + n.buffer[t + 1], this.to = i + n.buffer[t + 2], !0 } yield(t) { return !!t && (t instanceof br ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type))) } toString() { return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString() } enter(t, e) { if (!this.buffer) return this.yield(this._tree.nextChild(t < 0 ? this._tree.node.children.length - 1 : 0, t, e, this.full)); let { buffer: i } = this.buffer; e = i.findChild(this.index + 4, i.buffer[this.index + 3], t, -1e8 == e ? -1e8 : e - this.buffer.start); return !(e < 0) && (this.stack.push(this.index), this.yieldBuf(e)) } firstChild() { return this.enter(1, -1e8) } lastChild() { return this.enter(-1, -1e8) } childAfter(t) { return this.enter(1, t) } childBefore(t) { return this.enter(-1, t) } parent() { if (!this.buffer) return this.yieldNode(this.full ? this._tree._parent : this._tree.parent); if (this.stack.length) return this.yieldBuf(this.stack.pop()); var t = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent(); return this.buffer = null, this.yieldNode(t) } sibling(t) { if (!this.buffer) return !!this._tree._parent && this.yield(this._tree._parent.nextChild(this._tree.index + t, t, -1e8, this.full)); let { buffer: e } = this.buffer, i = this.stack.length - 1; if (t < 0) { var n = i < 0 ? 0 : this.stack[i] + 4; if (this.index != n) return this.yieldBuf(e.findChild(n, this.index, -1, -1e8)) } else { n = e.buffer[this.index + 3]; if (n < (i < 0 ? e.buffer.length : e.buffer[this.stack[i] + 3])) return this.yieldBuf(n) } return i < 0 && this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, -1e8, this.full)) } nextSibling() { return this.sibling(1) } prevSibling() { return this.sibling(-1) } atLastNode(i) { let n, r, { buffer: e } = this; if (e) { if (0 < i) { if (this.index < e.buffer.buffer.length) return !1 } else for (let t = 0; t < this.index; t++)if (e.buffer.buffer[t + 3] < this.index) return !1; ({ index: n, parent: r } = e) } else ({ index: n, _parent: r } = this._tree); for (; r; { index: n, _parent: r } = r)for (let t = n + i, e = i < 0 ? -1 : r.node.children.length; t != e; t += i) { var s = r.node.children[t]; if (this.full || !s.type.isAnonymous || s instanceof yr || Tr(s)) return !1 } return !0 } move(t) { if (this.enter(t, -1e8)) return !0; for (; ;) { if (this.sibling(t)) return !0; if (this.atLastNode(t) || !this.parent()) return !1 } } next() { return this.move(1) } prev() { return this.move(-1) } moveTo(t, e = 0) { for (; (this.from == this.to || (e < 1 ? this.from >= t : this.from > t) || (-1 < e ? this.to <= t : this.to < t)) && this.parent();); for (; e < 0 ? this.childBefore(t) : this.childAfter(t);)if (this.from == this.to || (e < 1 ? this.from >= t : this.from > t) || (-1 < e ? this.to <= t : this.to < t)) { this.parent(); break } return this } get node() { if (!this.buffer) return this._tree; let n = this.bufferNode, r = null, s = 0; if (n && n.context == this.buffer) t: for (let e = this.index, i = this.stack.length; 0 <= i;) { for (let t = n; t; t = t._parent)if (t.index == e) { if (e == this.index) return t; r = t, s = i + 1; break t } e = this.stack[--i] } for (let t = s; t < this.stack.length; t++)r = new Sr(this.buffer, r, this.stack[t]); return this.bufferNode = new Sr(this.buffer, r, this.index) } get tree() { return this.buffer ? null : this._tree.node } } function Tr(t) { return t.children.some(t => !t.type.isAnonymous || t instanceof yr || Tr(t)) } class Wr { constructor(t, e) { this.buffer = t, this.index = e } get id() { return this.buffer[this.index - 4] } get start() { return this.buffer[this.index - 3] } get end() { return this.buffer[this.index - 2] } get size() { return this.buffer[this.index - 1] } get pos() { return this.index } next() { this.index -= 4 } fork() { return new Wr(this.buffer, this.index) } } const Xr = 8; function Rr(t, i, n, r, s, o, a, l, e, h) { let c = [], O = []; if (e <= l) for (let t = s; t < o; t++)c.push(n[t]), O.push(r[t] - a); else { var d = Math.max(l, Math.ceil(1.5 * e / Xr)); for (let e = s; e < o;) { var u = e, f = r[e]; for (e++; e < o; e++)if (d < r[e] + n[e].length - f) break; if (e == u + 1) { var p = n[u]; if (p instanceof wr && p.type == i && p.length > d << 1) { for (let t = 0; t < p.children.length; t++)c.push(p.children[t]), O.push(p.positions[t] + f - a); continue } c.push(p) } else if (e == u + 1) c.push(n[u]); else { let t = Rr(i, i, n, r, u, e, f, l, r[e - 1] + n[e - 1].length - f, h); i == Qr.none || function (t, e) { for (var i of t) if (i.type == e) return !0; return !1 }(t.children, i) || (t = $r(new wr(Qr.none, t.children, t.positions, t.length), h)), c.push(t) } O.push(f - a) } } return $r(new wr(t, c, O, e), h) } class _r { constructor(t, e, i, n, r) { this.from = t, this.to = e, this.tree = i, this.offset = n, this.open = r } get openStart() { return 0 < (1 & this.open) } get openEnd() { return 0 < (2 & this.open) } static applyChanges(e, t, i = 128) { if (!t.length) return e; let n = [], r = 1, s = e.length ? e[0] : null, o = 0, a = 0, l = 0; for (; ;) { var h, c, O = o < t.length ? t[o++] : null, d = O ? O.fromA : 1e9; if (d - a >= i) for (; s && s.from < d;) { let t = s; if ((a >= t.from || d <= t.to || l) && (h = Math.max(t.from, a) - l, c = Math.min(t.to, d) - l, t = c <= h ? null : new _r(h, c, t.tree, t.offset + l, (0 < o ? 1 : 0) | (O ? 2 : 0))), t && n.push(t), s.to > d) break; s = r < e.length ? e[r++] : null } if (!O) break; a = O.toA, l = O.toA - O.toB } return n } static addTree(t, e = [], i = !1) { let n = [new _r(0, t.length, t, 0, i ? 2 : 0)]; for (var r of e) r.to > t.length && n.push(r); return n } } function Cr(t) { return new Ar(t) } class Ar { constructor(t, e = t.length) { this.string = t, this.length = e } get(t) { return t < 0 || t >= this.length ? -1 : this.string.charCodeAt(t) } lineAfter(t) { if (t < 0) return ""; var e = this.string.indexOf("\n", t); return this.string.slice(t, e < 0 ? this.length : Math.min(e, this.length)) } read(t, e) { return this.string.slice(t, Math.min(this.length, e)) } clip(t) { return new Ar(this.string, t) } } const Lr = new mr; function zr(e) { return L.define({ combine: e ? t => t.concat(e) : void 0 }) } class qr { constructor(t, e, i, n = []) { this.data = t, this.topNode = i, pt.prototype.hasOwnProperty("tree") || Object.defineProperty(pt.prototype, "tree", { get() { return Mr(this) } }), this.parser = e, this.extension = [Br.of(this), pt.languageData.of((t, e) => t.facet(Vr(t, e)))].concat(n) } isActiveAt(t, e) { return Vr(t, e) == this.data } findRegions(t) { var e = t.facet(Br); if ((null == e ? void 0 : e.data) == this.data) return [{ from: 0, to: t.doc.length }]; if (!e || !e.allowsNesting) return []; let n = []; return Mr(t).iterate({ enter: (t, e, i) => { if (t.isTop && t.prop(Lr) == this.data) return n.push({ from: e, to: i }), !1 } }), n } get allowsNesting() { return !0 } parseString(t) { var e = d.of(t.split("\n")); let i = this.parser.startParse(new Zr(e), 0, new Er(this.parser, pt.create({ doc: e }), [], wr.empty, { from: 0, to: t.length }, [], null)), n; for (; !(n = i.advance());); return n } } function Vr(t, e) { var i = t.facet(Br); if (!i) return null; if (!i.allowsNesting) return i.data; let n = Mr(t), r = n.resolve(e, -1); for (; r;) { var s = r.type.prop(Lr); if (s) return s; r = r.parent } return i.data } qr.setState = rt.define(); class Yr extends qr { constructor(t, e) { super(t, e, e.topNode), this.parser = e } static define(t) { let e = zr(t.languageData); return new Yr(e, t.parser.configure({ props: [Lr.add(t => t.isTop ? e : void 0)] })) } configure(t) { return new Yr(this.data, this.parser.configure(t)) } get allowsNesting() { return this.parser.hasNested } } function Mr(t) { t = t.field(qr.state, !1); return t ? t.tree : wr.empty } class Zr { constructor(t, e = t.length) { this.doc = t, this.length = e, this.cursorPos = 0, this.string = "", this.prevString = "", this.cursor = t.iter() } syncTo(t) { return t < this.cursorPos && (this.cursor = this.doc.iter(), this.cursorPos = 0), this.prevString = t == this.cursorPos ? this.string : "", this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length } get(t) { if (t >= this.length) return -1; let e = this.cursorPos - this.string.length; if (t < e || t >= this.cursorPos) { if (t < e && t >= e - this.prevString.length) return this.prevString.charCodeAt(t - (e - this.prevString.length)); e = this.syncTo(t) } return this.string.charCodeAt(t - e) } lineAfter(t) { if (t >= this.length || t < 0) return ""; let e = this.cursorPos - this.string.length; return (t < e || t >= this.cursorPos) && (e = this.syncTo(t)), this.cursor.lineBreak ? "" : this.string.slice(t - e, Math.min(this.length - e, this.string.length)) } read(t, e) { var i = this.cursorPos - this.string.length; return t < i || e >= this.cursorPos ? this.doc.sliceString(t, e) : this.string.slice(t - i, e - i) } clip(t) { return new Zr(this.doc, t) } } class Er { constructor(t, e, i = [], n, r, s, o) { this.parser = t, this.state = e, this.fragments = i, this.tree = n, this.viewport = r, this.skipped = s, this.scheduleOn = o, this.parse = null, this.tempSkipped = [] } work(t, e) { if (this.tree != wr.empty && (null == e ? this.tree.length == this.state.doc.length : this.tree.length >= e)) return this.takeTree(), !0; this.parse || (this.parse = this.parser.startParse(new Zr(this.state.doc), 0, this)); for (var i = Date.now() + t; ;) { var n = this.parse.advance(); if (n) return this.fragments = this.withoutTempSkipped(_r.addTree(n)), this.parse = null, this.tree = n, !0; if (null != e && this.parse.pos >= e) return this.takeTree(), !0; if (Date.now() > i) return !1 } } takeTree() { this.parse && this.parse.pos > this.tree.length && (this.tree = this.parse.forceFinish(), this.fragments = this.withoutTempSkipped(_r.addTree(this.tree, this.fragments, !0))) } withoutTempSkipped(t) { for (var e; e = this.tempSkipped.pop();)t = jr(t, e.from, e.to); return t } changes(t, e) { let { fragments: i, tree: n, viewport: s, skipped: o } = this; if (this.takeTree(), !t.empty) { let r = []; if (t.iterChangedRanges((t, e, i, n) => r.push({ fromA: t, toA: e, fromB: i, toB: n })), i = _r.applyChanges(i, r), n = wr.empty, s = { from: t.mapPos(s.from, -1), to: t.mapPos(s.to, 1) }, this.skipped.length) { o = []; for (var a of this.skipped) { var l = t.mapPos(a.from, 1), a = t.mapPos(a.to, -1); l < a && o.push({ from: l, to: a }) } } } return new Er(this.parser, e, i, n, s, o, this.scheduleOn) } updateViewport(e) { this.viewport = e; var t = this.skipped.length; for (let t = 0; t < this.skipped.length; t++) { var { from: i, to: n } = this.skipped[t]; i < e.to && n > e.from && (this.fragments = jr(this.fragments, i, n), this.skipped.splice(t--, 1)) } return this.skipped.length < t } reset() { this.parse && (this.takeTree(), this.parse = null) } skipUntilInView(t, e) { this.skipped.push({ from: t, to: e }) } static getSkippingParser(r) { return { startParse(e, i, n) { return { pos: i, advance() { let t = n; return t.tempSkipped.push({ from: i, to: e.length }), r && (t.scheduleOn = t.scheduleOn ? Promise.all([t.scheduleOn, r]) : r), this.pos = e.length, new wr(Qr.none, [], [], e.length - i) }, forceFinish() { return this.advance() } } } } } movedPast(t) { return this.tree.length < t && this.parse && this.parse.pos >= t } } function jr(t, e, i) { return _r.applyChanges(t, [{ fromA: e, toA: i, fromB: e, toB: i }]) } Er.skippingParser = Er.getSkippingParser(); class Dr { constructor(t) { this.context = t, this.tree = t.tree } apply(t) { if (!t.docChanged) return this; let e = this.context.changes(t.changes, t.state); t = this.context.tree.length == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.tree.length), e.viewport.to); return e.work(25, t) || e.takeTree(), new Dr(e) } static init(t) { let e = new Er(t.facet(Br).parser, t, [], wr.empty, { from: 0, to: t.doc.length }, [], null); return e.work(25) || e.takeTree(), new Dr(e) } } qr.state = M.define({ create: Dr.init, update(t, e) { for (var i of e.effects) if (i.is(qr.setState)) return i.value; return e.startState.facet(Br) != e.state.facet(Br) ? Dr.init(e.state) : t.apply(e) } }); let Hr = "undefined" != typeof window && window.requestIdleCallback || ((t, { timeout: e }) => setTimeout(t, e)), Ir = "undefined" != typeof window && window.cancelIdleCallback || clearTimeout; var Gr = ci.fromClass(class { constructor(t) { this.view = t, this.working = -1, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork() } update(t) { let e = this.view.state.field(qr.state).context; t.viewportChanged && (e.updateViewport(t.view.viewport) && e.reset(), this.view.viewport.to > e.tree.length && this.scheduleWork()), t.docChanged && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e) } scheduleWork(i = !1) { if (!(-1 < this.working)) { let { state: t } = this.view, e = t.field(qr.state); !i && e.tree.length >= t.doc.length || (this.working = Hr(this.work, { timeout: 500 })) } } work(n) { this.working = -1; var r = Date.now(); if (this.chunkEnd < r && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = r + 3e4, this.chunkBudget = 3e3), !(this.chunkBudget <= 0)) { let { state: t, viewport: { to: e } } = this.view, i = t.field(qr.state); i.tree.length >= e + 1e6 || (n = Math.min(this.chunkBudget, n ? Math.max(25, n.timeRemaining()) : 100), n = i.context.work(n, e + 1e6), this.chunkBudget -= Date.now() - r, (n || this.chunkBudget <= 0 || i.context.movedPast(e)) && (i.context.takeTree(), this.view.dispatch({ effects: qr.setState.of(new Dr(i.context)) })), !n && 0 < this.chunkBudget && this.scheduleWork(), this.checkAsyncSchedule(i.context)) } } checkAsyncSchedule(t) { t.scheduleOn && (t.scheduleOn.then(() => this.scheduleWork(!0)), t.scheduleOn = null) } destroy() { 0 <= this.working && Ir(this.working) } }, { eventHandlers: { focus() { this.scheduleWork() } } }); const Br = L.define({ combine(t) { return t.length ? t[0] : null }, enables: [qr.state, Gr] }); class Nr { constructor(t, e = []) { this.language = t, this.support = e, this.extension = [t, e] } } class Ur { constructor(t, e, i, n, r) { this.name = t, this.alias = e, this.extensions = i, this.filename = n, this.loadFunc = r, this.support = void 0, this.loading = null } load() { return this.loading || (this.loading = this.loadFunc().then(t => this.support = t, t => { throw this.loading = null, t })) } static of(t) { return new Ur(t.name, (t.alias || []).concat(t.name).map(t => t.toLowerCase()), t.extensions || [], t.filename, t.load) } static matchFilename(t, e) { for (var i of t) if (i.filename && i.filename.test(e)) return i; var n = /\.([^.]+)$/.exec(e); if (n) for (var r of t) if (-1 < r.extensions.indexOf(n[1])) return r; return null } static matchLanguageName(t, e, i = !0) { e = e.toLowerCase(); for (var n of t) if (n.alias.some(t => t == e)) return n; if (i) for (var r of t) for (var s of r.alias) { var o = e.indexOf(s); if (-1 < o && (2 < s.length || !/\w/.test(e[o - 1]) && !/\w/.test(e[o + s.length]))) return r } return null } } const Fr = L.define(), Jr = L.define({ combine: t => { if (!t.length) return "  "; if (!/^(?: +|\t+)$/.test(t[0])) throw new Error("Invalid indent unit: " + JSON.stringify(t[0])); return t[0] } }); function Kr(t) { let e = t.facet(Jr); return 9 == e.charCodeAt(0) ? t.tabSize * e.length : e.length } function ts(t, e) { let i = "", n = t.tabSize; if (9 == t.facet(Jr).charCodeAt(0)) for (; n <= e;)i += "\t", e -= n; for (let t = 0; t < e; t++)i += " "; return i } function es(t, e) { for (var i of (t = t instanceof pt ? new is(t) : t).state.facet(Fr)) { i = i(t, e); if (null != i) return i } var n = Mr(t.state); return n ? function (t, e, i) { let n = e.resolve(i); for (let t = n, e = i; ;) { var r = t.childBefore(e); if (!r) break; e = r.type.isError && r.from == r.to ? (n = t, r.from) : (t = r, t.to + 1) } return ss(n, i, t) }(t, n, e) : null } class is { constructor(t, e = {}) { this.state = t, this.options = e, this.unit = Kr(t) } textAfterPos(t) { var e, i = null === (i = this.options) || void 0 === i ? void 0 : i.simulateBreak; return t == i && null !== (e = this.options) && void 0 !== e && e.simulateDoubleBreak ? "" : this.state.sliceDoc(t, Math.min(t + 100, null != i && t < i ? i : 1e9, this.state.doc.lineAt(t).to)) } column(t) { let e = this.state.doc.lineAt(t), i = e.text.slice(0, t - e.from), n = this.countColumn(i, t - e.from); t = null !== (t = this.options) && void 0 !== t && t.overrideIndentation ? this.options.overrideIndentation(e.from) : -1; return -1 < t && (n += t - this.countColumn(i, i.search(/\S/))), n } countColumn(t, e) { return x(e < 0 ? t : t.slice(0, e), 0, this.state.tabSize) } lineIndent(t) { let e = null === (i = this.options) || void 0 === i ? void 0 : i.overrideIndentation; if (e) { var i = e(t.from); if (-1 < i) return i } return this.countColumn(t.text, t.text.search(/\S/)) } } const ns = new mr; function rs(t) { var e = t.type.prop(ns); if (e) return e; let i = t.firstChild, n; if (i && (n = i.type.prop(mr.closedBy))) { let e = t.lastChild, i = e && -1 < n.indexOf(e.name); return t => ls(t, !0, 1, void 0, i && !function (t) { var e, i; return t.pos == (null === (e = t.options) || void 0 === e ? void 0 : e.simulateBreak) && null !== (i = t.options) && void 0 !== i && i.simulateDoubleBreak }(t) ? e.from : void 0) } return null == t.parent ? os : null } function ss(e, i, n) { for (; e; e = e.parent) { let t = rs(e); if (t) return t(new as(n, i, e)) } return null } function os() { return 0 } class as extends is { constructor(t, e, i) { super(t.state, t.options), this.base = t, this.pos = e, this.node = i } get textAfter() { return this.textAfterPos(this.pos) } get baseIndent() { let e = this.state.doc.lineAt(this.node.from); for (; ;) { let t = this.node.resolve(e.from); for (; t.parent && t.parent.from == t.from;)t = t.parent; if (function (e, i) { for (let t = i; t; t = t.parent)if (e == t) return !0; return !1 }(t, this.node)) break; e = this.state.doc.lineAt(t.from) } return this.lineIndent(e) } continue() { var t = this.node.parent; return t ? ss(t, this.pos, this.base) : 0 } } function ls(t, e, i, n, r) { let s = t.textAfter, o = s.match(/^\s*/)[0].length; r = n && s.slice(o, o + n.length) == n || r == t.pos + o, e = e ? function (t) { let e = t.node; var i = e.childAfter(e.from), n = e.lastChild; if (!i) return null; var r = null === (r = t.options) || void 0 === r ? void 0 : r.simulateBreak, t = t.state.doc.lineAt(i.from), s = null == r || r <= t.from ? t.to : Math.min(t.to, r); for (let t = i.to; ;) { var o = e.childAfter(t); if (!o || o == n) return null; if (!o.type.isSkipped) return o.from < s ? i : null; t = o.to } }(t) : null; return e ? r ? t.column(e.from) : t.column(e.to) : t.baseIndent + (r ? 0 : t.unit * i) } function hs({ except: i, units: n = 1 } = {}) { return t => { var e = i && i.test(t.textAfter); return t.baseIndent + (e ? 0 : n * t.unit) } } L.define(); const cs = new mr; function Os(t) { var e = t.firstChild, i = t.lastChild; return e && e.to < i.from ? { from: e.to, to: i.type.isError ? t.to : i.from } : null } var ds = er.baseTheme({ ".cm-matchingBracket": { color: "#0b0" }, ".cm-nonmatchingBracket": { color: "#a22" } }); const us = 1e4, fs = "()[]{}", ps = L.define({ combine(t) { return mt(t, { afterCursor: !0, brackets: fs, maxScanDistance: us }) } }), ms = Me.mark({ class: "cm-matchingBracket" }), gs = Me.mark({ class: "cm-nonmatchingBracket" }), Qs = [M.define({ create() { return Me.none }, update(t, e) { if (!e.docChanged && !e.selection) return t; let i = []; var n, r = e.state.facet(ps); for (n of e.state.selection.ranges) if (n.empty) { var s = ws(e.state, n.head, -1, r) || 0 < n.head && ws(e.state, n.head - 1, 1, r) || r.afterCursor && (ws(e.state, n.head, 1, r) || n.head < e.state.doc.length && ws(e.state, n.head + 1, -1, r)); if (s) { let t = s.matched ? ms : gs; i.push(t.range(s.start.from, s.start.to)), s.end && i.push(t.range(s.end.from, s.end.to)) } } return Me.set(i, !0) }, provide: t => er.decorations.from(t) }), ds]; function vs(t, e, i) { var n = t.prop(e < 0 ? mr.openedBy : mr.closedBy); if (n) return n; if (1 == t.name.length) { t = i.indexOf(t.name); if (-1 < t && t % 2 == (e < 0 ? 1 : 0)) return [i[t + e]] } return null } function ws(t, e, i, n = {}) { var r = n.maxScanDistance || us, n = n.brackets || fs; let s = Mr(t), o = s.resolve(e, i), a; return (a = vs(o.type, i, n)) ? function (t, e, i, n) { let r = e.parent, s = { from: e.from, to: e.to }, o = 0, a = null == r ? void 0 : r.cursor; if (a && (t < 0 ? a.childBefore(e.from) : a.childAfter(e.to))) do { if (t < 0 ? a.to <= e.from : a.from >= e.to) { if (0 == o && -1 < i.indexOf(a.type.name)) return { start: s, end: { from: a.from, to: a.to }, matched: !0 }; if (vs(a.type, t, n)) o++; else if (vs(a.type, -t, n) && (o--, 0 == o)) return { start: s, end: { from: a.from, to: a.to }, matched: !1 } } } while (t < 0 ? a.prevSibling() : a.nextSibling()); return { start: s, matched: !1 } }(i, o, a, n) : function (t, e, i, n, r, s, o) { var a = i < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), l = o.indexOf(a); if (l < 0 || l % 2 == 0 != 0 < i) return null; let h = { from: i < 0 ? e - 1 : e, to: 0 < i ? e + 1 : e }, c = t.doc.iterRange(e, 0 < i ? t.doc.length : 0), O = 0; for (let t = 0; !c.next().done && t <= s;) { var d = c.value; i < 0 && (t += d.length); var u = e + t * i; for (let t = 0 < i ? 0 : d.length - 1, e = 0 < i ? d.length : -1; t != e; t += i) { var f = o.indexOf(d[t]); if (!(f < 0 || n.resolve(u + t, 1).type != r)) if (f % 2 == 0 == 0 < i) O++; else { if (1 == O) return { start: h, end: { from: u + t, to: u + t + 1 }, matched: f >> 1 == l >> 1 }; O-- } } 0 < i && (t += d.length) } return c.done ? { start: h, matched: !1 } : null }(t, e, i, s, o.type, r, n) } const $s = { brackets: ["(", "[", "{", "'", '"'], before: ")]}'\":;>" }, ys = rt.define({ map(t, e) { t = e.mapPos(t, -1, w.TrackAfter); return null == t ? void 0 : t } }), bs = rt.define({ map(t, e) { return e.mapPos(t) } }), xs = new class extends bt { }; xs.startSide = 1, xs.endSide = -1; const ks = M.define({ create() { return Pt.empty }, update(t, i) { var e, n; i.selection && (e = i.state.doc.lineAt(i.selection.main.head).from, n = i.startState.doc.lineAt(i.startState.selection.main.head).from, e != i.changes.mapPos(n, -1) && (t = Pt.empty)), t = t.map(i.changes); for (let e of i.effects) e.is(ys) ? t = t.update({ add: [xs.range(e.value, e.value + 1)] }) : e.is(bs) && (t = t.update({ filter: t => t != e.value })); return t } }); const Ss = "()[]{}<>"; function Ps(e) { for (let t = 0; t < Ss.length; t += 2)if (Ss.charCodeAt(t) == e) return Ss.charAt(t + 1); return (t = e < 128 ? e : e + 1) <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t))); var t } function Ts(t, e) { return t.languageDataAt("closeBrackets", e)[0] || $s } function Ws(t, e, i, n) { if (t.composing) return !1; var r = t.state.selection.main; if (2 < n.length || 2 == n.length && 1 == O(c(n, 0)) || e != r.from || i != r.to) return !1; n = function (t, e) { let i = Ts(t, t.selection.main.head), n = i.brackets || $s.brackets; for (var r of n) { var s = Ps(c(r, 0)); if (e == r) return s == r ? function (r, s, o) { let a = null, t = r.changeByRange(t => { if (!t.empty) return { changes: [{ insert: s, from: t.from }, { insert: s, from: t.to }], effects: ys.of(t.to + s.length), range: _.range(t.anchor + s.length, t.head + s.length) }; var e = t.head, i = _s(r.doc, e); if (i == s) { if (Cs(r, e)) return { changes: { insert: s + s, from: e }, effects: ys.of(e + s.length), range: _.cursor(e + s.length) }; if (Rs(r, e)) { var n = o && r.sliceDoc(e, e + 3 * s.length) == s + s + s; return { range: _.cursor(e + s.length * (n ? 3 : 1)), effects: bs.of(e) } } } else { if (o && r.sliceDoc(e - 2 * s.length, e) == s + s && Cs(r, e - 2 * s.length)) return { changes: { insert: s + s + s + s, from: e }, effects: ys.of(e + s.length), range: _.cursor(e + s.length) }; if (r.charCategorizer(e)(i) != Ot.Word) { i = r.sliceDoc(e - 1, e); if (i != s && r.charCategorizer(e)(i) != Ot.Word) return { changes: { insert: s + s, from: e }, effects: ys.of(e + s.length), range: _.cursor(e + s.length) } } } return { range: a = t } }); return a ? null : r.update(t, { scrollIntoView: !0, annotations: st.userEvent.of("input") }) }(t, r, -1 < n.indexOf(r + r + r)) : function (i, n, r, s) { let o = null, t = i.changeByRange(t => { if (!t.empty) return { changes: [{ insert: n, from: t.from }, { insert: r, from: t.to }], effects: ys.of(t.to + n.length), range: _.range(t.anchor + n.length, t.head + n.length) }; var e = _s(i.doc, t.head); return !e || /\s/.test(e) || -1 < s.indexOf(e) ? { changes: { insert: n + r, from: t.head }, effects: ys.of(t.head + n.length), range: _.cursor(t.head + n.length) } : { range: o = t } }); return o ? null : i.update(t, { scrollIntoView: !0, annotations: st.userEvent.of("input") }) }(t, r, s, i.before || $s.before); if (e == s && Rs(t, t.selection.main.from)) return function (e, i) { let n = null, t = e.selection.ranges.map(t => t.empty && _s(e.doc, t.head) == i ? _.cursor(t.head + i.length) : n = t); return n ? null : e.update({ selection: _.create(t, e.selection.mainIndex), scrollIntoView: !0, effects: e.selection.ranges.map(({ from: t }) => bs.of(t)) }) }(t, (r, s)) } return null }(t.state, n); return !!n && (t.dispatch(n), !0) } const Xs = [{ key: "Backspace", run: ({ state: n, dispatch: t }) => { let r = Ts(n, n.selection.main.head).brackets || $s.brackets, s = null, e = n.changeByRange(t => { if (t.empty) { var e, i = function (t, e) { let i = t.sliceString(e - 2, e); return O(c(i, 0)) == i.length ? i : i.slice(1) }(n.doc, t.head); for (e of r) if (e == i && _s(n.doc, t.head) == Ps(c(e, 0))) return { changes: { from: t.head - e.length, to: t.head + e.length }, range: _.cursor(t.head - e.length), annotations: st.userEvent.of("delete") } } return { range: s = t } }); return s || t(n.update(e, { scrollIntoView: !0 })), !s } }]; function Rs(t, e) { let i = !1; return t.field(ks).between(0, t.doc.length, t => { t == e && (i = !0) }), i } function _s(t, e) { let i = t.sliceString(e, e + 2); return i.slice(0, O(c(i, 0))) } function Cs(t, e) { t = Mr(t).resolve(e + 1); return t.parent && t.from == e } function As(t, e) { return _.create(t.ranges.map(e), t.mainIndex) } function Ls(t, e) { return t.update({ selection: e, scrollIntoView: !0, annotations: st.userEvent.of("keyboardselection") }) } function zs({ state: t, dispatch: e }, i) { let n = As(t.selection, i); return !n.eq(t.selection) && (e(Ls(t, n)), !0) } function qs(t, e) { return _.cursor(e ? t.to : t.from) } function Vs(e, i) { return zs(e, t => t.empty ? e.moveByChar(t, i) : qs(t, i)) } var Ys = t => Vs(t, t.textDirection != Si.LTR), Ms = t => Vs(t, t.textDirection == Si.LTR); function Zs(e, i) { return zs(e, t => t.empty ? e.moveByGroup(t, i) : qs(t, i)) } function Es(e, i, n) { let r = Mr(e).resolve(i.head); var s, o, a, l = n ? mr.closedBy : mr.openedBy; for (let t = i.head; ;) { var h = n ? r.childAfter(t) : r.childBefore(t); if (!h) break; s = e, a = l, (o = h).type.prop(a) || ((a = o.to - o.from) && (2 < a || /[^\s,.;:]/.test(s.sliceDoc(o.from, o.to))) || o.firstChild) ? r = h : t = n ? h.to : h.from } let t = r.type.prop(l), c, O; return O = t && (c = n ? ws(e, r.from, 1) : ws(e, r.to, -1)) && c.matched ? n ? c.end.to : c.end.from : n ? r.to : r.from, _.cursor(O, n ? -1 : 1) } function js(e, i) { return zs(e, t => t.empty ? e.moveVertically(t, i) : qs(t, i)) } var Ds = t => js(t, !1), Hs = t => js(t, !0); function Is(e, i) { return zs(e, t => t.empty ? e.moveVertically(t, i, e.dom.clientHeight) : qs(t, i)) } var Gs = t => Is(t, !1), Bs = t => Is(t, !0); function Ns(t, e, i) { let n = t.visualLineAt(e.head), r = t.moveToLineBoundary(e, i); return r.head == e.head && r.head != (i ? n.to : n.from) && (r = t.moveToLineBoundary(e, i, !1)), i || r.head != n.from || !n.length || (t = /^\s*/.exec(t.state.sliceDoc(n.from, Math.min(n.from + 100, n.to)))[0].length) && e.head != n.from + t && (r = _.cursor(n.from + t)), r } var Us = e => zs(e, t => Ns(e, t, !0)), Fs = e => zs(e, t => Ns(e, t, !1)); function Js(t, i) { let e = As(t.state.selection, t => { var e = i(t); return _.range(t.anchor, e.head, e.goalColumn) }); return !e.eq(t.state.selection) && (t.dispatch(Ls(t.state, e)), !0) } function Ks(e, i) { return Js(e, t => e.moveByChar(t, i)) } var to = t => Ks(t, t.textDirection != Si.LTR), eo = t => Ks(t, t.textDirection == Si.LTR); function io(e, i) { return Js(e, t => e.moveByGroup(t, i)) } function no(e, i) { return Js(e, t => e.moveVertically(t, i)) } var ro = t => no(t, !1), Yt = t => no(t, !0); function so(e, i) { return Js(e, t => e.moveVertically(t, i, e.dom.clientHeight)) } Zt = t => so(t, !1), Et = t => so(t, !0), ve = e => Js(e, t => Ns(e, t, !0)), ge = e => Js(e, t => Ns(e, t, !1)), Qe = ({ state: t, dispatch: e }) => (e(Ls(t, { anchor: 0 })), !0), me = ({ state: t, dispatch: e }) => (e(Ls(t, { anchor: t.doc.length })), !0), we = ({ state: t, dispatch: e }) => (e(Ls(t, { anchor: t.selection.main.anchor, head: 0 })), !0), $e = ({ state: t, dispatch: e }) => (e(Ls(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0); function oo({ state: t, dispatch: e }, r) { var i = t.changeByRange(t => { let { from: e, to: i } = t; var n; return e == i && (n = r(e), e = Math.min(e, n), i = Math.max(i, n)), e == i ? { range: t } : { changes: { from: e, to: i }, range: _.cursor(e) } }); return !i.changes.empty && (e(t.update(i, { scrollIntoView: !0, annotations: st.userEvent.of("delete") })), !0) } const ao = (a, l, h) => oo(a, e => { let { state: t } = a, i = t.doc.lineAt(e), n; if (!l && e > i.from && e < i.from + 200 && !/[^ \t]/.test(n = i.text.slice(0, e - i.from))) { if ("\t" == n[n.length - 1]) return e - 1; var r = x(n, 0, t.tabSize) % Kr(t) || Kr(t); for (let t = 0; t < r && " " == n[n.length - 1 - t]; t++)e--; return e } let s; var o; return s = h ? (o = (o = i.text.slice(e - i.from + (l ? 0 : -2), e - i.from + (l ? 2 : 0))) ? O(c(o, 0)) : 1, l ? Math.min(t.doc.length, e + o) : Math.max(0, e - o)) : b(i.text, e - i.from, l) + i.from, s == e && i.number != (l ? t.doc.lines : 1) && (s += l ? 1 : -1), s }); fe = t => ao(t, !1, !0), be = t => ao(t, !0, !1); const lo = (t, h) => oo(t, e => { let i = e, { state: n } = t, r = n.doc.lineAt(i), s = n.charCategorizer(i); for (let t = null; ;) { if (i == (h ? r.to : r.from)) { i == e && r.number != (h ? n.doc.lines : 1) && (i += h ? 1 : -1); break } var o = b(r.text, i - r.from, h) + r.from, a = r.text.slice(Math.min(i, o) - r.from, Math.max(i, o) - r.from), l = s(a); if (null != t && l != t) break; " " == a && i == e || (t = l), i = o } return i }); ye = t => lo(t, !1), pe = t => lo(t, !0), Gr = i => oo(i, t => { var e = i.visualLineAt(t).to; return t < e ? e : Math.min(i.state.doc.length, t + 1) }); function ho(t) { let e = [], i = -1; for (var n of t.selection.ranges) { var r = t.doc.lineAt(n.from), n = t.doc.lineAt(n.to); i == r.number ? e[e.length - 1].to = n.to : e.push({ from: r.from, to: n.to }), i = n.number } return e } function co(t, e, i) { let n = []; for (var r of ho(t)) { var s; (i ? r.to != t.doc.length : 0 != r.from) && (s = t.doc.lineAt(i ? r.to + 1 : r.from - 1), i ? n.push({ from: r.to, to: s.to }, { from: r.from, insert: s.text + t.lineBreak }) : n.push({ from: s.from, to: r.from }, { from: r.to, insert: t.lineBreak + s.text })) } return !!n.length && (e(t.update({ changes: n, scrollIntoView: !0 })), !0) } function Oo(t, e, i) { let n = []; for (var r of ho(t)) i ? n.push({ from: r.from, insert: t.doc.slice(r.from, r.to) + t.lineBreak }) : n.push({ from: r.to, insert: t.lineBreak + t.doc.slice(r.from, r.to) }); return e(t.update({ changes: n, scrollIntoView: !0 })), !0 } function uo(r, s) { let o = -1; return r.changeByRange(e => { var i = []; for (let t = e.from; t <= e.to;) { var n = r.doc.lineAt(t); n.number > o && (e.empty || e.to > n.from) && (s(n, i, e), o = n.number), t = n.to + 1 } let t = r.changes(i); return { changes: i, range: _.range(t.mapPos(e.anchor, 1), t.mapPos(e.head, 1)) } }) } ds = ({ state: o, dispatch: t }) => { let a = Object.create(null), l = new is(o, { overrideIndentation: t => { t = a[t]; return null == t ? -1 : t } }); var e = uo(o, (t, e, i) => { var n, r, s = es(l, t.from); null == s || ((n = /^\s*/.exec(t.text)[0]) != (r = ts(o, s)) || i.from < t.from + n.length) && (a[t.from] = s, e.push({ from: t.from, to: t.from + n.length, insert: r })) }); return e.changes.empty || t(o.update(e)), !0 }; const fo = ({ state: i, dispatch: t }) => (t(i.update(uo(i, (t, e) => { e.push({ from: t.from, insert: i.facet(Jr) }) }))), !0); const po = [{ key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: e => zs(e, t => Es(e.state, t, e.textDirection != Si.LTR)), shift: e => Js(e, t => Es(e.state, t, e.textDirection != Si.LTR)) }, { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: e => zs(e, t => Es(e.state, t, e.textDirection == Si.LTR)), shift: e => Js(e, t => Es(e.state, t, e.textDirection == Si.LTR)) }, { key: "Alt-ArrowUp", run: ({ state: t, dispatch: e }) => co(t, e, !1) }, { key: "Shift-Alt-ArrowUp", run: ({ state: t, dispatch: e }) => Oo(t, e, !1) }, { key: "Alt-ArrowDown", run: ({ state: t, dispatch: e }) => co(t, e, !0) }, { key: "Shift-Alt-ArrowDown", run: ({ state: t, dispatch: e }) => Oo(t, e, !0) }, { key: "Escape", run: ({ state: t, dispatch: e }) => { let i = t.selection, n = null; return 1 < i.ranges.length ? n = _.create([i.main]) : i.main.empty || (n = _.create([_.cursor(i.main.head)])), !!n && (e(Ls(t, n)), !0) } }, { key: "Alt-l", mac: "Ctrl-l", run: ({ state: i, dispatch: t }) => { var e = ho(i).map(({ from: t, to: e }) => _.range(t, Math.min(e + 1, i.doc.length))); return t(i.update({ selection: _.create(e), annotations: st.userEvent.of("keyboardselection") })), !0 } }, { key: "Mod-i", run: ({ state: n, dispatch: t }) => { var e = As(n.selection, t => { var e; let i = Mr(n).resolve(t.head, 1); for (; !(i.from < t.from && i.to >= t.to || i.to > t.to && i.from <= t.from || null === (e = i.parent) || void 0 === e) && e.parent;)i = i.parent; return _.range(i.to, i.from) }); return t(Ls(n, e)), !0 }, preventDefault: !0 }, { key: "Mod-[", run: ({ state: o, dispatch: t }) => (t(o.update(uo(o, (n, r) => { let s = /^\s*/.exec(n.text)[0]; if (s) { let t = x(s, 0, o.tabSize), e = 0, i = ts(o, Math.max(0, t - Kr(o))); for (; e < s.length && e < i.length && s.charCodeAt(e) == i.charCodeAt(e);)e++; r.push({ from: n.from + e, to: n.from + s.length, insert: i.slice(e) }) } }))), !0) }, { key: "Mod-]", run: fo }, { key: "Mod-Alt-\\", run: ds }, { key: "Shift-Mod-k", run: e => { let { state: i } = e, t = i.changes(ho(i).map(({ from: t, to: e }) => (0 < t ? t-- : e < i.doc.length && e++, { from: t, to: e }))); var n = As(i.selection, t => e.moveVertically(t, !0)).map(t); return e.dispatch({ changes: t, selection: n, scrollIntoView: !0 }), !0 } }, { key: "Shift-Mod-\\", run: ({ state: t, dispatch: e }) => function (i, t, n) { let r = !1, e = As(i.selection, t => { var e = ws(i, t.head, -1) || ws(i, t.head, 1) || 0 < t.head && ws(i, t.head - 1, 1) || t.head < i.doc.length && ws(i, t.head + 1, -1); if (!e || !e.end) return t; r = !0; e = e.start.from == t.head ? e.end.to : e.end.from; return n ? _.range(t.anchor, e) : _.cursor(e) }); return !!r && (t(Ls(i, e)), !0) }(t, e, !1) }].concat([{ key: "ArrowLeft", run: Ys, shift: to }, { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: t => Zs(t, t.textDirection != Si.LTR), shift: t => io(t, t.textDirection != Si.LTR) }, { mac: "Cmd-ArrowLeft", run: Fs, shift: ge }, { key: "ArrowRight", run: Ms, shift: eo }, { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: t => Zs(t, t.textDirection == Si.LTR), shift: t => io(t, t.textDirection == Si.LTR) }, { mac: "Cmd-ArrowRight", run: Us, shift: ve }, { key: "ArrowUp", run: Ds, shift: ro }, { mac: "Cmd-ArrowUp", run: Qe, shift: we }, { mac: "Ctrl-ArrowUp", run: Gs, shift: Zt }, { key: "ArrowDown", run: Hs, shift: Yt }, { mac: "Cmd-ArrowDown", run: me, shift: $e }, { mac: "Ctrl-ArrowDown", run: Bs, shift: Et }, { key: "PageUp", run: Gs, shift: Zt }, { key: "PageDown", run: Bs, shift: Et }, { key: "Home", run: Fs, shift: ge }, { key: "Mod-Home", run: Qe, shift: we }, { key: "End", run: Us, shift: ve }, { key: "Mod-End", run: me, shift: $e }, { key: "Enter", run: ({ state: a, dispatch: t }) => { var e = a.changeByRange(({ from: t, to: e }) => { var i = t == e && function (t, e) { if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1))) return { from: e, to: e }; let i = Mr(t).resolve(e), n = i.childBefore(e), r = i.childAfter(e), s; return n && r && n.to <= e && r.from >= e && (s = n.type.prop(mr.closedBy)) && -1 < s.indexOf(r.name) && t.doc.lineAt(n.to).from == t.doc.lineAt(r.from).from ? { from: n.to, to: r.from } : null }(a, t); let n = new is(a, { simulateBreak: t, simulateDoubleBreak: !!i }), r = es(n, t); null == r && (r = /^\s*/.exec(a.doc.lineAt(t).text)[0].length); let s = a.doc.lineAt(t); for (; e < s.to && /\s/.test(s.text.slice(e - s.from, e + 1 - s.from));)e++; i ? { from: t, to: e } = i : t > s.from && t < s.from + 100 && !/\S/.test(s.text.slice(0, t)) && (t = s.from); let o = ["", ts(a, r)]; return i && o.push(ts(a, n.lineIndent(s))), { changes: { from: t, to: e, insert: d.of(o) }, range: _.cursor(t + 1 + o[1].length) } }); return t(a.update(e, { scrollIntoView: !0 })), !0 } }, { key: "Mod-a", run: ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, annotations: st.userEvent.of("keyboardselection") })), !0) }, { key: "Backspace", run: fe, shift: fe }, { key: "Delete", run: be, shift: be }, { key: "Mod-Backspace", mac: "Alt-Backspace", run: ye }, { key: "Mod-Delete", mac: "Alt-Delete", run: pe }, { mac: "Mod-Backspace", run: i => oo(i, t => { var e = i.visualLineAt(t).from; return e < t ? e : Math.max(0, t - 1) }) }, { mac: "Mod-Delete", run: Gr }].concat([{ key: "Ctrl-b", run: Ys, shift: to, preventDefault: !0 }, { key: "Ctrl-f", run: Ms, shift: eo }, { key: "Ctrl-p", run: Ds, shift: ro }, { key: "Ctrl-n", run: Hs, shift: Yt }, { key: "Ctrl-a", run: e => zs(e, t => _.cursor(e.visualLineAt(t.head).from, 1)), shift: e => Js(e, t => _.cursor(e.visualLineAt(t.head).from)) }, { key: "Ctrl-e", run: e => zs(e, t => _.cursor(e.visualLineAt(t.head).to, -1)), shift: e => Js(e, t => _.cursor(e.visualLineAt(t.head).to)) }, { key: "Ctrl-d", run: be }, { key: "Ctrl-h", run: t => ao(t, !1, !1) }, { key: "Ctrl-k", run: Gr }, { key: "Alt-d", run: pe }, { key: "Ctrl-Alt-h", run: ye }, { key: "Ctrl-o", run: ({ state: t, dispatch: e }) => { var i = t.changeByRange(t => ({ changes: { from: t.from, to: t.to, insert: d.of(["", ""]) }, range: _.cursor(t.from) })); return e(t.update(i, { scrollIntoView: !0, annotations: st.userEvent.of("input") })), !0 } }, { key: "Ctrl-t", run: ({ state: n, dispatch: t }) => { var e = n.changeByRange(t => { if (!t.empty || 0 == t.from || t.from == n.doc.length) return { range: t }; var e = t.from, i = n.doc.lineAt(e), t = e == i.from ? e - 1 : b(i.text, e - i.from, !1) + i.from, i = e == i.to ? e + 1 : b(i.text, e - i.from, !0) + i.from; return { changes: { from: t, to: i, insert: n.doc.slice(e, i).append(n.doc.slice(t, e)) }, range: _.cursor(i) } }); return !e.changes.empty && (t(n.update(e, { scrollIntoView: !0 })), !0) } }, { key: "Alt-f", run: t => Zs(t, !0), shift: t => io(t, !0) }, { key: "Alt-b", run: t => Zs(t, !1), shift: t => io(t, !1) }, { key: "Alt-<", run: Qe }, { key: "Alt->", run: me }, { key: "Ctrl-v", run: Bs }, { key: "Alt-v", run: Gs }].map(t => ({ mac: t.key, run: t.run, shift: t.shift })))), mo = { key: "Tab", run: ({ state: t, dispatch: e }) => t.selection.ranges.some(t => !t.empty) ? fo({ state: t, dispatch: e }) : (e(t.update(t.replaceSelection("\t"), { scrollIntoView: !0, annotations: st.userEvent.of("input") })), !0), shift: ds }, go = et.define(), Qo = et.define(), vo = L.define(), wo = L.define({ combine(t) { return mt(t, { minDepth: 100, newGroupDelay: 500 }, { minDepth: Math.max, newGroupDelay: Math.min }) } }), $o = M.define({ create() { return _o.empty }, update(e, i) { var n = i.state.facet(wo), r = i.annotation(go); if (r) { var s = ko.fromTransaction(i), o = r.side; let t = 0 == o ? e.undone : e.done; return t = s ? So(t, t.length, n.minDepth, s) : Xo(t, i.startState.selection), new _o(0 == o ? r.rest : t, 0 == o ? t : r.rest) } var t = i.annotation(Qo); if ("full" != t && "before" != t || (e = e.isolate()), !1 === i.annotation(st.addToHistory)) return i.changes.empty ? e : e.addMapping(i.changes.desc); s = ko.fromTransaction(i), o = i.annotation(st.time), r = i.annotation(st.userEvent); return s ? e = e.addChanges(s, o, r, n.newGroupDelay, n.minDepth) : i.selection && (e = e.addSelection(i.startState.selection, o, r, n.newGroupDelay)), e = "full" == t || "after" == t ? e.isolate() : e }, toJSON(t) { return { done: t.done.map(t => t.toJSON()), undone: t.undone.map(t => t.toJSON()) } }, fromJSON(t) { return new _o(t.done.map(ko.fromJSON), t.undone.map(ko.fromJSON)) } }); function yo(n, r) { return function ({ state: t, dispatch: e }) { let i = t.field($o, !1); if (!i) return !1; t = i.pop(n, t, r); return !!t && (e(t), !0) } } const bo = yo(0, !1), xo = yo(1, !1); eo = yo(0, !0), Ds = yo(1, !0); class ko { constructor(t, e, i, n, r) { this.changes = t, this.effects = e, this.mapped = i, this.startSelection = n, this.selectionsAfter = r } setSelAfter(t) { return new ko(this.changes, this.effects, this.mapped, this.startSelection, t) } toJSON() { var t; return { changes: null === (t = this.changes) || void 0 === t ? void 0 : t.toJSON(), mapped: null === (t = this.mapped) || void 0 === t ? void 0 : t.toJSON(), startSelection: null === (t = this.startSelection) || void 0 === t ? void 0 : t.toJSON(), selectionsAfter: this.selectionsAfter.map(t => t.toJSON()) } } static fromJSON(t) { return new ko(t.changes && k.fromJSON(t.changes), [], t.mapped && y.fromJSON(t.mapped), t.startSelection && _.fromJSON(t.startSelection), t.selectionsAfter.map(_.fromJSON)) } static fromTransaction(t) { let e = To; for (var i of t.startState.facet(vo)) { i = i(t); i.length && (e = e.concat(i)) } return !e.length && t.changes.empty ? null : new ko(t.changes.invert(t.startState.doc), e, void 0, t.startState.selection, To) } static selection(t) { return new ko(void 0, To, void 0, void 0, t) } } function So(t, e, i, n) { let r = t.slice(i + 20 < e + 1 ? e - i - 1 : 0, e); return r.push(n), r } function Po(t, e) { return t.length ? e.length ? t.concat(e) : t : e } const To = [], Wo = 200; function Xo(i, n) { if (i.length) { let t = i[i.length - 1], e = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - Wo)); return e.length && e[e.length - 1].eq(n) ? i : (e.push(n), So(i, i.length - 1, 1e9, t.setSelAfter(e))) } return [ko.selection([n])] } function Ro(e, t) { if (!e.length) return e; let i = e.length, n = To; for (; i;) { var r = function (t, e, i) { var n = Po(t.selectionsAfter.length ? t.selectionsAfter.map(t => t.map(e)) : To, i); if (!t.changes) return ko.selection(n); var r = t.changes.map(e), s = e.mapDesc(t.changes, !0), i = t.mapped ? t.mapped.composeDesc(s) : s; return new ko(r, rt.mapEffects(t.effects, e), i, t.startSelection.map(s), n) }(e[i - 1], t, n); if (r.changes && !r.changes.empty || r.effects.length) { let t = e.slice(0, i); return t[i - 1] = r, t } t = r.mapped, i--, n = r.selectionsAfter } return n.length ? [ko.selection(n)] : To } class _o { constructor(t, e, i = 0, n = void 0) { this.done = t, this.undone = e, this.prevTime = i, this.prevUserEvent = n } isolate() { return this.prevTime ? new _o(this.done, this.undone) : this } addChanges(t, e, i, n, r) { let s = this.done, o = s[s.length - 1]; return s = o && o.changes && e - this.prevTime < n && !o.selectionsAfter.length && !o.changes.empty && t.changes && function (t, e) { let o = [], a = !1; return t.iterChangedRanges((t, e) => o.push(t, e)), e.iterChangedRanges((t, e, i, n) => { for (let t = 0; t < o.length;) { var r = o[t++], s = o[t++]; r <= n && i <= s && (a = !0) } }), a }(o.changes, t.changes) ? So(s, s.length - 1, r, new ko(t.changes.compose(o.changes), Po(t.effects, o.effects), o.mapped, o.startSelection, To)) : So(s, s.length, r, t), new _o(s, To, e, i) } addSelection(t, e, i, n) { var r, s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : To; return 0 < s.length && e - this.prevTime < n && "keyboardselection" == i && this.prevUserEvent == i && (s = s[s.length - 1], r = t, s.ranges.length == r.ranges.length && 0 === s.ranges.filter((t, e) => t.empty != r.ranges[e].empty).length) ? this : new _o(Xo(this.done, t), this.undone, e, i) } addMapping(t) { return new _o(Ro(this.done, t), Ro(this.undone, t), this.prevTime, this.prevUserEvent) } pop(e, i, t) { let n = 0 == e ? this.done : this.undone; if (0 == n.length) return null; var r = n[n.length - 1]; if (t && r.selectionsAfter.length) return i.update({ selection: r.selectionsAfter[r.selectionsAfter.length - 1], annotations: go.of({ side: e, rest: function (t) { let e = t[t.length - 1], i = t.slice(); return i[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), i }(n) }) }); if (r.changes) { let t = 1 == n.length ? To : n.slice(0, n.length - 1); return r.mapped && (t = Ro(t, r.mapped)), i.update({ changes: r.changes, selection: r.startSelection, effects: r.effects, annotations: go.of({ side: e, rest: t }), filter: !1 }) } return null } } _o.empty = new _o(To, To); const Co = [{ key: "Mod-z", run: bo, preventDefault: !0 }, { key: "Mod-y", mac: "Mod-Shift-z", run: xo, preventDefault: !0 }, { key: "Mod-u", run: eo, preventDefault: !0 }, { key: "Alt-u", mac: "Mod-Shift-u", run: Ds, preventDefault: !0 }]; let Ao = 0; class Lo { constructor(t, e, i) { this.set = t, this.base = e, this.modified = i, this.id = Ao++ } static define(t) { if (null != t && t.base) throw new Error("Can not derive from a modified tag"); let e = new Lo([], null, []); if (e.set.push(e), t) for (var i of t.set) e.set.push(i); return e } static defineModifier() { let e = new qo; return t => -1 < t.modified.indexOf(e) ? t : qo.get(t.base || t, t.modified.concat(e).sort((t, e) => t.id - e.id)) } } let zo = 0; class qo { constructor() { this.instances = [], this.id = zo++ } static get(e, i) { if (!i.length) return e; var t, n = i[0].instances.find(t => t.base == e && function (t, i) { return t.length == i.length && t.every((t, e) => t == i[e]) }(i, t.modified)); if (n) return n; let r = [], s = new Lo(r, e, i); for (t of i) t.instances.push(s); var o, a = function e(i) { let n = [i]; for (let t = 0; t < i.length; t++)for (var r of e(i.slice(0, t).concat(i.slice(t + 1)))) n.push(r); return n }(i); for (o of e.set) for (var l of a) r.push(qo.get(o, l)); return s } } function Vo(t) { let s = Object.create(null); for (var e in t) { let r = t[e]; Array.isArray(r) || (r = [r]); for (var o of e.split(" ")) if (o) { let e = [], i = 2, n = o; for (let t = 0; ;) { if ("..." == n && 0 < t && t + 3 == o.length) { i = 1; break } var a = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(n); if (!a) throw new RangeError("Invalid path: " + o); if (e.push("*" == a[0] ? null : '"' == a[0][0] ? JSON.parse(a[0]) : a[0]), t += a[0].length, t == o.length) break; a = o[t++]; if (t == o.length && "!" == a) { i = 0; break } if ("/" != a) throw new RangeError("Invalid path: " + o); n = o.slice(t) } var l = e.length - 1, h = e[l]; if (!h) throw new RangeError("Invalid path: " + o); let t = new jo(r, i, 0 < l ? e.slice(0, l) : null); s[h] = t.sort(s[h]) } } return Yo.add(s) } const Yo = new mr, Mo = L.define({ combine(t) { return t.length ? Do.combinedMatch(t) : null } }), Zo = L.define({ combine(t) { return t.length ? t[0].match : null } }); function Eo(t) { return t.facet(Mo) || t.facet(Zo) } class jo { constructor(t, e, i, n) { this.tags = t, this.mode = e, this.context = i, this.next = n } sort(t) { return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t) } get depth() { return this.context ? this.context.length : 0 } } class Do { constructor(t, e) { this.map = Object.create(null); let i; function n(t) { var e = wt.newName(); return (i = i || Object.create(null))["." + e] = t, e } this.all = "string" == typeof e.all ? e.all : e.all ? n(e.all) : null; for (var r of t) { var s = (r.class || n(Object.assign({}, r, { tag: null }))) + (this.all ? " " + this.all : ""), r = r.tag; if (Array.isArray(r)) for (var o of r) this.map[o.id] = s; else this.map[r.id] = s } this.module = i ? new wt(i) : null, this.scope = e.scope || null, this.match = this.match.bind(this); let a = [Io]; this.module && a.push(er.styleModule.of(this.module)), this.extension = a.concat(Mo.of(this)), this.fallback = a.concat(Zo.of(this)) } match(t, e) { if (this.scope && e != this.scope) return null; for (var i of t.set) { var n = this.map[i.id]; if (void 0 !== n) return i != t && (this.map[t.id] = n), n } return this.map[t.id] = this.all } static combinedMatch(o) { if (1 == o.length) return o[0].match; let a = o.some(t => t.scope) ? void 0 : Object.create(null); return (t, e) => { var i, n = a && a[t.id]; if (void 0 !== n) return n; let r = null; for (i of o) { var s = i.match(t, e); s && (r = r ? r + " " + s : s) } return a && (a[t.id] = r), r } } static define(t, e) { return new Do(t, e || {}) } static get(t, e, i) { let n = Eo(t); return n && n(e, i || Qr.none) } } class Ho { constructor(t) { this.markCache = Object.create(null), this.tree = Mr(t.state), this.decorations = this.buildDeco(t, Eo(t.state)) } update(t) { var e = Mr(t.state), i = Eo(t.state), n = i != t.startState.facet(Mo); e.length < t.view.viewport.to && !n ? this.decorations = this.decorations.map(t.changes) : (e != this.tree || t.viewportChanged || n) && (this.tree = e, this.decorations = this.buildDeco(t.view, i)) } buildDeco(t, e) { if (!e || !this.tree.length) return Me.none; let n = new Tt; for (var { from: i, to: r } of t.visibleRanges) !function (t, e, i, d, n) { let r = e, u = "", f = t.topNode.cursor; function p(t, e) { u && n(r, t, u), r = t, u = e } (function r(s, o, a) { let { type: l, from: h, to: c } = f; if (!(i <= h || c <= e)) { Go[o] = l.name, l.isTop && (a = l); let t = s, e = l.prop(Yo), i = !1; for (; e;) { if (!e.context || function (i, n, r) { if (!(i.length > r - 1)) { for (let t = r - 1, e = i.length - 1; 0 <= e; e--, t--) { var s = i[e]; if (s && s != n[t]) return } return 1 } }(e.context, Go, o)) { for (var O of e.tags) (O = d(O, a)) && (t && (t += " "), t += O, 1 == e.mode ? s += (s ? " " : "") + O : 0 == e.mode && (i = !0)); break } e = e.next } let n = h; if (!i && f.firstChild()) { for (; f.from > n && u != t && p(n, t), n = f.to, r(s, o + 1, a), f.nextSibling();); f.parent() } c > n && u != t && p(n, t) } })("", 0, t.type), p(i, "") }(this.tree, i, r, e, (t, e, i) => { n.add(t, e, this.markCache[i] || (this.markCache[i] = Me.mark({ class: i }))) }); return n.finish() } } const Io = E.fallback(ci.fromClass(Ho, { decorations: t => t.decorations })), Go = [""]; var Bo, ro = Lo.define, Hs = ro(), Yt = ro(), be = ro(Yt), Gr = ro(), pe = ro(Gr), ye = ro(Gr), Qe = ro(), me = ro(Qe), Bs = ro(), Gs = ro(), ds = ro(), eo = ro(ds), Ds = ro(); const No = { comment: Hs, lineComment: ro(Hs), blockComment: ro(Hs), docComment: ro(Hs), name: Yt, variableName: ro(Yt), typeName: be, tagName: ro(be), propertyName: ro(Yt), className: ro(Yt), labelName: ro(Yt), namespace: ro(Yt), macroName: ro(Yt), literal: Gr, string: pe, docString: ro(pe), character: ro(pe), number: ye, integer: ro(ye), float: ro(ye), bool: ro(Gr), regexp: ro(Gr), escape: ro(Gr), color: ro(Gr), url: ro(Gr), keyword: Bs, self: ro(Bs), null: ro(Bs), atom: ro(Bs), unit: ro(Bs), modifier: ro(Bs), operatorKeyword: ro(Bs), controlKeyword: ro(Bs), definitionKeyword: ro(Bs), operator: Gs, derefOperator: ro(Gs), arithmeticOperator: ro(Gs), logicOperator: ro(Gs), bitwiseOperator: ro(Gs), compareOperator: ro(Gs), updateOperator: ro(Gs), definitionOperator: ro(Gs), typeOperator: ro(Gs), controlOperator: ro(Gs), punctuation: ds, separator: ro(ds), bracket: eo, angleBracket: ro(eo), squareBracket: ro(eo), paren: ro(eo), brace: ro(eo), content: Qe, heading: me, heading1: ro(me), heading2: ro(me), heading3: ro(me), heading4: ro(me), heading5: ro(me), heading6: ro(me), contentSeparator: ro(Qe), list: ro(Qe), quote: ro(Qe), emphasis: ro(Qe), strong: ro(Qe), link: ro(Qe), monospace: ro(Qe), strikethrough: ro(Qe), inserted: ro(), deleted: ro(), changed: ro(), invalid: ro(), meta: Ds, documentMeta: ro(Ds), annotation: ro(Ds), processingInstruction: ro(Ds), definition: Lo.defineModifier(), constant: Lo.defineModifier(), function: Lo.defineModifier(), standard: Lo.defineModifier(), local: Lo.defineModifier(), special: Lo.defineModifier() }, Uo = Do.define([{ tag: No.link, class: "cmt-link" }, { tag: No.heading, class: "cmt-heading" }, { tag: No.emphasis, class: "cmt-emphasis" }, { tag: No.strong, class: "cmt-strong" }, { tag: No.keyword, class: "cmt-keyword" }, { tag: No.atom, class: "cmt-atom" }, { tag: No.bool, class: "cmt-bool" }, { tag: No.url, class: "cmt-url" }, { tag: No.labelName, class: "cmt-labelName" }, { tag: No.inserted, class: "cmt-inserted" }, { tag: No.deleted, class: "cmt-deleted" }, { tag: No.literal, class: "cmt-literal" }, { tag: No.string, class: "cmt-string" }, { tag: No.number, class: "cmt-number" }, { tag: [No.regexp, No.escape, No.special(No.string)], class: "cmt-string2" }, { tag: No.variableName, class: "cmt-variableName" }, { tag: No.local(No.variableName), class: "cmt-variableName cmt-local" }, { tag: No.definition(No.variableName), class: "cmt-variableName cmt-definition" }, { tag: No.special(No.variableName), class: "cmt-variableName2" }, { tag: No.typeName, class: "cmt-typeName" }, { tag: No.namespace, class: "cmt-namespace" }, { tag: No.macroName, class: "cmt-macroName" }, { tag: No.propertyName, class: "cmt-propertyName" }, { tag: No.operator, class: "cmt-operator" }, { tag: No.comment, class: "cmt-comment" }, { tag: No.meta, class: "cmt-meta" }, { tag: No.invalid, class: "cmt-invalid" }, { tag: No.punctuation, class: "cmt-punctuation" }]); class Fo { constructor(t, e, i, n, r, s, o) { this.type = t, this.value = e, this.from = i, this.hash = n, this.end = r, this.children = s, this.positions = o } static create(t, e, i, n, r) { n = n + (n << 8) + t + (e << 4) | 0; return new Fo(t, e, i, n, r, [], []) } toTree(t, e = this.end) { var i = this.children.length - 1; 0 <= i && (e = Math.max(e, this.positions[i] + this.children[i].length + this.from)); e = new wr(t.types[this.type], this.children, this.positions, e - this.from).balance(2048); return function t(e, i) { for (var n of e) Na.set(n, i), n instanceof wr && n.type.isAnonymous && t(n.children, i) }(e.children, this.hash), e } copy() { return new Fo(this.type, this.value, this.from, this.hash, this.end, this.children.slice(), this.positions.slice()) } } (Bs = Bo = Bo || {})[Bs.Document = 1] = "Document", Bs[Bs.CodeBlock = 2] = "CodeBlock", Bs[Bs.FencedCode = 3] = "FencedCode", Bs[Bs.Blockquote = 4] = "Blockquote", Bs[Bs.HorizontalRule = 5] = "HorizontalRule", Bs[Bs.BulletList = 6] = "BulletList", Bs[Bs.OrderedList = 7] = "OrderedList", Bs[Bs.ListItem = 8] = "ListItem", Bs[Bs.ATXHeading1 = 9] = "ATXHeading1", Bs[Bs.ATXHeading2 = 10] = "ATXHeading2", Bs[Bs.ATXHeading3 = 11] = "ATXHeading3", Bs[Bs.ATXHeading4 = 12] = "ATXHeading4", Bs[Bs.ATXHeading5 = 13] = "ATXHeading5", Bs[Bs.ATXHeading6 = 14] = "ATXHeading6", Bs[Bs.SetextHeading1 = 15] = "SetextHeading1", Bs[Bs.SetextHeading2 = 16] = "SetextHeading2", Bs[Bs.HTMLBlock = 17] = "HTMLBlock", Bs[Bs.LinkReference = 18] = "LinkReference", Bs[Bs.Paragraph = 19] = "Paragraph", Bs[Bs.CommentBlock = 20] = "CommentBlock", Bs[Bs.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", Bs[Bs.Escape = 22] = "Escape", Bs[Bs.Entity = 23] = "Entity", Bs[Bs.HardBreak = 24] = "HardBreak", Bs[Bs.Emphasis = 25] = "Emphasis", Bs[Bs.StrongEmphasis = 26] = "StrongEmphasis", Bs[Bs.Link = 27] = "Link", Bs[Bs.Image = 28] = "Image", Bs[Bs.InlineCode = 29] = "InlineCode", Bs[Bs.HTMLTag = 30] = "HTMLTag", Bs[Bs.Comment = 31] = "Comment", Bs[Bs.ProcessingInstruction = 32] = "ProcessingInstruction", Bs[Bs.URL = 33] = "URL", Bs[Bs.HeaderMark = 34] = "HeaderMark", Bs[Bs.QuoteMark = 35] = "QuoteMark", Bs[Bs.ListMark = 36] = "ListMark", Bs[Bs.LinkMark = 37] = "LinkMark", Bs[Bs.EmphasisMark = 38] = "EmphasisMark", Bs[Bs.CodeMark = 39] = "CodeMark", Bs[Bs.CodeInfo = 40] = "CodeInfo", Bs[Bs.LinkTitle = 41] = "LinkTitle", Bs[Bs.LinkLabel = 42] = "LinkLabel"; class Jo { constructor(t, e) { this.start = t, this.content = e, this.marks = [], this.parsers = [] } } class Ko { constructor() { this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1 } forward() { this.basePos > this.pos && this.forwardInner() } forwardInner() { var t = this.skipSpace(this.basePos); this.indent = this.countIndent(t, this.pos, this.indent), this.pos = t, this.next = t == this.text.length ? -1 : this.text.charCodeAt(t) } skipSpace(t) { return na(this.text, t) } reset(t) { for (this.text = t, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length;)this.markers.pop() } moveBase(t) { this.basePos = t, this.baseIndent = this.countIndent(t, this.pos, this.indent) } moveBaseColumn(t) { this.baseIndent = t, this.basePos = this.findColumn(t) } addMarker(t) { this.markers.push(t) } countIndent(e, i = 0, n = 0) { for (let t = i; t < e; t++)n += 9 == this.text.charCodeAt(t) ? 4 - n % 4 : 1; return n } findColumn(e) { let i = 0; for (let t = 0; i < this.text.length && t < e; i++)t += 9 == this.text.charCodeAt(i) ? 4 - t % 4 : 1; return i } scrub() { if (!this.baseIndent) return this.text; let e = ""; for (let t = 0; t < this.basePos; t++)e += " "; return e + this.text.slice(this.basePos) } } function ta(t, e, i) { if (i.pos == i.text.length || t != e.block && i.indent >= e.stack[i.depth + 1].value + i.baseIndent) return !0; if (i.indent >= i.baseIndent + 4) return !1; var n = (t.type == Bo.OrderedList ? ca : ha)(i, e, !1); return 0 < n && (t.type != Bo.BulletList || aa(i, e, !1) < 0) && i.text.charCodeAt(i.pos + n - 1) == t.value } var ea = { [Bo.Blockquote](t, e, i) { return 62 == i.next && (i.markers.push(La(Bo.QuoteMark, e.lineStart + i.pos, e.lineStart + i.pos + 1)), i.moveBase(i.pos + 1), t.end = e.lineStart + i.text.length, !0) }, [Bo.ListItem](t, e, i) { return !(i.indent < i.baseIndent + t.value && -1 < i.next) && (i.moveBaseColumn(i.baseIndent + t.value), !0) }, [Bo.OrderedList]: ta, [Bo.BulletList]: ta, [Bo.Document]() { return !0 } }; function ia(t) { return 32 == t || 9 == t || 10 == t || 13 == t } function na(t, e = 0) { for (; e < t.length && ia(t.charCodeAt(e));)e++; return e } function ra(t, e, i) { for (; i < e && ia(t.charCodeAt(e - 1));)e--; return e } function sa(e) { if (96 != e.next && 126 != e.next) return -1; let i = e.pos + 1; for (; i < e.text.length && e.text.charCodeAt(i) == e.next;)i++; if (i < e.pos + 3) return -1; if (96 == e.next) for (let t = i; t < e.text.length; t++)if (96 == e.text.charCodeAt(t)) return -1; return i } function oa(t) { return 62 != t.next ? -1 : 32 == t.text.charCodeAt(t.pos + 1) ? 2 : 1 } function aa(e, t, i) { if (42 != e.next && 45 != e.next && 95 != e.next) return -1; let n = 1; for (let t = e.pos + 1; t < e.text.length; t++) { var r = e.text.charCodeAt(t); if (r == e.next) n++; else if (!ia(r)) return -1 } return i && 45 == e.next && -1 < da(e) && e.depth == t.stack.length || n < 3 ? -1 : 1 } function la(t, e) { return t.block.type == e || 1 < t.stack.length && t.stack[t.stack.length - 2].type == e } function ha(t, e, i) { return 45 != t.next && 43 != t.next && 42 != t.next || t.pos != t.text.length - 1 && !ia(t.text.charCodeAt(t.pos + 1)) || !(!i || la(e, Bo.BulletList) || t.skipSpace(t.pos + 2) < t.text.length) ? -1 : 1 } function ca(t, e, i) { let n = t.pos, r = t.next; for (; 48 <= r && r <= 57;) { if (n++, n == t.text.length) return -1; r = t.text.charCodeAt(n) } return n == t.pos || n > t.pos + 9 || 46 != r && 41 != r || n < t.text.length - 1 && !ia(t.text.charCodeAt(n + 1)) || i && !la(e, Bo.OrderedList) && (t.skipSpace(n + 1) == t.text.length || n > t.pos + 1 || 49 != t.next) ? -1 : n + 1 - t.pos } function Oa(t) { if (35 != t.next) return -1; let e = t.pos + 1; for (; e < t.text.length && 35 == t.text.charCodeAt(e);)e++; if (e < t.text.length && 32 != t.text.charCodeAt(e)) return -1; var i = e - t.pos; return 6 < i ? -1 : i } function da(t) { if (45 != t.next && 61 != t.next || t.indent >= t.baseIndent + 4) return -1; let e = t.pos + 1; for (; e < t.text.length && t.text.charCodeAt(e) == t.next;)e++; for (var i = e; e < t.text.length && ia(t.text.charCodeAt(e));)e++; return e == t.text.length ? i : -1 } const ua = /^[ \t]*$/, fa = /-->/, pa = /\?>/, ma = [[/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i], [/^\s*<!--/, fa], [/^\s*<\?/, pa], [/^\s*<![A-Z]/, />/], [/^\s*<!\[CDATA\[/, /\]\]>/], [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, ua], [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, ua]]; function ga(t, e, i) { if (60 != t.next) return -1; var n = t.text.slice(t.pos); for (let t = 0, e = ma.length - (i ? 1 : 0); t < e; t++)if (ma[t][0].test(n)) return t; return -1 } function Qa(t, e) { var i = t.countIndent(e, t.pos, t.indent), e = t.countIndent(t.skipSpace(e), e, i); return i + 5 <= e ? i + 1 : e } const va = { LinkReference: void 0, IndentedCode(e, t) { var i = t.baseIndent + 4; if (t.indent < i) return !1; var n = t.findColumn(i); let r = e.lineStart + n, s = e.lineStart + t.text.length, o = [], a = []; for (; e.nextLine() && !(t.depth < e.stack.length);)if (t.pos == t.text.length) for (var l of t.markers) a.push(l); else { if (t.indent < i) break; if (a.length) { for (var h of a) o.push(h); a = [] } for (var c of t.markers) o.push(c); s = e.lineStart + t.text.length } a.length && (t.markers = a.concat(t.markers)); let O = !o.length && e.parser.codeParser && e.parser.codeParser(""); return O ? e.startNested(r, O.startParse(e.input.clip(s), r, e.parseContext), t => new wr(e.parser.nodeSet.types[Bo.CodeBlock], [t], [0], s - r)) : e.addNode(e.buffer.writeElements(o, -r).finish(Bo.CodeBlock, s - r), r), !0 }, FencedCode(e, i) { var t = sa(i); if (t < 0) return !1; let n = e.lineStart + i.pos, r = i.next, s = t - i.pos; var o = i.skipSpace(t), t = ra(i.text, i.text.length, o); let a = [La(Bo.CodeMark, n, n + s)], l = ""; o < t && (a.push(La(Bo.CodeInfo, e.lineStart + o, e.lineStart + t)), l = i.text.slice(o, t)); let h = a.length, c = h, O = e.lineStart + i.text.length + 1, d = -1; for (; e.nextLine() && !(i.depth < e.stack.length);) { for (var u of i.markers) a.push(u); let t = i.pos; if (i.indent - i.baseIndent < 4) for (; t < i.text.length && i.text.charCodeAt(t) == r;)t++; if (t - i.pos >= s && i.skipSpace(t) == i.text.length) { a.push(La(Bo.CodeMark, e.lineStart + i.pos, e.lineStart + t)), h++, d = e.lineStart - 1, e.nextLine(); break } } let f = e.prevLineEnd(); d < 0 && (d = f); let p = a.length == h && e.parser.codeParser && e.parser.codeParser(l); return p && O < d ? e.startNested(n, p.startParse(e.input.clip(d), O, e.parseContext), t => (a.splice(c, 0, new Aa(t, O)), La(Bo.FencedCode, n, f, a))) : e.addNode(e.buffer.writeElements(a, -n).finish(Bo.FencedCode, e.prevLineEnd() - n), n), !0 }, Blockquote(t, e) { var i = oa(e); return !(i < 0) && (t.startContext(Bo.Blockquote, e.pos), t.addNode(Bo.QuoteMark, t.lineStart + e.pos, t.lineStart + e.pos + 1), e.moveBase(e.pos + i), null) }, HorizontalRule(t, e) { if (aa(e, t, !1) < 0) return !1; e = t.lineStart + e.pos; return t.nextLine(), t.addNode(Bo.HorizontalRule, e), !0 }, BulletList(t, e) { var i = ha(e, t, !1); if (i < 0) return !1; t.block.type != Bo.BulletList && t.startContext(Bo.BulletList, e.basePos, e.next); var n = Qa(e, e.pos + 1); return t.startContext(Bo.ListItem, e.basePos, n - e.baseIndent), t.addNode(Bo.ListMark, t.lineStart + e.pos, t.lineStart + e.pos + i), e.moveBaseColumn(n), null }, OrderedList(t, e) { var i = ca(e, t, !1); if (i < 0) return !1; t.block.type != Bo.OrderedList && t.startContext(Bo.OrderedList, e.basePos, e.text.charCodeAt(e.pos + i - 1)); var n = Qa(e, e.pos + i); return t.startContext(Bo.ListItem, e.basePos, n - e.baseIndent), t.addNode(Bo.ListMark, t.lineStart + e.pos, t.lineStart + e.pos + i), e.moveBaseColumn(n), null }, ATXHeading(t, e) { var i = Oa(e); if (i < 0) return !1; var n = e.pos, r = t.lineStart + n; let s = ra(e.text, e.text.length, n), o = s; for (; o > n && e.text.charCodeAt(o - 1) == e.next;)o--; o != s && o != n && ia(e.text.charCodeAt(o - 1)) || (o = e.text.length); let a = t.buffer.write(Bo.HeaderMark, 0, i).writeElements(t.parser.parseInline(e.text.slice(n + i + 1, o), r + i + 1), -r); o < e.text.length && a.write(Bo.HeaderMark, o - n, s - n); i = a.finish(Bo.ATXHeading1 - 1 + i, e.text.length - n); return t.nextLine(), t.addNode(i, r), !0 }, HTMLBlock(e, t) { var i = ga(t, 0, !1); if (i < 0) return !1; let n = e.lineStart + t.pos, r = ma[i][1], s = [], o = r != ua; for (; !r.test(t.text) && e.nextLine();) { if (t.depth < e.stack.length) { o = !1; break } for (var a of t.markers) s.push(a) } o && e.nextLine(); let l = r == fa ? Bo.CommentBlock : r == pa ? Bo.ProcessingInstructionBlock : Bo.HTMLBlock, h = e.prevLineEnd(); return !s.length && l == Bo.HTMLBlock && e.parser.htmlParser ? e.startNested(n, e.parser.htmlParser.startParse(e.input.clip(h), n, e.parseContext), t => new wr(e.parser.nodeSet.types[l], [t], [0], h - n)) : e.addNode(e.buffer.writeElements(s, -n).finish(l, h - n), n), !0 }, SetextHeading: void 0 }; class wa { constructor(t) { this.stage = 0, this.elts = [], this.pos = 0, this.start = t.start, this.advance(t.content) } nextLine(t, e, i) { if (-1 == this.stage) return !1; var n = i.content + "\n" + e.scrub(), e = this.advance(n); return -1 < e && e < n.length && this.complete(t, i, e) } finish(t, e) { return (2 == this.stage || 3 == this.stage) && na(e.content, this.pos) == e.content.length && this.complete(t, e, e.content.length) } complete(t, e, i) { return t.addLeafElement(e, La(Bo.LinkReference, this.start, this.start + i, this.elts)), !0 } nextStage(t) { return t ? (this.pos = t.to - this.start, this.elts.push(t), this.stage++, !0) : (!1 === t && (this.stage = -1), !1) } advance(i) { for (; ;) { if (-1 == this.stage) return -1; if (0 == this.stage) { if (!this.nextStage(Ia(i, this.pos, this.start, !0))) return -1; if (58 != i.charCodeAt(this.pos)) return this.stage = -1; this.elts.push(La(Bo.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++ } else { if (1 != this.stage) { if (2 != this.stage) return $a(i, this.pos); { let t = na(i, this.pos), e = 0; var n, r; return t > this.pos && (!(n = Ha(i, t, this.start)) || 0 < (r = $a(i, n.to - this.start)) && (this.nextStage(n), e = r)), e = e || $a(i, this.pos), 0 < e && e < i.length ? e : -1 } } if (!this.nextStage(Da(i, na(i, this.pos), this.start))) return -1 } } } } function $a(t, e) { for (; e < t.length; e++) { var i = t.charCodeAt(e); if (10 == i) break; if (!ia(i)) return -1 } return e } class ya { nextLine(t, e, i) { var n = e.depth < t.stack.length ? -1 : da(e), r = e.next; if (n < 0) return !1; n = La(Bo.HeaderMark, t.lineStart + e.pos, t.lineStart + n); return t.nextLine(), t.addLeafElement(i, La(61 == r ? Bo.SetextHeading1 : Bo.SetextHeading2, i.start, t.prevLineEnd(), [...t.parser.parseInline(i.content, i.start), n])), !0 } finish() { return !1 } } const ba = { LinkReference(t, e) { return 91 == e.content.charCodeAt(0) ? new wa(e) : null }, SetextHeading() { return new ya } }; Gs = [(t, e) => 0 <= Oa(e), (t, e) => 0 <= sa(e), (t, e) => 0 <= oa(e), (t, e) => 0 <= ha(e, t, !0), (t, e) => 0 <= ca(e, t, !0), (t, e) => 0 <= aa(e, t, !0), (t, e) => 0 <= ga(e, 0, !0)]; class xa { constructor(t, e, i) { this.from = t, this.parse = e, this.finish = i } } class ka { constructor(t, e, i, n) { this.parser = t, this.input = e, this.parseContext = n, this.line = new Ko, this.atEnd = !1, this.nested = null, this.lineStart = i, this.block = Fo.create(Bo.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = null != n && n.fragments ? new Fa(n.fragments, e) : null, this.updateLine(e.lineAfter(this.lineStart)) } get pos() { return this.nested ? this.nested.parse.pos : this.lineStart } advance() { if (this.nested) { var e = this.nested.parse.advance(); if (e) { let t = this.nested.finish(e); t instanceof Ca && (t = t.toTree(this.parser.nodeSet)), this.addNode(t, this.nested.from), this.nested = null } return null } let { line: t } = this; for (; ;) { for (; t.depth < this.stack.length;)this.finishContext(); for (var i of t.markers) this.addNode(i.type, i.from, i.to); if (t.pos < t.text.length) break; if (!this.nextLine()) return this.finish() } if (this.fragments && this.reuseFragment(t.basePos)) return null; t: for (; ;) { for (var n of this.parser.blockParsers) if (n) { n = n(this, t); if (0 != n) { if (1 == n) return null; t.forward(); continue t } } break } let r = new Jo(this.lineStart + t.pos, t.text.slice(t.pos)); for (var s of this.parser.leafBlockParsers) !s || (s = s(this, r)) && r.parsers.push(s); t: for (; this.nextLine() && t.pos != t.text.length;) { if (t.indent < t.baseIndent + 4) for (var o of Ja.endLeafBlock) if (o(this, t)) break t; for (var a of r.parsers) if (a.nextLine(this, t, r)) return null; r.content += "\n" + t.scrub(); for (var l of t.markers) r.marks.push(l) } return this.finishLeaf(r), null } reuseFragment(t) { if (!this.fragments.moveTo(this.lineStart + t, this.lineStart) || !this.fragments.matches(this.block.hash)) return !1; t = this.fragments.takeNodes(this); return !!t && (this.lineStart += t, this.lineStart < this.input.length ? (this.lineStart++, this.updateLine(this.input.lineAfter(this.lineStart))) : (this.atEnd = !0, this.updateLine("")), !0) } nextLine() { return this.lineStart += this.line.text.length, this.lineStart >= this.input.length ? (this.atEnd = !0, this.updateLine(""), !1) : (this.lineStart++, this.updateLine(this.input.lineAfter(this.lineStart)), !0) } updateLine(t) { let { line: i } = this; for (i.reset(t); i.depth < this.stack.length; i.depth++) { let t = this.stack[i.depth], e = this.parser.skipContextMarkup[t.type]; if (!e) throw new Error("Unhandled block context " + Bo[t.type]); if (!e(t, this, i)) break; i.forward() } } prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1 } startContext(t, e, i = 0) { this.block = Fo.create(t, i, this.lineStart + e, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block) } startComposite(t, e, i = 0) { this.startContext(this.parser.getNodeType(t), e, i) } addNode(t, e, i) { "number" == typeof t && (t = new wr(this.parser.nodeSet.types[t], Ra, Ra, (null != i ? i : this.prevLineEnd()) - e)), this.block.children.push(t), this.block.positions.push(e - this.block.from) } addElement(t) { this.block.children.push(t.toTree(this.parser.nodeSet)), this.block.positions.push(t.from - this.block.from) } addLeafElement(t, e) { this.addNode(this.buffer.writeElements(Ba(e.children, t.marks), -e.from).finish(e.type, e.to - e.from), e.from) } startNested(t, e, i) { this.nested = new xa(t, e, i) } finishContext() { this.block = Xa(this.stack, this.parser.nodeSet) } finish() { for (; 1 < this.stack.length;)this.finishContext(); return this.block.toTree(this.parser.nodeSet, this.lineStart) } forceFinish() { let e = this.stack.map(t => t.copy()), r = this.lineStart; if (this.nested) { let t = e[e.length - 1], i = this.nested.finish(this.nested.parse.forceFinish()); i instanceof Ca && (i = i.toTree(this.parser.nodeSet)); let n = r - this.nested.from; i.length > n && (i = new wr(i.type, i.children.filter((t, e) => i.positions[e] <= n), i.positions.filter(t => t <= n), n)), t.children.push(i), t.positions.push(this.nested.from) } for (; 1 < e.length;)Xa(e, this.parser.nodeSet); return e[0].toTree(this.parser.nodeSet, r) } finishLeaf(t) { for (var e of t.parsers) if (e.finish(this, t)) return; var i = Ba(this.parser.parseInline(t.content, t.start), t.marks); this.addNode(this.buffer.writeElements(i, -t.start).finish(Bo.Paragraph, t.content.length), t.start) } elt(t, e, i, n) { return "string" == typeof t ? La(this.parser.getNodeType(t), e, i, n) : new Aa(t, e) } get buffer() { return new _a(this.parser.nodeSet) } } class Sa { constructor(t, e, i, n, r, s, o, a, l, h) { this.nodeSet = t, this.codeParser = e, this.htmlParser = i, this.blockParsers = n, this.leafBlockParsers = r, this.blockNames = s, this.endLeafBlock = o, this.skipContextMarkup = a, this.inlineParsers = l, this.inlineNames = h, this.nodeTypes = Object.create(null); for (var c of t.types) this.nodeTypes[c.name] = c.id } startParse(t, e = 0, i = {}) { return new ka(this, t, e, i) } configure(t) { var r, t = function t(e) { if (!Array.isArray(e)) return e; if (0 == e.length) return null; let i = t(e[0]); if (1 == e.length) return i; let n = t(e.slice(1)); if (!n || !i) return i || n; let r = (t, e) => (t || Ra).concat(e || Ra); return { props: r(i.props, n.props), codeParser: n.codeParser || i.codeParser, htmlParser: n.htmlParser || i.htmlParser, defineNodes: r(i.defineNodes, n.defineNodes), parseBlock: r(i.parseBlock, n.parseBlock), parseInline: r(i.parseInline, n.parseInline), remove: r(i.remove, n.remove) } }(t); if (!t) return this; let { nodeSet: e, skipContextMarkup: s } = this, i = this.blockParsers.slice(), n = this.leafBlockParsers.slice(), o = this.blockNames.slice(), a = this.inlineParsers.slice(), l = this.inlineNames.slice(), h = this.endLeafBlock.slice(); if (Pa(t.defineNodes)) { s = Object.assign({}, s); let i = e.types.slice(); for (var c of t.defineNodes) { let { name: e, block: t, composite: n } = "string" == typeof c ? { name: c } : c; i.some(t => t.name == e) || (n && (s[i.length] = (t, e, i) => n(e, i, t.value)), r = i.length, c = n ? ["Block", "BlockContext"] : t ? r >= Bo.ATXHeading1 && r <= Bo.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0, i.push(Qr.define({ id: r, name: e, props: c && [[mr.group, c]] }))) } e = new vr(i) } if (Pa(t.props) && (e = e.extend(...t.props)), Pa(t.remove)) for (var O of t.remove) { var d = this.blockNames.indexOf(O), O = this.inlineNames.indexOf(O); -1 < d && (i[d] = n[d] = void 0), -1 < O && (a[O] = void 0) } if (Pa(t.parseBlock)) for (var u of t.parseBlock) { var f = o.indexOf(u.name); -1 < f ? (i[f] = u.parse, n[f] = u.leaf) : (f = u.before ? Ta(o, u.before) : u.after ? Ta(o, u.after) + 1 : o.length - 1, i.splice(f, 0, u.parse), n.splice(f, 0, u.leaf), o.splice(f, 0, u.name)), u.endLeaf && h.push(u.endLeaf) } if (Pa(t.parseInline)) for (var p of t.parseInline) { var m = l.indexOf(p.name); -1 < m ? a[m] = p.parse : (m = p.before ? Ta(l, p.before) : p.after ? Ta(l, p.after) + 1 : l.length - 1, a.splice(m, 0, p.parse), l.splice(m, 0, p.name)) } return new Sa(e, t.codeParser || this.codeParser, t.htmlParser || this.htmlParser, i, n, o, h, s, a, l) } getNodeType(t) { var e = this.nodeTypes[t]; if (null == e) throw new RangeError(`Unknown node type '${t}'`); return e } parseInline(t, e) { let i = new Ga(this, t, e); t: for (let t = e; t < i.end;) { var n, r = i.char(t); for (n of this.inlineParsers) if (n) { var s = n(i, r, t); if (0 <= s) { t = s; continue t } } t++ } return i.resolveMarkers(0) } } function Pa(t) { return null != t && 0 < t.length } function Ta(t, e) { t = t.indexOf(e); if (t < 0) throw new RangeError(`Position specified relative to unknown parser ${e}`); return t } let Wa = [Qr.none]; for (let t = 1, e; e = Bo[t]; t++)Wa[t] = Qr.define({ id: t, name: e, props: t >= Bo.Escape ? [] : [[mr.group, t in ea ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]] }); function Xa(t, e) { let i = t.pop(), n = t[t.length - 1]; return n.children.push(i.toTree(e)), n.positions.push(i.from - n.from), n } const Ra = []; class _a { constructor(t) { this.nodeSet = t, this.content = [], this.nodes = [] } write(t, e, i, n = 0) { return this.content.push(t, e, i, 4 + 4 * n), this } writeElements(t, e = 0) { for (var i of t) i.writeTo(this, e); return this } finish(t, e) { return wr.build({ buffer: this.content, nodeSet: this.nodeSet, reused: this.nodes, topID: t, length: e }) } } class Ca { constructor(t, e, i, n = Ra) { this.type = t, this.from = e, this.to = i, this.children = n } writeTo(t, e) { var i = t.content.length; t.writeElements(this.children, e), t.content.push(this.type, this.from + e, this.to + e, t.content.length + 4 - i) } toTree(t) { return new _a(t).writeElements(this.children, -this.from).finish(this.type, this.to - this.from) } } class Aa { constructor(t, e) { this.tree = t, this.from = e } get to() { return this.from + this.tree.length } get type() { return this.tree.type.id } get children() { return Ra } writeTo(t, e) { t.nodes.push(this.tree), t.content.push(t.nodes.length - 1, this.from + e, this.to + e, -1) } toTree() { return this.tree } } function La(t, e, i, n) { return new Ca(t, e, i, n) } const za = { resolve: "Emphasis", mark: "EmphasisMark" }, qa = { resolve: "Emphasis", mark: "EmphasisMark" }, Va = {}, Ya = {}; class Ma { constructor(t, e, i, n) { this.type = t, this.from = e, this.to = i, this.side = n } } const Za = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"; let Ea = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/; try { Ea = /[\p{Pc}|\p{Pd}|\p{Pe}|\p{Pf}|\p{Pi}|\p{Po}|\p{Ps}]/u } catch (t) { } const ja = { Escape(e, t, i) { if (92 != t || i == e.end - 1) return -1; var n = e.char(i + 1); for (let t = 0; t < Za.length; t++)if (Za.charCodeAt(t) == n) return e.append(La(Bo.Escape, i, i + 2)); return -1 }, Entity(t, e, i) { if (38 != e) return -1; e = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(t.slice(i + 1, i + 31)); return e ? t.append(La(Bo.Entity, i, i + 1 + e[0].length)) : -1 }, InlineCode(t, e, i) { if (96 != e || i && 96 == t.char(i - 1)) return -1; let n = i + 1; for (; n < t.end && 96 == t.char(n);)n++; let r = n - i, s = 0; for (; n < t.end; n++)if (96 == t.char(n)) { if (s++, s == r && 96 != t.char(n + 1)) return t.append(La(Bo.InlineCode, i, n + 1, [La(Bo.CodeMark, i, i + r), La(Bo.CodeMark, n + 1 - r, n + 1)])) } else s = 0; return -1 }, HTMLTag(e, t, n) { if (60 != t || n == e.end - 1) return -1; var r = e.slice(n + 1, e.end), t = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(r); if (t) return e.append(La(Bo.URL, n, n + 1 + t[0].length)); t = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(r); if (t) return e.append(La(Bo.Comment, n, n + 1 + t[0].length)); t = /^\?[^]*?\?>/.exec(r); if (t) return e.append(La(Bo.ProcessingInstruction, n, n + 1 + t[0].length)); r = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(r); if (!r) return -1; let s = []; if (e.parser.htmlParser) { let t = e.parser.htmlParser.startParse(Cr(e.slice(n, n + 1 + r[0].length)), 0, {}), i; for (; !(i = t.advance());); s = i.children.map((t, e) => new Aa(t, n + i.positions[e])) } return e.append(La(Bo.HTMLTag, n, n + 1 + r[0].length, s)) }, Emphasis(t, e, i) { if (95 != e && 42 != e) return -1; let n = i + 1; for (; t.char(n) == e;)n++; var r = t.slice(i - 1, i), s = t.slice(n, n + 1), o = Ea.test(r), a = Ea.test(s), l = /\s|^$/.test(r), r = /\s|^$/.test(s), s = !r && (!a || l || o), r = !l && (!o || r || a), o = s && (42 == e || !r || o), a = r && (42 == e || !s || a); return t.append(new Ma(95 == e ? za : qa, i, n, (o ? 1 : 0) | (a ? 2 : 0))) }, HardBreak(e, t, i) { if (92 == t && 10 == e.char(i + 1)) return e.append(La(Bo.HardBreak, i, i + 2)); if (32 == t) { let t = i + 1; for (; 32 == e.char(t);)t++; if (10 == e.char(t) && t >= i + 2) return e.append(La(Bo.HardBreak, i, t + 1)) } return -1 }, Link(t, e, i) { return 91 == e ? t.append(new Ma(Va, i, i + 1, 1)) : -1 }, Image(t, e, i) { return 33 == e && 91 == t.char(i + 1) ? t.append(new Ma(Ya, i, i + 2, 1)) : -1 }, LinkEnd(i, t, e) { if (93 != t) return -1; for (let t = i.parts.length - 1; 0 <= t; t--) { var n = i.parts[t]; if (n instanceof Ma && (n.type == Va || n.type == Ya)) { if (!n.side || i.skipSpace(n.to) == e && !/[(\[]/.test(i.slice(e + 1, e + 2))) return i.parts[t] = null, -1; var r = i.takeContent(t), r = i.parts[t] = function (n, r, t, e, s) { let { text: o } = n, i = n.char(s), a = s; if (r.unshift(La(Bo.LinkMark, e, e + (t == Bo.Image ? 2 : 1))), r.push(La(Bo.LinkMark, s - 1, s)), 40 == i) { let t = n.skipSpace(s + 1), e = Da(o, t - n.offset, n.offset), i; e && (t = n.skipSpace(e.to), i = Ha(o, t - n.offset, n.offset), i && (t = n.skipSpace(i.to))), 41 == n.char(t) && (r.push(La(Bo.LinkMark, s, s + 1)), a = t + 1, e && r.push(e), i && r.push(i), r.push(La(Bo.LinkMark, t, a))) } else 91 != i || (n = Ia(o, s - n.offset, n.offset, !1)) && (r.push(n), a = n.to); return La(t, e, a, r) }(i, r, n.type == Va ? Bo.Link : Bo.Image, n.from, e + 1); if (n.type == Va) for (let e = 0; e < t; e++) { let t = i.parts[e]; t instanceof Ma && t.type == Va && (t.side = 0) } return r.to } } return -1 } }; function Da(n, r, s) { if (60 == n.charCodeAt(r)) { for (let t = r + 1; t < n.length; t++) { var e = n.charCodeAt(t); if (62 == e) return La(Bo.URL, r + s, t + 1 + s); if (60 == e || 10 == e) return !1 } return null } { let e = 0, i = r; for (let t = !1; i < n.length; i++) { var o = n.charCodeAt(i); if (ia(o)) break; if (t) t = !1; else if (40 == o) e++; else if (41 == o) { if (!e) break; e-- } else 92 == o && (t = !0) } return i > r ? La(Bo.URL, r + s, i + s) : i == n.length && null } } function Ha(i, n, r) { var t = i.charCodeAt(n); if (39 != t && 34 != t && 40 != t) return !1; var s = 40 == t ? 41 : t; for (let t = n + 1, e = !1; t < i.length; t++) { var o = i.charCodeAt(t); if (e) e = !1; else { if (o == s) return La(Bo.LinkTitle, n + r, t + 1 + r); 92 == o && (e = !0) } } return null } function Ia(n, r, s, o) { for (let t = !1, e = r + 1, i = Math.min(n.length, e + 999); e < i; e++) { var a = n.charCodeAt(e); if (t) t = !1; else { if (93 == a) return !o && La(Bo.LinkLabel, r + s, e + 1 + s); if (o && !ia(a) && (o = !1), 91 == a) return !1; 92 == a && (t = !0) } } return null } class Ga { constructor(t, e, i) { this.parser = t, this.text = e, this.offset = i, this.parts = [] } char(t) { return t >= this.end ? -1 : this.text.charCodeAt(t - this.offset) } get end() { return this.offset + this.text.length } slice(t, e) { return this.text.slice(t - this.offset, e - this.offset) } append(t) { return this.parts.push(t), t.to } addDelimiter(t, e, i, n, r) { return this.append(new Ma(t, e, i, (n ? 1 : 0) | (r ? 2 : 0))) } addElement(t) { return this.append(t) } resolveMarkers(e) { for (let o = e; o < this.parts.length; o++) { var a = this.parts[o]; if (a instanceof Ma && a.type.resolve && 2 & a.side) { var l = a.type == za || a.type == qa, h = a.to - a.from; let r, s = o - 1; for (; s >= e; s--) { var t = this.parts[s]; if (t instanceof Ma && 1 & t.side && t.type == a.type && !(l && (1 & a.side || 2 & t.side) && (t.to - t.from + h) % 3 == 0 && ((t.to - t.from) % 3 || h % 3))) { r = t; break } } if (r) { let t = a.type.resolve, e = [], i = r.from, n = a.to; l && (c = Math.min(2, r.to - r.from, h), i = r.to - c, n = a.from + c, t = 1 == c ? "Emphasis" : "StrongEmphasis"), r.type.mark && e.push(this.elt(r.type.mark, i, r.to)); for (let t = s + 1; t < o; t++)this.parts[t] instanceof Ca && e.push(this.parts[t]), this.parts[t] = null; a.type.mark && e.push(this.elt(a.type.mark, a.from, n)); var c = this.elt(t, i, n, e); this.parts[s] = l && r.from != i ? new Ma(r.type, r.from, i, r.side) : null, (this.parts[o] = l && a.to != n ? new Ma(a.type, n, a.to, a.side) : null) ? this.parts.splice(o, 0, c) : this.parts[o] = c } } } let i = []; for (let t = e; t < this.parts.length; t++) { var n = this.parts[t]; n instanceof Ca && i.push(n) } return i } findOpeningDelimiter(e) { for (let t = this.parts.length - 1; 0 <= t; t--) { var i = this.parts[t]; if (i instanceof Ma && i.type == e) return t } return null } takeContent(t) { var e = this.resolveMarkers(t); return this.parts.length = t, e } skipSpace(t) { return na(this.text, t - this.offset) + this.offset } elt(t, e, i, n) { return "string" == typeof t ? La(this.parser.getNodeType(t), e, i, n) : new Aa(t, e) } } function Ba(t, e) { if (!e.length) return t; if (!t.length) return e; let i = t.slice(), n = 0; for (var r of e) { for (; n < i.length && i[n].to < r.to;)n++; var s; n < i.length && i[n].from < r.from ? (s = i[n]) instanceof Ca && (i[n] = new Ca(s.type, s.from, s.to, Ba(s.children, [r]))) : i.splice(n++, 0, r) } return i } const Na = new WeakMap; const Ua = [Bo.CodeBlock, Bo.ListItem, Bo.OrderedList, Bo.BulletList]; class Fa { constructor(t, e) { this.fragments = t, this.input = e, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, t.length && (this.fragment = t[this.i++]) } nextFragment() { this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1 } moveTo(t, e) { for (; this.fragment && this.fragment.to <= t;)this.nextFragment(); if (!this.fragment || this.fragment.from > (t ? t - 1 : 0)) return !1; if (this.fragmentEnd < 0) { let t = this.fragment.to; for (; 0 < t && 10 != this.input.get(t - 1);)t--; this.fragmentEnd = t ? t - 1 : 0 } let i = this.cursor; i || (i = this.cursor = this.fragment.tree.cursor(), i.firstChild()); for (var n = t + this.fragment.offset; i.to <= n;)if (!i.parent()) return !1; for (; ;) { if (i.from >= n) return this.fragment.from <= e; if (!i.childAfter(n)) return !1 } } matches(t) { var e = this.cursor.tree; return e && Na.get(e) == t } takeNodes(t) { let e = this.cursor, i = this.fragment.offset, n = t.lineStart, r = n, s = t.block.children.length, o = r, a = s; for (; ;) { if (e.to - i >= this.fragmentEnd) { if (e.type.isAnonymous && e.firstChild()) continue; break } if (t.addNode(e.tree, e.from - i), e.type.is("Block") && (Ua.indexOf(e.type.id) < 0 ? (r = e.to - i, s = t.block.children.length) : (r = o, s = a, o = e.to - i, a = t.block.children.length)), !e.nextSibling()) break } for (; t.block.children.length > s;)t.block.children.pop(), t.block.positions.pop(); return r - n } } const Ja = new Sa(new vr(Wa), null, null, Object.keys(va).map(t => va[t]), Object.keys(va).map(t => ba[t]), Object.keys(va), Gs, ea, Object.keys(ja).map(t => ja[t]), Object.keys(ja)), Ka = { resolve: "Strikethrough", mark: "StrikethroughMark" }; function tl(e, i, n = 0, r, s = 0) { let o = 0, a = !0, l = -1, h = -1, c = !1; var O = () => { r.push(e.elt("TableCell", s + l, s + h, e.parser.parseInline(i.slice(l, h), s + l))) }; for (let t = n; t < i.length; t++) { var d = i.charCodeAt(t); 124 != d || c ? (c || 32 != d && 9 != d) && (l < 0 && (l = t), h = t + 1) : ((!a || -1 < l) && o++, a = !1, r && (-1 < l && O(), r.push(e.elt("TableDelimiter", t + s, t + s + 1))), l = h = -1), c = !c && 92 == d } return -1 < l && (o++, r && O()), o } class el { constructor() { this.rows = null } nextLine(e, i, n) { if (null == this.rows) { this.rows = !1; let t; 45 != i.next && 58 != i.next && 124 != i.next || !/^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/.test(t = i.text.slice(i.pos)) || tl(e, n.content, 0, r = [], n.start) == tl(e, t, i.pos) && (this.rows = [e.elt("TableHeader", n.start, n.start + n.content.length, r), e.elt("TableDelimiter", e.lineStart + i.pos, e.lineStart + i.text.length)]) } else { var r; this.rows && (tl(e, i.text, i.pos, r = [], e.lineStart), this.rows.push(e.elt("TableRow", e.lineStart + i.pos, e.lineStart + i.text.length, r))) } return !1 } finish(t, e) { return !!this.rows && (this.emit(t, e), !0) } emit(t, e) { t.addLeafElement(e, t.elt("Table", e.start, e.start + e.content.length, this.rows)) } } class il { nextLine() { return !1 } finish(t, e) { return t.addLeafElement(e, t.elt("Task", e.start, e.start + e.content.length, [t.elt("TaskMarker", e.start, e.start + 3), ...t.parser.parseInline(e.content.slice(3), e.start + 3)])), !0 } } ds = [{ defineNodes: [{ name: "Table", block: !0 }, "TableHeader", "TableRow", "TableCell", "TableDelimiter"], parseBlock: [{ name: "Table", leaf(t, e) { return function (e, i) { for (let t = i; t < e.length; t++) { var n = e.charCodeAt(t); if (124 == n) return 1; 92 == n && t++ } }(e.content, 0) ? new el : null }, before: "SetextHeading" }] }, { defineNodes: [{ name: "Task", block: !0 }, "TaskMarker"], parseBlock: [{ name: "TaskList", leaf(t, e) { return /^\[[ xX]\]/.test(e.content) && "ListItem" == t.parser.nodeSet.types[t.block.type].name ? new il : null }, after: "SetextHeading" }] }, { defineNodes: ["Strikethrough", "StrikethroughMark"], parseInline: [{ name: "Strikethrough", parse(t, e, i) { return 126 != e || 126 != t.char(i + 1) ? -1 : t.addDelimiter(Ka, i, i + 2, !0, !0) }, after: "Emphasis" }] }]; function nl(s, o, a) { return (e, t, i) => { if (t != s || e.char(i + 1) == s) return -1; let n = [e.elt(a, i, i + 1)]; for (let t = i + 1; t < e.end; t++) { var r = e.char(t); if (r == s) return e.addElement(e.elt(o, i, t + 1, n.concat(e.elt(a, t, t + 1)))); if (92 == r && n.push(e.elt("Escape", t, 2 + t++)), ia(r)) break } return -1 } } eo = { defineNodes: ["Superscript", "SuperscriptMark"], parseInline: [{ name: "Superscript", parse: nl(94, "Superscript", "SuperscriptMark") }] }, me = { defineNodes: ["Subscript", "SubscriptMark"], parseInline: [{ name: "Subscript", parse: nl(126, "Subscript", "SubscriptMark") }] }; class rl { constructor(t, e, i, n, r, s, o, a, l, h) { this.p = t, this.stack = e, this.state = i, this.reducePos = n, this.pos = r, this.score = s, this.buffer = o, this.bufferBase = a, this.curContext = l, this.parent = h } toString() { return `[${this.stack.filter((t, e) => e % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}` } static start(t, e, i = 0) { var n = t.parser.context; return new rl(t, [], e, i, i, 0, [], 0, n ? new sl(n, n.start) : null, null) } get context() { return this.curContext ? this.curContext.context : null } pushState(t, e) { this.stack.push(this.state, e, this.bufferBase + this.buffer.length), this.state = t } reduce(t) { var e = t >> 19, i = 65535 & t; let { parser: n } = this.p; var r = n.dynamicPrecedence(i); if (r && (this.score += r), 0 == e) return i < n.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0), this.pushState(n.getGoto(this.state, i, !0), this.reducePos), void this.reduceContext(i); var s = this.stack.length - 3 * (e - 1) - (262144 & t ? 6 : 0), o = this.stack[s - 2], r = this.stack[s - 1], e = this.bufferBase + this.buffer.length - r; for ((i < n.minRepeatTerm || 131072 & t) && (r = n.stateFlag(this.state, 1) ? this.pos : this.reducePos, this.storeNode(i, o, r, 4 + e, !0)), 262144 & t ? this.state = this.stack[s] : (t = this.stack[s - 3], this.state = n.getGoto(t, i, !0)); this.stack.length > s;)this.stack.pop(); this.reduceContext(i) } storeNode(e, i, n, r = 4, t = !1) { if (0 == e) { let t = this, e = this.buffer.length; if (0 == e && t.parent && (e = t.bufferBase - t.parent.bufferBase, t = t.parent), 0 < e && 0 == t.buffer[e - 4] && -1 < t.buffer[e - 1]) { if (i == n) return; if (t.buffer[e - 2] >= i) return void (t.buffer[e - 2] = n) } } if (t && this.pos != n) { let t = this.buffer.length; if (0 < t && 0 != this.buffer[t - 4]) for (; 0 < t && this.buffer[t - 2] > n;)this.buffer[t] = this.buffer[t - 4], this.buffer[t + 1] = this.buffer[t - 3], this.buffer[t + 2] = this.buffer[t - 2], this.buffer[t + 3] = this.buffer[t - 1], t -= 4, 4 < r && (r -= 4); this.buffer[t] = e, this.buffer[t + 1] = i, this.buffer[t + 2] = n, this.buffer[t + 3] = r } else this.buffer.push(e, i, n, r) } shift(n, r, s) { if (131072 & n) this.pushState(65535 & n, this.pos); else if (0 == (262144 & n)) { let t = this.pos, e = n, { parser: i } = this.p; (s > this.pos || r <= i.maxNode) && (this.pos = s, i.stateFlag(e, 1) || (this.reducePos = s)), this.pushState(e, t), r <= i.maxNode && this.buffer.push(r, t, s, 4), this.shiftContext(r) } else r <= this.p.parser.maxNode && this.buffer.push(r, this.pos, s, 4), this.pos = s } apply(t, e, i) { 65536 & t ? this.reduce(t) : this.shift(t, e, i) } useNode(t, e) { let i = this.p.reused.length - 1; (i < 0 || this.p.reused[i] != t) && (this.p.reused.push(t), i++); var n = this.pos; this.reducePos = this.pos = n + t.length, this.pushState(e, n), this.buffer.push(i, n, this.reducePos, -1), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this.p.input, this)) } split() { let t = this, e = t.buffer.length; for (; 0 < e && t.buffer[e - 2] > t.reducePos;)e -= 4; for (var i = t.buffer.slice(e), n = t.bufferBase + e; t && n == t.bufferBase;)t = t.parent; return new rl(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, n, this.curContext, t) } recoverByDelete(t, e) { var i = t <= this.p.parser.maxNode; i && this.storeNode(t, this.pos, e), this.storeNode(0, this.pos, e, i ? 8 : 4), this.pos = this.reducePos = e, this.score -= 200 } canShift(e) { for (let t = new ol(this); ;) { var i = this.p.parser.stateSlot(t.top, 4) || this.p.parser.hasAction(t.top, e); if (0 == (65536 & i)) return !0; if (0 == i) return !1; t.reduce(i) } } get ruleStart() { for (let t = this.state, e = this.stack.length; ;) { var i = this.p.parser.stateSlot(t, 5); if (!(65536 & i)) return 0; if (e -= 3 * (i >> 19), (65535 & i) < this.p.parser.minRepeatTerm) return this.stack[e + 1]; t = this.stack[e] } } startOf(t, e) { let i = this.state, n = this.stack.length, { parser: r } = this.p; for (; ;) { var s = r.stateSlot(i, 5), o = s >> 19, a = 65535 & s; if (-1 < t.indexOf(a)) { s = n - 3 * (s >> 19), s = this.stack[1 + s]; if (null == e || s < e) return s } if (0 == n) return null; i = 0 == o ? (n -= 3, this.stack[n]) : (n -= 3 * (o - 1), r.getGoto(this.stack[n - 3], a, !0)) } } recoverByInsert(i) { if (300 <= this.stack.length) return []; let r = this.p.parser.nextStates(this.state); if (8 < r.length || 120 <= this.stack.length) { let n = []; for (let t = 0, e; t < r.length; t += 2)(e = r[t + 1]) != this.state && this.p.parser.hasAction(e, i) && n.push(r[t], e); if (this.stack.length < 120) for (let t = 0; n.length < 8 && t < r.length; t += 2) { let i = r[t + 1]; n.some((t, e) => 1 & e && t == i) || n.push(r[t], i) } r = n } let n = []; for (let e = 0; e < r.length && n.length < 4; e += 2) { var s = r[e + 1]; if (s != this.state) { let t = this.split(); t.storeNode(0, t.pos, t.pos, 4, !0), t.pushState(s, this.pos), t.shiftContext(r[e]), t.score -= 200, n.push(t) } } return n } forceReduce() { var t = this.p.parser.stateSlot(this.state, 5); return 0 != (65536 & t) && (this.p.parser.validAction(this.state, t) || (this.storeNode(0, this.reducePos, this.reducePos, 4, !0), this.score -= 100), this.reduce(t), !0) } forceAll() { for (; !this.p.parser.stateFlag(this.state, 2) && this.forceReduce();); return this } get deadEnd() { if (3 != this.stack.length) return !1; let { parser: t } = this.p; return 65535 == t.data[t.stateSlot(this.state, 1)] && !t.stateSlot(this.state, 4) } restart() { this.state = this.stack[0], this.stack.length = 0 } sameState(e) { if (this.state != e.state || this.stack.length != e.stack.length) return !1; for (let t = 0; t < this.stack.length; t += 3)if (this.stack[t] != e.stack[t]) return !1; return !0 } get parser() { return this.p.parser } dialectEnabled(t) { return this.p.parser.dialect.flags[t] } shiftContext(t) { this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this.p.input, this)) } reduceContext(t) { this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this.p.input, this)) } emitContext() { var t, e = this.curContext; !e.tracker.strict || ((t = this.buffer.length - 1) < 0 || -2 != this.buffer[t]) && this.buffer.push(e.hash, this.reducePos, this.reducePos, -2) } updateContext(t) { t != this.curContext.context && ((t = new sl(this.curContext.tracker, t)).hash != this.curContext.hash && this.emitContext(), this.curContext = t) } } class sl { constructor(t, e) { this.tracker = t, this.context = e, this.hash = t.hash(e) } } (Qe = {})[Qe.Token = 200] = "Token", Qe[Qe.Reduce = 100] = "Reduce", Qe[Qe.MaxNext = 4] = "MaxNext", Qe[Qe.MaxInsertStackDepth = 300] = "MaxInsertStackDepth", Qe[Qe.DampenInsertStackDepth = 120] = "DampenInsertStackDepth"; class ol { constructor(t) { this.stack = t, this.top = t.state, this.rest = t.stack, this.offset = this.rest.length } reduce(t) { var e = 65535 & t, t = t >> 19; 0 == t ? (this.rest == this.stack.stack && (this.rest = this.rest.slice()), this.rest.push(this.top, 0, 0), this.offset += 3) : this.offset -= 3 * (t - 1); e = this.stack.p.parser.getGoto(this.rest[this.offset - 3], e, !0); this.top = e } } class al { constructor(t, e, i) { this.stack = t, this.pos = e, this.index = i, this.buffer = t.buffer, 0 == this.index && this.maybeNext() } static create(t) { return new al(t, t.bufferBase + t.buffer.length, t.buffer.length) } maybeNext() { var t = this.stack.parent; null != t && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer) } get id() { return this.buffer[this.index - 4] } get start() { return this.buffer[this.index - 3] } get end() { return this.buffer[this.index - 2] } get size() { return this.buffer[this.index - 1] } next() { this.index -= 4, this.pos -= 4, 0 == this.index && this.maybeNext() } fork() { return new al(this.stack, this.pos, this.index) } } class ll { constructor() { this.start = -1, this.value = -1, this.end = -1 } accept(t, e) { this.value = t, this.end = e } } class hl { constructor(t, e) { this.data = t, this.id = e } token(t, e, i) { !function (i, t, n, r, e) { let s = 0, o = 1 << e, a = r.p.parser.dialect; t: for (let e = n.start; 0 != (o & i[s]);) { var l = i[s + 1]; for (let t = s + 3; t < l; t += 2)if (0 < (i[t + 1] & o)) { var h = i[t]; if (a.allows(h) && (-1 == n.value || n.value == h || r.p.parser.overrides(h, n.value))) { n.accept(h, e); break } } var c = t.get(e++); for (let t = 0, e = i[s + 2]; t < e;) { var O = t + e >> 1, d = l + O + (O << 1), u = i[d], f = i[d + 1]; if (c < u) e = O; else { if (!(f <= c)) { s = i[d + 2]; continue t } t = 1 + O } } break } }(this.data, t, e, i, this.id) } } hl.prototype.contextual = hl.prototype.fallback = hl.prototype.extend = !1; class cl { constructor(t, e = {}) { this.token = t, this.contextual = !!e.contextual, this.fallback = !!e.fallback, this.extend = !!e.extend } } function Ol(s, e = Uint16Array) { if ("string" != typeof s) return s; let i = null; for (let r = 0, t = 0; r < s.length;) { let n = 0; for (; ;) { let t = s.charCodeAt(r++), e = !1; if (126 == t) { n = 65535; break } 92 <= t && t--, 34 <= t && t--; let i = t - 32; if (46 <= i && (i -= 46, e = !0), n += i, e) break; n *= 46 } i ? i[t++] = n : i = new e(n) } return i } const dl = "undefined" != typeof process && /\bparse\b/.test(process.env.LOG); let ul = null; function fl(t, e, i) { let n = t.cursor(e); for (; ;)if (!(i < 0 ? n.childBefore(e) : n.childAfter(e))) for (; ;) { if ((i < 0 ? n.to < e : n.from > e) && !n.type.isError) return i < 0 ? Math.max(0, Math.min(n.to - 1, e - 5)) : Math.min(t.length, Math.max(n.from + 1, e + 5)); if (i < 0 ? n.prevSibling() : n.nextSibling()) break; if (!n.parent()) return i < 0 ? 0 : t.length } } class pl { constructor(t) { this.fragments = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment() } nextFragment() { var t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++]; if (t) { for (this.safeFrom = t.openStart ? fl(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? fl(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length;)this.trees.pop(), this.start.pop(), this.index.pop(); this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom } else this.nextStart = 1e9 } nodeAt(t) { if (t < this.nextStart) return null; for (; this.fragment && this.safeTo <= t;)this.nextFragment(); if (!this.fragment) return null; for (; ;) { var e = this.trees.length - 1; if (e < 0) return this.nextFragment(), null; var i = this.trees[e], n = this.index[e]; if (n != i.children.length) { var r = i.children[n], n = this.start[e] + i.positions[n]; if (t < n) return this.nextStart = n, null; if (n == t && n + r.length <= this.safeTo) return n == t && n >= this.safeFrom ? r : null; r instanceof yr ? (this.index[e]++, this.nextStart = n + r.length) : (this.index[e]++, n + r.length >= t && (this.trees.push(r), this.start.push(n), this.index.push(0))) } else this.trees.pop(), this.start.pop(), this.index.pop() } } } class ml extends ll { constructor() { super(...arguments), this.extended = -1, this.mask = 0, this.context = 0 } clear(t) { this.start = t, this.value = this.extended = -1 } } const gl = new ll; class Ql { constructor(t) { this.tokens = [], this.mainToken = gl, this.actions = [], this.tokens = t.tokenizers.map(t => new ml) } getActions(n, r) { let s = 0, o = null, { parser: t } = n.p, { tokenizers: a } = t; var l = t.stateSlot(n.state, 3), h = n.curContext ? n.curContext.hash : 0; for (let i = 0; i < a.length; i++)if (0 != (1 << i & l)) { let t = a[i], e = this.tokens[i]; if ((!o || t.fallback) && (!t.contextual && e.start == n.pos && e.mask == l && e.context == h || (this.updateCachedToken(e, t, n, r), e.mask = l, e.context = h), 0 != e.value)) { var c = s; if (-1 < e.extended && (s = this.addActions(n, e.extended, e.end, s)), s = this.addActions(n, e.value, e.end, s), !t.extend && (o = e, s > c)) break } } for (; this.actions.length > s;)this.actions.pop(); return o || (o = gl, o.start = n.pos, n.pos == r.length ? o.accept(n.p.parser.eofTerm, n.pos) : o.accept(0, n.pos + 1)), this.mainToken = o, this.actions } updateCachedToken(i, t, n, r) { if (i.clear(n.pos), t.token(r, i, n), -1 < i.value) { let { parser: e } = n.p; for (let t = 0; t < e.specialized.length; t++)if (e.specialized[t] == i.value) { var s = e.specializers[t](r.read(i.start, i.end), n); if (0 <= s && n.p.parser.dialect.allows(s >> 1)) { 0 == (1 & s) ? i.value = s >> 1 : i.extended = s >> 1; break } } } else n.pos == r.length ? i.accept(n.p.parser.eofTerm, n.pos) : i.accept(0, n.pos + 1) } putAction(e, t, i, n) { for (let t = 0; t < n; t += 3)if (this.actions[t] == e) return n; return this.actions[n++] = e, this.actions[n++] = t, this.actions[n++] = i, n } addActions(t, i, n, r) { let { state: s } = t, { parser: o } = t.p, { data: a } = o; for (let e = 0; e < 2; e++)for (let t = o.stateSlot(s, e ? 2 : 1); ; t += 3) { if (65535 == a[t]) { if (1 != a[t + 1]) { 0 == r && 2 == a[t + 1] && (r = this.putAction(xl(a, t + 1), i, n, r)); break } t = xl(a, t + 2) } a[t] == i && (r = this.putAction(xl(a, t + 1), i, n, r)) } return r } } (ro = {})[ro.Distance = 5] = "Distance", ro[ro.MaxRemainingPerStep = 3] = "MaxRemainingPerStep", ro[ro.MinBufferLengthPrune = 200] = "MinBufferLengthPrune", ro[ro.ForceReduceLimit = 10] = "ForceReduceLimit"; class vl { constructor(t, e, i, n) { this.parser = t, this.input = e, this.startPos = i, this.context = n, this.pos = 0, this.recovering = 0, this.nextStackID = 9812, this.nested = null, this.nestEnd = 0, this.nestWrap = null, this.reused = [], this.tokens = new Ql(t), this.topTerm = t.top[1], this.stacks = [rl.start(this, t.top[0], this.startPos)]; n = null == n ? void 0 : n.fragments; this.fragments = n && n.length ? new pl(n) : null } advance() { if (this.nested) { var t = this.nested.advance(); return this.pos = this.nested.pos, t && (this.finishNested(this.stacks[0], t), this.nested = null), null } let e = this.stacks, i = this.pos, n = this.stacks = [], r, s, o; for (let t = 0; t < e.length; t++)for (var a = e[t]; ;) { if (a.pos > i) n.push(a); else if (l = this.checkNest(a)) (!o || o.stack.score < a.score) && (o = l); else { if (this.advanceStack(a, n, e)) continue; r || (r = [], s = []), r.push(a); var l = this.tokens.mainToken; s.push(l.value, l.end) } break } if (o) return this.startNested(o), null; if (!n.length) { t = r && function (t) { let e = null; for (var i of t) i.pos == i.p.input.length && i.p.parser.stateFlag(i.state, 2) && (!e || e.score < i.score) && (e = i); return e }(r); if (t) return this.stackToTree(t); if (this.parser.strict) throw dl && r && console.log("Stuck with token " + this.parser.getName(this.tokens.mainToken.value)), new SyntaxError("No parse at " + i); this.recovering || (this.recovering = 5) } if (this.recovering && r) { let t = this.runRecovery(r, s, n); if (t) return this.stackToTree(t.forceAll()) } if (this.recovering) { var h = 1 == this.recovering ? 1 : 3 * this.recovering; if (n.length > h) for (n.sort((t, e) => e.score - t.score); n.length > h;)n.pop(); n.some(t => t.reducePos > i) && this.recovering-- } else if (1 < n.length) t: for (let i = 0; i < n.length - 1; i++) { let e = n[i]; for (let t = i + 1; t < n.length; t++) { var c = n[t]; if (e.sameState(c) || 200 < e.buffer.length && 200 < c.buffer.length) { if (!(0 < (e.score - c.score || e.buffer.length - c.buffer.length))) { n.splice(i--, 1); continue t } n.splice(t--, 1) } } } this.pos = n[0].pos; for (let t = 1; t < n.length; t++)n[t].pos < this.pos && (this.pos = n[t].pos); return null } advanceStack(i, n, r) { let s = i.pos, { input: t, parser: o } = this; var a = dl ? this.stackID(i) + " -> " : ""; if (this.fragments) { var e = i.curContext && i.curContext.tracker.strict, l = e ? i.curContext.hash : 0; for (let t = this.fragments.nodeAt(s); t;) { var h = this.parser.nodeSet.types[t.type.id] == t.type ? o.getGoto(i.state, t.type.id) : -1; if (-1 < h && t.length && (!e || (t.contextHash || 0) == l)) return i.useNode(t, h), dl && console.log(a + this.stackID(i) + ` (via reuse of ${o.getName(t.type.id)})`), !0; if (!(t instanceof wr) || 0 == t.children.length || 0 < t.positions[0]) break; h = t.children[0]; if (!(h instanceof wr)) break; t = h } } var c = o.stateSlot(i.state, 4); if (0 < c) return i.reduce(c), dl && console.log(a + this.stackID(i) + ` (via always-reduce ${o.getName(65535 & c)})`), !0; var O = this.tokens.getActions(i, t); for (let e = 0; e < O.length;) { var d = O[e++], u = O[e++], f = O[e++], p = e == O.length || !r; let t = p ? i : i.split(); if (t.apply(d, u, f), dl && console.log(a + this.stackID(t) + ` (via ${0 == (65536 & d) ? "shift" : `reduce of ${o.getName(65535 & d)}`} for ${o.getName(u)} @ ${s}${t == i ? "" : ", split"})`), p) return !0; (t.pos > s ? n : r).push(t) } return !1 } advanceFully(t, e) { for (var i = t.pos; ;) { var n = this.checkNest(t); if (n) return n; if (!this.advanceStack(t, null, null)) return !1; if (t.pos > i) return wl(t, e), !0 } } runRecovery(o, a, l) { let h = null, c = !1, O; for (let s = 0; s < o.length; s++) { let t = o[s], e = a[s << 1], i = a[1 + (s << 1)]; var d, u = dl ? this.stackID(t) + " -> " : ""; if (t.deadEnd) { if (c) continue; c = !0, t.restart(), dl && console.log(u + this.stackID(t) + " (restarted)"); var f = this.advanceFully(t, l); if (f) { !0 !== f && (O = f); continue } } let n = t.split(), r = u; for (let t = 0; n.forceReduce() && t < 10; t++) { dl && console.log(r + this.stackID(n) + " (via force-reduce)"); var p = this.advanceFully(n, l); if (p) { !0 !== p && (O = p); break } dl && (r = this.stackID(n) + " -> ") } for (d of t.recoverByInsert(e)) dl && console.log(u + this.stackID(d) + " (via recover-insert)"), this.advanceFully(d, l); this.input.length > t.pos ? (i == t.pos && (i++, e = 0), t.recoverByDelete(e, i), dl && console.log(u + this.stackID(t) + ` (via recover-delete ${this.parser.getName(e)})`), wl(t, l)) : (!h || h.score < t.score) && (h = t) } if (h) return h; if (O) for (var t of this.stacks) if (t.score > O.stack.score) { O = void 0; break } return O && this.startNested(O), null } forceFinish() { let t = this.stacks[0].split(); return this.nested && this.finishNested(t, this.nested.forceFinish()), this.stackToTree(t.forceAll()) } stackToTree(t, e = t.pos) { return this.parser.context && t.emitContext(), wr.build({ buffer: al.create(t), nodeSet: this.parser.nodeSet, topID: this.topTerm, maxBufferLength: this.parser.bufferLength, reused: this.reused, start: this.startPos, length: e - this.startPos, minRepeatType: this.parser.minRepeatTerm }) } checkNest(t) { var e = this.parser.findNested(t.state); if (!e) return null; let i = e.value; return "function" == typeof i && (i = i(this.input, t)), i ? { stack: t, info: e, spec: i } : null } startNested(t) { let { stack: e, info: i, spec: n } = t; this.stacks = [e], this.nestEnd = this.scanForNestEnd(e, i.end, n.filterEnd), this.nestWrap = "number" == typeof n.wrapType ? this.parser.nodeSet.types[n.wrapType] : n.wrapType || null, n.startParse ? this.nested = n.startParse(this.input.clip(this.nestEnd), e.pos, this.context) : this.finishNested(e) } scanForNestEnd(e, i, n) { for (let t = e.pos; t < this.input.length; t++)if (gl.start = t, gl.value = -1, i.token(this.input, gl, e), -1 < gl.value && (!n || n(this.input.read(t, gl.end)))) return t; return this.input.length } finishNested(t, e) { e = this.nestWrap ? new wr(this.nestWrap, e ? [e] : [], e ? [0] : [], this.nestEnd - t.pos) : e || new wr(Qr.none, [], [], this.nestEnd - t.pos); var i = this.parser.findNested(t.state); t.useNode(e, this.parser.getGoto(t.state, i.placeholder, !0)), dl && console.log(this.stackID(t) + " (via unnest)") } stackID(t) { let e = (ul = ul || new WeakMap).get(t); return e || ul.set(t, e = String.fromCodePoint(this.nextStackID++)), e + t } } function wl(i, n) { for (let e = 0; e < n.length; e++) { let t = n[e]; if (t.pos == i.pos && t.sameState(i)) return void (n[e].score < i.score && (n[e] = i)) } n.push(i) } class $l { constructor(t, e, i) { this.source = t, this.flags = e, this.disabled = i } allows(t) { return !this.disabled || 0 == this.disabled[t] } } const yl = t => t; class bl { constructor(i) { if (this.bufferLength = 1024, this.strict = !1, this.cachedDialect = null, 13 != i.version) throw new RangeError(`Parser version (${i.version}) doesn't match runtime version (13)`); let e = Ol(i.tokenData), n = i.nodeNames.split(" "); this.minRepeatTerm = n.length, this.context = i.context; for (let t = 0; t < i.repeatNodeCount; t++)n.push(""); let r = []; for (let t = 0; t < n.length; t++)r.push([]); function s(t, e, i) { r[t].push([e, e.deserialize(String(i))]) } if (i.nodeProps) for (var o of i.nodeProps) { var a = o[0]; for (let e = 1; e < o.length;) { var l = o[e++]; if (0 <= l) s(l, a, o[e++]); else { var h = o[e + -l]; for (let t = -l; 0 < t; t--)s(o[e++], a, h); e++ } } } if (this.specialized = new Uint16Array(i.specialized ? i.specialized.length : 0), this.specializers = [], i.specialized) for (let t = 0; t < i.specialized.length; t++)this.specialized[t] = i.specialized[t].term, this.specializers[t] = i.specialized[t].get; this.states = Ol(i.states, Uint32Array), this.data = Ol(i.stateData), this.goto = Ol(i.goto); let c = Object.keys(i.topRules).map(t => i.topRules[t][1]); this.nodeSet = new vr(n.map((t, e) => Qr.define({ name: e >= this.minRepeatTerm ? void 0 : t, id: e, props: r[e], top: -1 < c.indexOf(e), error: 0 == e, skipped: i.skippedNodes && -1 < i.skippedNodes.indexOf(e) }))), this.maxTerm = i.maxTerm, this.tokenizers = i.tokenizers.map(t => "number" == typeof t ? new hl(e, t) : t), this.topRules = i.topRules, this.nested = (i.nested || []).map(([t, e, i, n]) => ({ name: t, value: e, end: new hl(Ol(i), 0), placeholder: n })), this.dialects = i.dialects || {}, this.dynamicPrecedences = i.dynamicPrecedences || null, this.tokenPrecTable = i.tokenPrec, this.termNames = i.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]] } parse(t, e = 0, i = {}) { "string" == typeof t && (t = Cr(t)); let n = new vl(this, t, e, i); for (; ;) { var r = n.advance(); if (r) return r } } startParse(t, e = 0, i = {}) { return "string" == typeof t && (t = Cr(t)), new vl(this, t, e, i) } getGoto(e, i, n = !1) { var r = this.goto; if (i >= r[0]) return -1; for (let t = r[i + 1]; ;) { var s = r[t++], o = 1 & s, a = r[t++]; if (o && n) return a; for (var l = t + (s >> 1); t < l; t++)if (r[t] == e) return a; if (o) return -1 } } hasAction(n, r) { var s = this.data; for (let i = 0; i < 2; i++)for (let t = this.stateSlot(n, i ? 2 : 1), e; ; t += 3) { if (65535 == (e = s[t])) { if (1 != s[t + 1]) { if (2 == s[t + 1]) return xl(s, t + 2); break } e = s[t = xl(s, t + 2)] } if (e == r || 0 == e) return xl(s, t + 1) } return 0 } stateSlot(t, e) { return this.states[6 * t + e] } stateFlag(t, e) { return 0 < (this.stateSlot(t, 0) & e) } findNested(t) { t = this.stateSlot(t, 0); return 4 & t ? this.nested[t >> 10] : null } validAction(e, i) { if (i == this.stateSlot(e, 4)) return !0; for (let t = this.stateSlot(e, 1); ; t += 3) { if (65535 == this.data[t]) { if (1 != this.data[t + 1]) return !1; t = xl(this.data, t + 2) } if (i == xl(this.data, t + 1)) return !0 } } nextStates(e) { let n = []; for (let t = this.stateSlot(e, 1); ; t += 3) { if (65535 == this.data[t]) { if (1 != this.data[t + 1]) break; t = xl(this.data, t + 2) } if (0 == (1 & this.data[t + 2])) { let i = this.data[t + 1]; n.some((t, e) => 1 & e && t == i) || n.push(this.data[t], i) } } return n } overrides(t, e) { e = kl(this.data, this.tokenPrecTable, e); return e < 0 || kl(this.data, this.tokenPrecTable, t) < e } configure(i) { let t = Object.assign(Object.create(bl.prototype), this); if (i.props && (t.nodeSet = this.nodeSet.extend(...i.props)), i.top) { var e = this.topRules[i.top]; if (!e) throw new RangeError(`Invalid top rule name ${i.top}`); t.top = e } return i.tokenizers && (t.tokenizers = this.tokenizers.map(e => { var t = i.tokenizers.find(t => t.from == e); return t ? t.to : e })), i.dialect && (t.dialect = this.parseDialect(i.dialect)), i.nested && (t.nested = this.nested.map(t => Object.prototype.hasOwnProperty.call(i.nested, t.name) ? { name: t.name, value: i.nested[t.name], end: t.end, placeholder: t.placeholder } : t)), null != i.strict && (t.strict = i.strict), null != i.bufferLength && (t.bufferLength = i.bufferLength), t } getName(t) { return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t) } get eofTerm() { return this.maxNode + 1 } get hasNested() { return 0 < this.nested.length } get topNode() { return this.nodeSet.types[this.top[1]] } dynamicPrecedence(t) { var e = this.dynamicPrecedences; return null != e && e[t] || 0 } parseDialect(t) { if (this.cachedDialect && this.cachedDialect.source == t) return this.cachedDialect; let n = Object.keys(this.dialects), e = n.map(() => !1); if (t) for (var i of t.split(" ")) { i = n.indexOf(i); 0 <= i && (e[i] = !0) } let r = null; for (let i = 0; i < n.length; i++)if (!e[i]) for (let t = this.dialects[n[i]], e; 65535 != (e = this.data[t++]);)(r = r || new Uint8Array(this.maxTerm + 1))[e] = 1; return this.cachedDialect = new $l(t, e, r) } static deserialize(t) { return new bl(t) } } function xl(t, e) { return t[e] | t[e + 1] << 16 } function kl(i, n, r) { for (let t = n, e; 65535 != (e = i[t]); t++)if (e == r) return t - n; return -1 } const Sl = 25, Pl = { area: !0, base: !0, br: !0, col: !0, command: !0, embed: !0, frame: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0, menuitem: !0 }, Tl = { dd: !0, li: !0, optgroup: !0, option: !0, p: !0, rp: !0, rt: !0, tbody: !0, td: !0, tfoot: !0, th: !0, tr: !0 }, Wl = { dd: { dd: !0, dt: !0 }, dt: { dd: !0, dt: !0 }, li: { li: !0 }, option: { option: !0, optgroup: !0 }, optgroup: { optgroup: !0 }, p: { address: !0, article: !0, aside: !0, blockquote: !0, dir: !0, div: !0, dl: !0, fieldset: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, menu: !0, nav: !0, ol: !0, p: !0, pre: !0, section: !0, table: !0, ul: !0 }, rp: { rp: !0, rt: !0 }, rt: { rp: !0, rt: !0 }, tbody: { tbody: !0, tfoot: !0 }, td: { td: !0, th: !0 }, tfoot: { tbody: !0 }, th: { td: !0, th: !0 }, thead: { tbody: !0, tfoot: !0 }, tr: { tr: !0 } }; let Xl = null, Rl = null, _l = 0; function Cl(t, e) { if (_l == e && Rl == t) return Xl; let i = t.get(e); for (; 9 == (n = i) || 10 == n || 13 == n || 32 == n;)i = t.get(++e); for (var n, r, s = e; 45 == (r = i) || 46 == r || 58 == r || 65 <= r && r <= 90 || 95 == r || 97 <= r && r <= 122 || 161 <= r;)i = t.get(++e); return Rl = t, _l = e, Xl = s < e ? t.read(s, e).toLowerCase() : 63 == i || 33 == i ? void 0 : null } function Al(e, t) { this.name = e, this.parent = t, this.hash = t ? t.hash : 0; for (let t = 0; t < e.length; t++)this.hash += (this.hash << 4) + e.charCodeAt(t) + (e.charCodeAt(t) << 8) } Ds = new class { constructor(t) { this.start = t.start, this.shift = t.shift || yl, this.reduce = t.reduce || yl, this.reuse = t.reuse || yl, this.hash = t.hash, this.strict = !1 !== t.strict } }({ start: null, shift(t, e, i, n) { return 1 == e ? new Al(Cl(i, n.pos) || "", t) : t }, reduce(t, e) { return 10 == e && t ? t.parent : t }, reuse(t, e, i, n) { var r = e.type.id; return 1 == r || 11 == r ? new Al(Cl(i, n.pos - e.length + 1) || "", t) : t }, hash(t) { return t ? t.hash : 0 }, strict: !1 }), Bs = new cl((t, e, i) => { let n = e.start, r = t.get(n), s; if (r < 0 && i.context && e.accept(33, e.start), 60 == r) { n++, (s = 47 == t.get(n)) && n++; var o = Cl(t, n); if (void 0 !== o) { if (!o) return e.accept(s ? 4 : 1, n); t = i.context ? i.context.name : null; if (s) { if (o == t) return e.accept(2, n); if (t && Tl[t]) return e.accept(33, e.start); if (i.dialectEnabled(0)) return e.accept(2, n); for (let t = i.context; t; t = t.parent)if (t.name == o) return; e.accept(3, n) } else t && Wl[t] && Wl[t][o] ? e.accept(33, e.start) : e.accept(1, n) } } }), Gs = new cl((t, e, i) => { let n = t.get(e.start), r = e.start + 1; if (47 == n) { if (62 != t.get(r)) return; r++ } else if (62 != n) return; i.context && Pl[i.context.name] && e.accept(5, r) }), Qe = new cl((t, e) => { let i = e.start, n = 0; for (; ;) { var r = t.get(i); if (r < 0) break; if (i++, r == "--\x3e".charCodeAt(n)) { if (n++, 3 == n) { i -= 3; break } } else n = 0 } i > e.start && e.accept(34, i) }); const Ll = /^<\/?\s*([\.\-\:\w\xa1-\uffff]+)/; function zl(t) { let e = Ll.exec(t); return e ? e[1].toLowerCase() : null } function ql(e) { return t => zl(t) == e } function Vl(t) { let a = null; for (var e of t) a = a || Object.create(null), (a[e.tag] || (a[e.tag] = [])).push({ attrs: e.attrs, value: { filterEnd: ql(e.tag), startParse: e.parser.startParse.bind(e.parser) } }); return function (t, e) { var i = t.read(e.ruleStart, e.pos); let n = zl(i), r, s; if (!n) return null; if (a && (r = a[n])) for (var o of r) if (!o.attrs || o.attrs(s = s || function (i) { let n = Ll.exec(i), r = {}; if (n) { let t = /\s*([\.\-\:\w\xa1-\uffff]+)\s*(?:=\s*(?:"([^"]*)"|'([^']*)'|([^\s=<>"'/]+)))?/g, e; for (t.lastIndex = n.index + n[0].length; e = t.exec(i);)r[e[1]] = e[4] || e[3] || e[2] || e[1] } return r }(i))) return o.value; return "script" == n || "textarea" == n || "style" == n ? { filterEnd: ql(n), wrapType: Sl } : null } } ro = Vl([]); function Yl(t) { return { elementContent: Vl(t) } } Ds = bl.deserialize({ version: 13, states: "'OOVOXOOOtQ`O'#CgS!eOXO'#CfOOOP'#Cf'#CfO!oOdO'#CqO!wQ`O'#CsOOOP'#DR'#DROOOP'#Cv'#CvQVOXOOO!|QrO,59ROOOP'#Cz'#CzO#XOXO'#DWO#cOPO,59QOOOS'#C{'#C{O#kOdO,59]OOOP,59],59]O#sQ`O,59_OOOP-E6t-E6tO#xQrO'#CiOOQQ'#Cw'#CwO$WQrO1G.mOOOP1G.m1G.mOOOP1G.v1G.vOOOP-E6x-E6xO$cQ`O'#CoOOOP1G.l1G.lOOOS-E6y-E6yOOOP1G.w1G.wOOOP1G.y1G.yO$hQ!bO,59TOOQQ-E6u-E6uOOOP7+$X7+$XOOOP7+$b7+$bO$sQ`O,59ZO$xO#tO'#ClO%WO&jO'#ClOOQQ1G.o1G.oOOOP1G.u1G.uOOOO'#Cx'#CxO%fO#tO,59WOOQQ,59W,59WOOOO'#Cy'#CyO%tO&jO,59WOOOO-E6v-E6vOOQQ1G.r1G.rOOOO-E6w-E6w", stateData: "&X~OtOS~OPPORTOSUOVUOWUOXUOfUOhVO{SO~O[XO~OPPORTOSUOVUOWUOXUOfUO{SO~OQzPqzP~PyOr]O|_O~O[`O~OTfO^bObeO~OQzXqzX~PyOQhOqiO~Or]O|kO~OblO~O_mOT]X^]Xb]X~OTpO^bOboO~O[qO~OatOvrOxsO~ObuO~OWvOXvOvxOwvO~OWyOXyOxxOyyO~OWvOXvOv|OwvO~OWyOXyOx|OyyO~O{fhf~", goto: "#k{PPPPPPPPPP|!SP!YPP!^PP!a!d|P|PP!j!p!v!|#S#YPPPPP#`PPPP#hXUOQWZXQOQWZTcXdRtmRi[XROQWZQWORaWQdXRndQwrR{wQzsR}zQZQRgZQ^SRj^SVOWTYQZR[Q", nodeNames: "⚠ StartTag StartCloseTag StartCloseTag IncompleteCloseTag SelfCloseEndTag Document Text EntityReference CharacterReference Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl RawText", maxTerm: 44, context: Ds, nodeProps: [[mr.closedBy, -2, 1, 2, "EndTag SelfCloseEndTag", 11, "CloseTag"], [mr.openedBy, 5, "StartTag", 18, "StartTag StartCloseTag", 19, "OpenTag"]], skippedNodes: [0, 25], repeatNodeCount: 6, tokenData: "!#`!aR!WOX$kXY)sYZ)sZ]$k]^)s^p$kpq)sqr$krs*zsv$kvw+dwx2wx}$k}!O3d!O!P$k!P!Q7]!Q![$k![!]8s!]!^$k!^!_>`!_!`!!n!`!a8R!a!c$k!c!}8s!}#R$k#R#S8s#S#T$k#T#o8s#o$f$k$f$g&R$g%W$k%W%o8s%o%p$k%p&a8s&a&b$k&b1p8s1p4U$k4U4d8s4d4e$k4e$IS8s$IS$I`$k$I`$Ib8s$Ib$Kh$k$Kh%#t8s%#t&/x$k&/x&Et8s&Et&FV$k&FV;'S8s;'S;:j<r;:j?&r$k?&r?Ah8s?Ah?BY$k?BY?Mn8s?Mn~$k!Z$vcVPaWw`ypOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!R&[VVPw`ypOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&Rq&xTVPypOv&qwx'Xx!^&q!^!_'g!_~&qP'^RVPOv'Xw!^'X!_~'Xp'lQypOv'gx~'ga'yUVPw`Or'rrs'Xsv'rw!^'r!^!_(]!_~'r`(bRw`Or(]sv(]w~(]!Q(rTw`ypOr(krs'gsv(kwx(]x~(kW)WXaWOX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!a*O^VPw`ypt^OX&RXY)sYZ)sZ]&R]^)s^p&Rpq)sqr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!Z+TTvhVPypOv&qwx'Xx!^&q!^!_'g!_~&q!Z+ibaWOX,qXZ.OZ],q]^.O^p,qqr,qrs.Ost/Ztw,qwx.Ox!P,q!P!Q.O!Q!],q!]!^)R!^!a.O!a$f,q$f$g.O$g~,q!Z,vbaWOX,qXZ.OZ],q]^.O^p,qqr,qrs.Ost)Rtw,qwx.Ox!P,q!P!Q.O!Q!],q!]!^.g!^!a.O!a$f,q$f$g.O$g~,q!R.RTOp.Oqs.Ot!].O!]!^.b!^~.O!R.gOW!R!Z.nXW!RaWOX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z/`aaWOX0eXZ1oZ]0e]^1o^p0eqr0ers1osw0ewx1ox!P0e!P!Q1o!Q!]0e!]!^)R!^!a1o!a$f0e$f$g1o$g~0e!Z0jaaWOX0eXZ1oZ]0e]^1o^p0eqr0ers1osw0ewx1ox!P0e!P!Q1o!Q!]0e!]!^2T!^!a1o!a$f0e$f$g1o$g~0e!R1rSOp1oq!]1o!]!^2O!^~1o!R2TOX!R!Z2[XX!RaWOX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z3QUxxVPw`Or'rrs'Xsv'rw!^'r!^!_(]!_~'r!]3oeVPaWw`ypOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O5Q!O!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!]5]dVPaWw`ypOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!`&R!`!a6k!a$f$k$f$g&R$g~$k!T6vVVPw`yp|QOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!X7fXVPw`ypOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_!`&R!`!a8R!a~&R!X8^VbUVPw`ypOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!a9S!Y^S[QVPaWw`ypOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O8s!O!P8s!P!Q&R!Q![8s![!]8s!]!^$k!^!_(k!_!a&R!a!c$k!c!}8s!}#R$k#R#S8s#S#T$k#T#o8s#o$f$k$f$g&R$g$}$k$}%O8s%O%W$k%W%o8s%o%p$k%p&a8s&a&b$k&b1p8s1p4U8s4U4d8s4d4e$k4e$IS8s$IS$I`$k$I`$Ib8s$Ib$Je$k$Je$Jg8s$Jg$Kh$k$Kh%#t8s%#t&/x$k&/x&Et8s&Et&FV$k&FV;'S8s;'S;:j<r;:j?&r$k?&r?Ah8s?Ah?BY$k?BY?Mn8s?Mn~$k!a<}eVPaWw`ypOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g;=`$k;=`<%l8s<%l~$k!R>gWw`ypOq(kqr?Prs'gsv(kwx(]x!a(k!a!bKh!b~(k!R?WZw`ypOr(krs'gsv(kwx(]x}(k}!O?y!O!f(k!f!gAP!g#W(k#W#XGx#X~(k!R@QVw`ypOr(krs'gsv(kwx(]x}(k}!O@g!O~(k!R@pTw`yp{POr(krs'gsv(kwx(]x~(k!RAWVw`ypOr(krs'gsv(kwx(]x!q(k!q!rAm!r~(k!RAtVw`ypOr(krs'gsv(kwx(]x!e(k!e!fBZ!f~(k!RBbVw`ypOr(krs'gsv(kwx(]x!v(k!v!wBw!w~(k!RCOVw`ypOr(krs'gsv(kwx(]x!{(k!{!|Ce!|~(k!RClVw`ypOr(krs'gsv(kwx(]x!r(k!r!sDR!s~(k!RDYVw`ypOr(krs'gsv(kwx(]x!g(k!g!hDo!h~(k!RDvWw`ypOrDorsE`svDovwEtwxFdx!`Do!`!aG`!a~DoqEeTypOvE`vxEtx!`E`!`!aFV!a~E`PEwRO!`Et!`!aFQ!a~EtPFVOhPqF^QyphPOv'gx~'gaFiVw`OrFdrsEtsvFdvwEtw!`Fd!`!aGO!a~FdaGVRw`hPOr(]sv(]w~(]!RGiTw`yphPOr(krs'gsv(kwx(]x~(k!RHPVw`ypOr(krs'gsv(kwx(]x#c(k#c#dHf#d~(k!RHmVw`ypOr(krs'gsv(kwx(]x#V(k#V#WIS#W~(k!RIZVw`ypOr(krs'gsv(kwx(]x#h(k#h#iIp#i~(k!RIwVw`ypOr(krs'gsv(kwx(]x#m(k#m#nJ^#n~(k!RJeVw`ypOr(krs'gsv(kwx(]x#d(k#d#eJz#e~(k!RKRVw`ypOr(krs'gsv(kwx(]x#X(k#X#YDo#Y~(k!RKoWw`ypOrKhrsLXsvKhvwLmwxM}x!aKh!a!b! e!b~KhqL^TypOvLXvxLmx!aLX!a!bM[!b~LXPLpRO!aLm!a!bLy!b~LmPL|RO!`Lm!`!aMV!a~LmPM[OfPqMaTypOvLXvxLmx!`LX!`!aMp!a~LXqMwQypfPOv'gx~'gaNSVw`OrM}rsLmsvM}vwLmw!aM}!a!bNi!b~M}aNnVw`OrM}rsLmsvM}vwLmw!`M}!`!a! T!a~M}a! [Rw`fPOr(]sv(]w~(]!R! lWw`ypOrKhrsLXsvKhvwLmwxM}x!`Kh!`!a!!U!a~Kh!R!!_Tw`ypfPOr(krs'gsv(kwx(]x~(k!V!!yV_SVPw`ypOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R", tokenizers: [Bs, Gs, Qe, 0, 1, 2, 3, 4, 5], topRules: { Document: [0, 6] }, nested: [["elementContent", ro, "%S~RP!^!_U~XP!P!Q[~_dXY[YZ[]^[pq[![!]!m!c!}!m#R#S!m#T#o!m%W%o!m%p&a!m&b1p!m4U4d!m4e$IS!m$I`$Ib!m$Kh%#t!m&/x&Et!m&FV;'S!m;'S;:j$|?&r?Ah!m?BY?Mn!m~!pkXY$eYZ$e]^$epq$e}!O!m!O!P!m!Q![!m![!]!m!`!a$w!c!}!m#R#S!m#T#o!m$}%O!m%W%o!m%p&a!m&b1p!m1p4U!m4U4d!m4e$IS!m$I`$Ib!m$Je$Jg!m$Kh%#t!m&/x&Et!m&FV;'S!m;'S;:j$|?&r?Ah!m?BY?Mn!m~$hTXY$eYZ$e]^$epq$e!`!a$w~$|Op~~%PP;=`<%l!m", 42]], dialects: { noMatch: 0 }, tokenPrec: 234 }); const Ml = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288]; function Zl(t) { return 65 <= t && t <= 90 || 97 <= t && t <= 122 || 161 <= t } Bs = new cl((t, e) => { let i = e.start, n = i, r = !1; for (; ;) { var s = t.get(n); if (!(Zl(s) || 45 == s || 95 == s || r && (48 <= (o = s) && o <= 57))) { r && e.accept(40 == s ? 93 : 94, n); break } !r && (45 != s || n > i) && (r = !0), n++ } var o }), Gs = new cl((t, e) => { Ml.includes(t.get(e.start - 1)) && (!Zl(t = t.get(e.start)) && 95 != t && 35 != t && 46 != t && 91 != t && 58 != t && 45 != t || e.accept(92, e.start)) }), Qe = new cl((e, i) => { var { start: n } = i; if (!Ml.includes(e.get(n - 1))) { var t = e.get(n); if (37 == t && i.accept(1, n + 1), Zl(t)) { let t = n + 1; for (; Zl(e.get(t));)t++; i.accept(1, t) } } }); const El = { __proto__: null, not: 30, url: 64, "url-prefix": 64, domain: 64, regexp: 64, selector: 132 }, jl = { __proto__: null, "@import": 112, "@media": 136, "@charset": 140, "@namespace": 144, "@keyframes": 150, "@supports": 162 }, Dl = { __proto__: null, not: 126, only: 126, from: 156, to: 158 }, Hl = bl.deserialize({ version: 13, states: "7WOYQ[OOOOQP'#Cc'#CcOOQP'#Cb'#CbO!ZQ[O'#CeO!}QXO'#C`O#UQ[O'#CgO#aQ[O'#DOO#fQ[O'#DSOOQP'#Eb'#EbO#kQdO'#DdO$SQ[O'#DqO#kQdO'#DsO$eQ[O'#DuO$pQ[O'#DxO$uQ[O'#EOO%TQ[O'#EQOOQS'#Ea'#EaOOQS'#ER'#ERQYQ[OOOOQP'#Cf'#CfOOQP,59P,59PO!ZQ[O,59PO%[Q[O'#ESO%vQWO,58zO&OQ[O,59RO#aQ[O,59jO#fQ[O,59nO%[Q[O,59rO%[Q[O,59tO%[Q[O,59uO'[Q[O'#D_OOQS,58z,58zOOQP'#Cj'#CjOOQO'#Cp'#CpOOQP,59R,59RO'cQWO,59RO'hQWO,59ROOQP'#DQ'#DQOOQP,59j,59jOOQO'#DU'#DUO'mQ`O,59nOOQS'#Cr'#CrO#kQdO'#CsO'uQvO'#CuO(|QtO,5:OOOQO'#Cz'#CzO'hQWO'#CyO)bQWO'#C{OOQS'#Ef'#EfOOQO'#Dg'#DgO)gQ[O'#DnO)uQWO'#EhO$uQ[O'#DlO*TQWO'#DoOOQO'#Ei'#EiO%yQWO,5:]O*YQpO,5:_OOQS'#Dw'#DwO*bQWO,5:aO*gQ[O,5:aOOQO'#Dz'#DzO*oQWO,5:dO*tQWO,5:jO*|QWO,5:lOOQS-E8P-E8POOQP1G.k1G.kO+pQXO,5:nOOQO-E8Q-E8QOOQS1G.f1G.fOOQP1G.m1G.mO'cQWO1G.mO'hQWO1G.mOOQP1G/U1G/UO+}Q`O1G/YO,hQXO1G/^O-OQXO1G/`O-fQXO1G/aO-|QXO'#CcO.qQWO'#D`OOQS,59y,59yO.vQWO,59yO/OQ[O,59yO/VQ[O'#CnO/^QdO'#CqOOQP1G/Y1G/YO#kQdO1G/YO/eQpO,59_OOQS,59a,59aO#kQdO,59cO/mQWO1G/jOOQS,59e,59eO/rQ!bO,59gO/zQWO'#DgO0VQWO,5:SO0[QWO,5:YO$uQ[O,5:UO$uQ[O'#EXO0dQWO,5;SO0oQWO,5:WO%[Q[O,5:ZOOQS1G/w1G/wOOQS1G/y1G/yOOQS1G/{1G/{O1QQWO1G/{O1VQdO'#D{OOQS1G0O1G0OOOQS1G0U1G0UOOQS1G0W1G0WOOQP7+$X7+$XOOQP7+$t7+$tO#kQdO7+$tO#kQdO,59zO1eQ[O'#EWO1oQWO1G/eOOQS1G/e1G/eO1oQWO1G/eO1wQXO'#EdO2OQWO,59YO2TQtO'#ETO2uQdO'#EeO3PQWO,59]O3UQpO7+$tOOQS1G.y1G.yOOQS1G.}1G.}OOQS7+%U7+%UO3^QWO1G/RO#kQdO1G/nOOQO1G/t1G/tOOQO1G/p1G/pO3cQWO,5:sOOQO-E8V-E8VO3qQXO1G/uOOQS7+%g7+%gO3xQYO'#CuO%yQWO'#EYO4QQdO,5:gOOQS,5:g,5:gO4`QpO<<H`O4hQtO1G/fOOQO,5:r,5:rO4{Q[O,5:rOOQO-E8U-E8UOOQS7+%P7+%PO5VQWO7+%PO5_QWO,5;OOOQP1G.t1G.tOOQS-E8R-E8RO#kQdO'#EUO5gQWO,5;POOQT1G.w1G.wOOQP<<H`<<H`OOQS7+$m7+$mO5oQdO7+%YOOQO7+%a7+%aOOQS,5:t,5:tOOQS-E8W-E8WOOQS1G0R1G0ROOQPAN=zAN=zO5vQtO'#EVO#kQdO'#EVO6nQdO7+%QOOQO7+%Q7+%QOOQO1G0^1G0^OOQS<<Hk<<HkO7OQdO,5:pOOQO-E8S-E8SOOQO<<Ht<<HtO7YQtO,5:qOOQS-E8T-E8TOOQO<<Hl<<Hl", stateData: "8W~O#SOSQOS~OTWOWWO[TO]TOsUOwVO!X_O!YXO!fYO!hZO!j[O!m]O!s^O#QPO#VRO~O#QcO~O[hO]hOcfOsiOwjO{kO!OmO#OlO#VeO~O!QnO~P!`O_sO#PqO#QpO~O#QuO~O#QwO~OazOh!QOj!QOp!PO#P}O#QyO#Z{O~Oa!SO!a!UO!d!VO#Q!RO!Q#[P~Oj![Op!PO#Q!ZO~O#Q!^O~Oa!SO!a!UO!d!VO#Q!RO~O!V#[P~P$SOTWOWWO[TO]TOsUOwVO#QPO#VRO~OcfO!QnO~O_!hO#PqO#QpO~OTWOWWO[TO]TOsUOwVO!X_O!YXO!fYO!hZO!j[O!m]O!s^O#Q!oO#VRO~O!P!qO~P&ZOa!tO~Oa!uO~Ou!vOy!wO~OP!yOaiXliX!ViX!aiX!diX#QiX`iXciXhiXjiXpiX#PiX#ZiXuiX!PiX!UiX~Oa!SOl!zO!a!UO!d!VO#Q!RO!V#[P~Oa!}O~Oa!SO!a!UO!d!VO#Q#OO~Oc#SO!_#RO!Q#[X!V#[X~Oa#VO~Ol!zO!V#XO~O!V#YO~Oj#ZOp!PO~O!Q#[O~O!QnO!_#RO~O!QnO!V#_O~O[hO]hOsiOwjO{kO!OmO#OlO#VeO~Oc!va!Q!va`!va~P+UOu#aOy#bO~O[hO]hOsiOwjO#VeO~Oczi{zi!Ozi!Qzi#Ozi`zi~P,VOc|i{|i!O|i!Q|i#O|i`|i~P,VOc}i{}i!O}i!Q}i#O}i`}i~P,VO[VX[!TX]VXcVXsVXwVX{VX!OVX!QVX#OVX#VVX~O[#cO~O!P#fO!V#dO~O!P#fO~P&ZO`#WP~P%[O`#XP~P#kO`#nOl!zO~O!V#pO~Oj#qOq#qO~O[!]X`!ZX!_!ZX~O[#rO~O`#sO!_#RO~Oc#SO!Q#[a!V#[a~O!_#ROc!`a!Q!`a!V!`a`!`a~O!V#xO~O!P#|O!p#zO!q#zO#Z#yO~O!P!zX!V!zX~P&ZO!P$SO!V#dO~O`#WX~P!`O`$VO~Ol!zO`!wXa!wXc!wXh!wXj!wXp!wX#P!wX#Q!wX#Z!wX~Oc$XO`#XX~P#kO`$ZO~Ol!zOu$[O~O`$]O~O!_#ROc!{a!Q!{a!V!{a~O`$_O~P+UOP!yO!QiX~O!P$bO!p#zO!q#zO#Z#yO~Ol!zOu$cO~Oc$eOl!zO!U$gO!P!Si!V!Si~P#kO!P!za!V!za~P&ZO!P$iO!V#dO~OcfO`#Wa~Oc$XO`#Xa~O`$lO~P#kOl!zOa!yXc!yXh!yXj!yXp!yX!P!yX!U!yX!V!yX#P!yX#Q!yX#Z!yX~Oc$eO!U$oO!P!Sq!V!Sq~P#kO`!xac!xa~P#kOl!zOa!yac!yah!yaj!yap!ya!P!ya!U!ya!V!ya#P!ya#Q!ya#Z!ya~Oq#Zl!Ol~", goto: "+}#^PPPP#_P#g#uP#g$T#gPP$ZPPP$aP$g$m$v$vP%YP$vP$v%p&SPP#gP&lP#gP&rP#gP#g#gPPP&x'['hPP#_PP'n'n'x'nP'nP'n'nP#_P#_P#_P'{#_P(O(RPP#_P#_(U(d(n(|)S)Y)d)jPPPPPP)p)xP*d*g*jP+`+i]`Obn!s#d$QiWObfklmn!s!t#V#d$QiQObfklmn!s!t#V#d$QQdRR!ceQrTR!ghQ!gsR#`!hQtTR!ihQ!gtQ!|!OR#`!iq!QXZz!u!w!z#b#c#k#r$O$X$^$e$f$jp!QXZz!u!w!z#b#c#k#r$O$X$^$e$f$jT#z#[#{q!OXZz!u!w!z#b#c#k#r$O$X$^$e$f$jp!QXZz!u!w!z#b#c#k#r$O$X$^$e$f$jQ![[R#Z!]QvUR!jiQxVR!kjQoSQ!fgQ#W!XQ#^!`Q#_!aR$`#zQ!rnQ#g!sQ$P#dR$h$QX!pn!s#d$Qa!WY^_|!S!U#R#SR#P!SR!][R!_]R#]!_QbOU!bb!s$QQ!snR$Q#dQgSS!eg$UR$U#hQ#k!uU$W#k$^$jQ$^#rR$j$XQ$Y#kR$k$YQ$f$OR$n$fQ#e!rS$R#e$TR$T#gQ#T!TR#v#TQ#{#[R$a#{]aObn!s#d$Q[SObn!s#d$QQ!dfQ!lkQ!mlQ!nmQ#h!tR#w#VR#i!tR#l!uQ|XQ!YZQ!xz[#j!u#k#r$X$^$jQ#m!wQ#o!zQ#}#bQ$O#cS$d$O$fR$m$eQ!XYQ!a_R!{|U!TY_|Q!`^Q#Q!SQ#U!UQ#t#RR#u#S", nodeNames: "⚠ Unit Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName not ) ( ArgList , PseudoClassName ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery callee MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList from to SupportsStatement supports AtRule", maxTerm: 105, nodeProps: [[mr.openedBy, 16, "(", 47, "{"], [mr.closedBy, 17, ")", 48, "}"]], skippedNodes: [0, 2], repeatNodeCount: 8, tokenData: "Bj~R![OX$wX^%]^p$wpq%]qr(crs+}st,otu2Uuv$wvw2rwx2}xy3jyz3uz{3z{|4_|}8u}!O9Q!O!P9i!P!Q9z!Q![<U![!]<y!]!^=i!^!_$w!_!`=t!`!a>P!a!b$w!b!c>o!c!}$w!}#O?{#O#P$w#P#Q@W#Q#R2U#R#T$w#T#U@c#U#c$w#c#dAb#d#o$w#o#pAq#p#q2U#q#rA|#r#sBX#s#y$w#y#z%]#z$f$w$f$g%]$g#BY$w#BY#BZ%]#BZ$IS$w$IS$I_%]$I_$I|$w$I|$JO%]$JO$JT$w$JT$JU%]$JU$KV$w$KV$KW%]$KW&FU$w&FU&FV%]&FV~$wW$zQOy%Qz~%QW%VQqWOy%Qz~%Q~%bf#S~OX%QX^&v^p%Qpq&vqy%Qz#y%Q#y#z&v#z$f%Q$f$g&v$g#BY%Q#BY#BZ&v#BZ$IS%Q$IS$I_&v$I_$I|%Q$I|$JO&v$JO$JT%Q$JT$JU&v$JU$KV%Q$KV$KW&v$KW&FU%Q&FU&FV&v&FV~%Q~&}f#S~qWOX%QX^&v^p%Qpq&vqy%Qz#y%Q#y#z&v#z$f%Q$f$g&v$g#BY%Q#BY#BZ&v#BZ$IS%Q$IS$I_&v$I_$I|%Q$I|$JO&v$JO$JT%Q$JT$JU&v$JU$KV%Q$KV$KW&v$KW&FU%Q&FU&FV&v&FV~%Q^(fSOy%Qz#]%Q#]#^(r#^~%Q^(wSqWOy%Qz#a%Q#a#b)T#b~%Q^)YSqWOy%Qz#d%Q#d#e)f#e~%Q^)kSqWOy%Qz#c%Q#c#d)w#d~%Q^)|SqWOy%Qz#f%Q#f#g*Y#g~%Q^*_SqWOy%Qz#h%Q#h#i*k#i~%Q^*pSqWOy%Qz#T%Q#T#U*|#U~%Q^+RSqWOy%Qz#b%Q#b#c+_#c~%Q^+dSqWOy%Qz#h%Q#h#i+p#i~%Q^+wQ!UUqWOy%Qz~%Q~,QUOY+}Zr+}rs,ds#O+}#O#P,i#P~+}~,iOj~~,lPO~+}_,tWsPOy%Qz!Q%Q!Q![-^![!c%Q!c!i-^!i#T%Q#T#Z-^#Z~%Q^-cWqWOy%Qz!Q%Q!Q![-{![!c%Q!c!i-{!i#T%Q#T#Z-{#Z~%Q^.QWqWOy%Qz!Q%Q!Q![.j![!c%Q!c!i.j!i#T%Q#T#Z.j#Z~%Q^.qWhUqWOy%Qz!Q%Q!Q![/Z![!c%Q!c!i/Z!i#T%Q#T#Z/Z#Z~%Q^/bWhUqWOy%Qz!Q%Q!Q![/z![!c%Q!c!i/z!i#T%Q#T#Z/z#Z~%Q^0PWqWOy%Qz!Q%Q!Q![0i![!c%Q!c!i0i!i#T%Q#T#Z0i#Z~%Q^0pWhUqWOy%Qz!Q%Q!Q![1Y![!c%Q!c!i1Y!i#T%Q#T#Z1Y#Z~%Q^1_WqWOy%Qz!Q%Q!Q![1w![!c%Q!c!i1w!i#T%Q#T#Z1w#Z~%Q^2OQhUqWOy%Qz~%QY2XSOy%Qz!_%Q!_!`2e!`~%QY2lQyQqWOy%Qz~%QX2wQWPOy%Qz~%Q~3QUOY2}Zw2}wx,dx#O2}#O#P3d#P~2}~3gPO~2}_3oQaVOy%Qz~%Q~3zO`~_4RSTPlSOy%Qz!_%Q!_!`2e!`~%Q_4fUlS!OPOy%Qz!O%Q!O!P4x!P!Q%Q!Q![7_![~%Q^4}SqWOy%Qz!Q%Q!Q![5Z![~%Q^5bWqW#ZUOy%Qz!Q%Q!Q![5Z![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%Q^6PWqWOy%Qz{%Q{|6i|}%Q}!O6i!O!Q%Q!Q![6z![~%Q^6nSqWOy%Qz!Q%Q!Q![6z![~%Q^7RSqW#ZUOy%Qz!Q%Q!Q![6z![~%Q^7fYqW#ZUOy%Qz!O%Q!O!P8U!P!Q%Q!Q![7_![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%Q^8]WqW#ZUOy%Qz!Q%Q!Q![8U![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%Q_8zQcVOy%Qz~%Q^9VUlSOy%Qz!O%Q!O!P4x!P!Q%Q!Q![7_![~%Q_9nS#VPOy%Qz!Q%Q!Q![5Z![~%Q~:PRlSOy%Qz{:Y{~%Q~:_SqWOy:Yyz:kz{;`{~:Y~:nROz:kz{:w{~:k~:zTOz:kz{:w{!P:k!P!Q;Z!Q~:k~;`OQ~~;eUqWOy:Yyz:kz{;`{!P:Y!P!Q;w!Q~:Y~<OQQ~qWOy%Qz~%Q^<ZY#ZUOy%Qz!O%Q!O!P8U!P!Q%Q!Q![7_![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%QX=OS[POy%Qz![%Q![!]=[!]~%QX=cQ]PqWOy%Qz~%Q_=nQ!VVOy%Qz~%QY=yQyQOy%Qz~%QX>US{POy%Qz!`%Q!`!a>b!a~%QX>iQ{PqWOy%Qz~%QX>rUOy%Qz!c%Q!c!}?U!}#T%Q#T#o?U#o~%QX?]Y!XPqWOy%Qz}%Q}!O?U!O!Q%Q!Q![?U![!c%Q!c!}?U!}#T%Q#T#o?U#o~%QX@QQwPOy%Qz~%Q^@]QuUOy%Qz~%QX@fSOy%Qz#b%Q#b#c@r#c~%QX@wSqWOy%Qz#W%Q#W#XAT#X~%QXA[Q!_PqWOy%Qz~%QXAeSOy%Qz#f%Q#f#gAT#g~%QXAvQ!QPOy%Qz~%Q_BRQ!PVOy%Qz~%QZB^S!OPOy%Qz!_%Q!_!`2e!`~%Q", tokenizers: [Gs, Qe, Bs, 0, 1, 2, 3], topRules: { StyleSheet: [0, 3] }, specialized: [{ term: 93, get: t => El[t] || -1 }, { term: 55, get: t => jl[t] || -1 }, { term: 94, get: t => Dl[t] || -1 }], tokenPrec: 1060 }); let Il = null; function Gl() { if (!Il && "object" == typeof document && document.body) { let t = []; for (var e in document.body.style) /[A-Z]|^-|^(item|length)$/.test(e) || t.push(e); Il = t.sort().map(t => ({ type: "property", label: t })) } return Il || [] } const Bl = ["active", "after", "before", "checked", "default", "disabled", "empty", "enabled", "first-child", "first-letter", "first-line", "first-of-type", "focus", "hover", "in-range", "indeterminate", "invalid", "lang", "last-child", "last-of-type", "link", "not", "nth-child", "nth-last-child", "nth-last-of-type", "nth-of-type", "only-of-type", "only-child", "optional", "out-of-range", "placeholder", "read-only", "read-write", "required", "root", "selection", "target", "valid", "visited"].map(t => ({ type: "class", label: t })), Nl = ["above", "absolute", "activeborder", "additive", "activecaption", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "antialiased", "appworkspace", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page", "avoid-region", "axis-pan", "background", "backwards", "baseline", "below", "bidi-override", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in", "destination-out", "destination-over", "difference", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic-abegede-gez", "ethiopic-halehame-aa-er", "ethiopic-halehame-gez", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fill-box", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from", "geometricPrecision", "graytext", "grid", "groove", "hand", "hard-light", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "horizontal", "hsl", "hsla", "hue", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "keep-all", "landscape", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lowercase", "ltr", "luminosity", "manipulation", "match", "matrix", "matrix3d", "medium", "menu", "menutext", "message-box", "middle", "min-intrinsic", "mix", "monospace", "move", "multiple", "multiple_mask_images", "multiply", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "perspective", "pinch-zoom", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position", "se-resize", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "start", "static", "status-bar", "stretch", "stroke", "stroke-box", "sub", "subpixel-antialiased", "svg_masks", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "text", "text-bottom", "text-top", "textarea", "textfield", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "to", "top", "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "unidirectional-pan", "unset", "up", "upper-latin", "uppercase", "url", "var", "vertical", "vertical-text", "view-box", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"].map(t => ({ type: "keyword", label: t })).concat(["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"].map(t => ({ type: "constant", label: t }))), Ul = ["a", "abbr", "address", "article", "aside", "b", "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "figcaption", "figure", "footer", "form", "header", "hgroup", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "meter", "nav", "ol", "output", "p", "pre", "ruby", "section", "select", "small", "source", "span", "strong", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "tr", "u", "ul"].map(t => ({ type: "type", label: t })), Fl = /^[\w-]*/; const Jl = Yr.define({ parser: Hl.configure({ props: [ns.add({ Declaration: hs() }), cs.add({ Block: Os }), Vo({ "import charset namespace keyframes": No.definitionKeyword, "media supports": No.controlKeyword, "from to": No.keyword, NamespaceName: No.namespace, KeyframeName: No.labelName, TagName: No.typeName, ClassName: No.className, PseudoClassName: No.constant(No.className), not: No.operatorKeyword, IdName: No.labelName, "FeatureName PropertyName AttributeName": No.propertyName, NumberLiteral: No.number, KeywordQuery: No.keyword, UnaryQueryOp: No.operatorKeyword, callee: No.keyword, "CallTag ValueName": No.atom, Callee: No.variableName, Unit: No.unit, "UniversalSelector NestingSelector": No.definitionOperator, AtKeyword: No.keyword, MatchOp: No.compareOperator, "ChildOp SiblingOp, LogicOp": No.logicOperator, BinOp: No.arithmeticOperator, Important: No.modifier, Comment: No.blockComment, ParenthesizedContent: No.special(No.name), ColorLiteral: No.color, StringLiteral: No.string, ":": No.punctuation, "PseudoOp #": No.derefOperator, "; ,": No.separator, "( )": No.paren, "[ ]": No.squareBracket, "{ }": No.brace })] }), languageData: { commentTokens: { block: { open: "/*", close: "*/" } }, indentOnInput: /^\s*\}$/ } }); Jl.data.of({ autocomplete: t => { let { state: e, pos: i } = t, n = Mr(e).resolve(i, -1); if ("PropertyName" == n.name) return { from: n.from, options: Gl(), span: Fl }; if ("ValueName" == n.name) return { from: n.from, options: Nl, span: Fl }; if ("PseudoClassName" == n.name) return { from: n.from, options: Bl, span: Fl }; if ("TagName" == n.name) { for (let { parent: t } = n; t; t = t.parent)if ("Block" == t.name) return { from: n.from, options: Gl(), span: Fl }; return { from: n.from, options: Ul, span: Fl } } if (!t.explicit) return null; let r = n.resolve(i), s = r.childBefore(i); return s && ":" == s.name && "PseudoClassSelector" == r.name ? { from: i, options: Bl, span: Fl } : s && ":" == s.name && "Declaration" == r.name || "ArgList" == r.name ? { from: i, options: Nl, span: Fl } : "Block" == r.name ? { from: i, options: Gl(), span: Fl } : null } }); const Kl = [10, 13, 8232, 8233], th = [9, 11, 12, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288]; function eh(e, i) { for (let t = i - 1; 0 <= t; t--) { var n = e.get(t); if (-1 < Kl.indexOf(n)) return 1; if (th.indexOf(n) < 0) break } } ro = new cl((t, e, i) => { var n = e.start, r = t.get(n); (125 == r || -1 == r || eh(t, n)) && i.canShift(273) && e.accept(273, e.start) }, { contextual: !0, fallback: !0 }), Gs = new cl((t, e, i) => { var n = e.start, r = t.get(n++); if (!(-1 < th.indexOf(r) || -1 < Kl.indexOf(r))) { if (47 == r) { n = t.get(+n); if (47 == n || 42 == n) return } 125 != r && 59 != r && -1 != r && !eh(t, e.start) && i.canShift(269) && e.accept(269, e.start) } }, { contextual: !0 }), Qe = new cl((t, e, i) => { var n = e.start, r = t.get(n); 43 != r && 45 != r || r != t.get(n + 1) || (i = !eh(t, e.start) && i.canShift(1), e.accept(i ? 1 : 2, n + 2)) }, { contextual: !0 }), Bs = new cl((t, e) => { let i = e.start, n = !1; for (; ;) { var r = t.get(i++); if (r < 0) { i - 1 > e.start && e.accept(270, i - 1); break } if (96 == r) { i == e.start + 1 ? e.accept(272, i) : e.accept(270, i - 1); break } if (123 == r && n) { i == e.start + 2 ? e.accept(271, i) : e.accept(270, i - 2); break } if (10 == r && i > e.start + 1) { e.accept(270, i); break } 92 == r && i != t.length && i++, n = 36 == r } }); const ih = { __proto__: null, export: 16, as: 21, from: 25, default: 30, async: 35, function: 36, this: 46, true: 54, false: 54, void: 58, typeof: 62, null: 76, super: 78, new: 112, await: 129, yield: 131, delete: 132, class: 142, extends: 144, public: 181, private: 181, protected: 181, readonly: 183, in: 202, instanceof: 204, const: 206, import: 238, keyof: 289, unique: 293, infer: 299, is: 333, abstract: 353, implements: 355, type: 357, let: 360, var: 362, interface: 369, enum: 373, namespace: 379, module: 381, declare: 385, global: 389, for: 410, of: 419, while: 422, with: 426, do: 430, if: 434, else: 436, switch: 440, case: 446, try: 452, catch: 454, finally: 456, return: 460, throw: 464, break: 468, continue: 472, debugger: 476 }, nh = { __proto__: null, async: 99, get: 101, set: 103, public: 151, private: 151, protected: 151, static: 153, abstract: 155, readonly: 159, new: 337 }, rh = { __proto__: null, "<": 119 }, sh = bl.deserialize({ version: 13, states: "$,lO]QYOOO&zQ!LdO'#CgO'ROSO'#DRO)ZQYO'#DWO)kQYO'#DcO)rQYO'#DmO-iQYO'#DsOOQO'#ET'#ETO-|QWO'#ESO.RQWO'#ESO0QQ!LdO'#IgO2hQ!LdO'#IhO3UQWO'#EqO3ZQpO'#FWOOQ!LS'#Ey'#EyO3cO!bO'#EyO3qQWO'#F_O4{QWO'#F^OOQ!LS'#Ih'#IhOOQ!LQ'#Ig'#IgOOQQ'#JR'#JRO5QQWO'#HeO5VQ!LYO'#HfOOQQ'#I['#I[OOQQ'#Hg'#HgQ]QYOOO)rQYO'#DeO5_QWO'#GRO5dQ#tO'#ClO5rQWO'#ERO5}Q#tO'#ExO6iQWO'#GRO6nQWO'#GVO6yQWO'#GVO7XQWO'#GYO7XQWO'#GZO7XQWO'#G]O5_QWO'#G`O7xQWO'#GcO9WQWO'#CcO9hQWO'#GpO9pQWO'#GvO9pQWO'#GxO]QYO'#GzO9pQWO'#G|O9pQWO'#HPO9uQWO'#HVO9zQ!LZO'#HZO)rQYO'#H]O:VQ!LZO'#H_O:bQ!LZO'#HaO5VQ!LYO'#HcO)rQYO'#IjOOOS'#Hh'#HhO:mOSO,59mOOQ!LS,59m,59mO=OQbO'#CgO=YQYO'#HiO=gQWO'#IlO?fQbO'#IlO'^QYO'#IlO?mQWO,59rO@TQ&jO'#D]O@|QWO'#ETOAZQWO'#IvOAfQWO'#IuOAnQWO,5:qOAsQWO'#ItOAzQWO'#DtO5dQ#tO'#EROBYQWO'#EROBeQ`O'#ExOOQ!LS,59},59}OBmQYO,59}ODkQ!LdO,5:XOEXQWO,5:_OErQ!LYO'#IsO6nQWO'#IrOEyQWO'#IrOFRQWO,5:pOFWQWO'#IrOFfQYO,5:nOHcQWO'#EPOIjQWO,5:nOJvQWO'#DgOJ}QYO'#DlOKXQ&jO,5:wO)rQYO,5:wOOQQ'#Ei'#EiOOQQ'#Ek'#EkO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xO)rQYO,5:xOOQQ'#Eo'#EoOK^QYO,5;YOOQ!LS,5;_,5;_OOQ!LS,5;`,5;`OMZQWO,5;`OOQ!LS,5;a,5;aO)rQYO'#HsOM`Q!LYO,5;zOMzQWO,5:xO)rQYO,5;]ONdQpO'#IzONRQpO'#IzONkQpO'#IzON|QpO,5;hOOQO,5;r,5;rO! [QYO'#FYOOOO'#Hr'#HrO3cO!bO,5;eO! cQpO'#F[OOQ!LS,5;e,5;eO!!PQ,UO'#CqOOQ!LS'#Ct'#CtO!!dQWO'#CtO!!zQ#tO,5;wO!#RQWO,5;yO!$[QWO'#FiO!$iQWO'#FjO!$nQWO'#FnO!%pQ&jO'#FrO!&cQ,UO'#IeOOQ!LS'#Ie'#IeO!&mQWO'#IdO!&{QWO'#IcOOQ!LS'#Cr'#CrOOQ!LS'#Cx'#CxO!'TQWO'#CzOIoQWO'#FaOIoQWO'#FcO!'YQWO'#FeOIeQWO'#FfO!'_QWO'#FlOIoQWO'#FqO!'dQWO'#EUO!'{QWO,5;xO]QYO,5>POOQQ'#I_'#I_OOQQ,5>Q,5>QOOQQ-E;e-E;eO!)wQ!LdO,5:POOQ!LQ'#Co'#CoO!*hQ#tO,5<mOOQO'#Ce'#CeO!*yQWO'#CpO!+RQ!LYO'#I`O4{QWO'#I`O9uQWO,59WO!+aQpO,59WO!+iQ#tO,59WO5dQ#tO,59WO!+tQWO,5:nO!+|QWO'#GoO!,UQWO'#JVO)rQYO,5;bOKXQ&jO,5;dO!,^QWO,5=YO!,cQWO,5=YO!,hQWO,5=YO5VQ!LYO,5=YO5_QWO,5<mO!,vQWO'#EVO!-XQ&jO'#EWOOQ!LQ'#It'#ItO!-jQ!LYO'#JSO5VQ!LYO,5<qO7XQWO,5<wOOQO'#Cq'#CqO!-uQpO,5<tO!-}Q#tO,5<uO!.YQWO,5<wO!._Q`O,5<zO9uQWO'#GeO5_QWO'#GgO!.gQWO'#GgO5dQ#tO'#GjO!.lQWO'#GjOOQQ,5<},5<}O!.qQWO'#GkO!.yQWO'#ClO!/OQWO,58}O!/YQWO,58}O!1XQYO,58}OOQQ,58},58}O!1fQ!LYO,58}O)rQYO,58}O!1qQYO'#GrOOQQ'#Gs'#GsOOQQ'#Gt'#GtO]QYO,5=[O!2RQWO,5=[O)rQYO'#DsO]QYO,5=bO]QYO,5=dO!2WQWO,5=fO]QYO,5=hO!2]QWO,5=kO!2bQYO,5=qOOQQ,5=u,5=uO)rQYO,5=uO5VQ!LYO,5=wOOQQ,5=y,5=yO!6`QWO,5=yOOQQ,5={,5={O!6`QWO,5={OOQQ,5=},5=}O!6eQ`O,5?UOOOS-E;f-E;fOOQ!LS1G/X1G/XO!6jQbO,5>TO)rQYO,5>TOOQO-E;g-E;gO!6tQWO,5?WO!6|QbO,5?WO!7TQWO,5?aOOQ!LS1G/^1G/^O!7]QpO'#DPOOQO'#In'#InO)rQYO'#InO!7zQpO'#InO!8iQpO'#D^O!8zQ&jO'#D^O!;SQYO'#D^O!;ZQWO'#ImO!;cQWO,59wO!;hQWO'#EXO!;vQWO'#IwO!<OQWO,5:rO!<fQ&jO'#D^O)rQYO,5?bO!<pQWO'#HnO!7TQWO,5?aOOQ!LQ1G0]1G0]O!=vQ&jO'#DwOOQ!LS,5:`,5:`O)rQYO,5:`OHcQWO,5:`O!=}QWO,5:`O9uQWO,5:mO!+aQpO,5:mO!+iQ#tO,5:mO5dQ#tO,5:mOOQ!LS1G/i1G/iOOQ!LS1G/y1G/yOOQ!LQ'#EO'#EOO)rQYO,5?_O!>YQ!LYO,5?_O!>kQ!LYO,5?_O!>rQWO,5?^O!>zQWO'#HpO!>rQWO,5?^OOQ!LQ1G0[1G0[O6nQWO,5?^OOQ!LS1G0Y1G0YO!?fQ!LdO1G0YO!@VQ!LbO,5:kOOQ!LS'#Fh'#FhO!@sQ!LdO'#IeOFfQYO1G0YO!BrQ#tO'#IoO!B|QWO,5:RO!CRQbO'#IpO)rQYO'#IpO!C]QWO,5:WOOQ!LS'#DP'#DPOOQ!LS1G0c1G0cO!CbQWO1G0cO!EsQ!LdO1G0dO!EzQ!LdO1G0dO!H_Q!LdO1G0dO!HfQ!LdO1G0dO!JmQ!LdO1G0dO!KQQ!LdO1G0dO!MqQ!LdO1G0dO!MxQ!LdO1G0dO#!]Q!LdO1G0dO#!dQ!LdO1G0dO#$XQ!LdO1G0dO#'RQ7^O'#CgO#(|Q7^O1G0tO#*wQ7^O'#IhOOQ!LS1G0z1G0zO#+[Q!LdO,5>_OOQ!LQ-E;q-E;qO#+{Q!LdO1G0dOOQ!LS1G0d1G0dO#-}Q!LdO1G0wO#.nQpO,5;jO#.sQpO,5;kO#.xQpO'#FRO#/^QWO'#FQOOQO'#I{'#I{OOQO'#Hq'#HqO#/cQpO1G1SOOQ!LS1G1S1G1SOOQO1G1]1G1]O#/qQ7^O'#IgO#/{QWO,5;tOK^QYO,5;tOOOO-E;p-E;pOOQ!LS1G1P1G1POOQ!LS,5;v,5;vO#0QQpO,5;vOOQ!LS,59`,59`O)rQYO1G1cOKXQ&jO'#HuO#0VQWO,5<[OOQ!LS,5<X,5<XOOQO'#F|'#F|OIoQWO,5<gOOQO'#GO'#GOOIoQWO,5<iOIoQWO,5<kOOQO1G1e1G1eO#0bQ`O'#CoO#0uQ`O,5<TO#0|QWO'#JOO5_QWO'#JOO#1[QWO,5<VOIoQWO,5<UO#1aQ`O'#FhO#1nQ`O'#JPO#1xQWO'#JPOHcQWO'#JPO#1}QWO,5<YOOQ!LQ'#Db'#DbO#2SQWO'#FkO#2_QpO'#FsO!%kQ&jO'#FsO!%kQ&jO'#FuO#2pQWO'#FvO!'_QWO'#FyOOQO'#Hw'#HwO#2uQ&jO,5<^OOQ!LS,5<^,5<^O#2|Q&jO'#FsO#3[Q&jO'#FtO#3dQ&jO'#FtOOQ!LS,5<l,5<lOIoQWO,5?OOIoQWO,5?OO#3iQWO'#HxO#3tQWO,5>}OOQ!LS'#Cg'#CgO#4hQ#tO,59fOOQ!LS,59f,59fO#5ZQ#tO,5;{O#5|Q#tO,5;}O#6WQWO,5<POOQ!LS,5<Q,5<QO#6]QWO,5<WO#6bQ#tO,5<]OFfQYO1G1dO#6rQWO1G1dOOQQ1G3k1G3kOOQ!LS1G/k1G/kOMZQWO1G/kOOQQ1G2X1G2XOHcQWO1G2XO)rQYO1G2XOHcQWO1G2XO#6wQWO1G2XO#7VQWO,59[O#8]QWO'#EPOOQ!LQ,5>z,5>zO#8gQ!LYO,5>zOOQQ1G.r1G.rO9uQWO1G.rO!+aQpO1G.rO!+iQ#tO1G.rO#8uQWO1G0YO#8zQWO'#CgO#9VQWO'#JWO#9_QWO,5=ZO#9dQWO'#JWO#9iQWO'#IQO#9wQWO,5?qO#:PQbO1G0|OOQ!LS1G1O1G1OO5_QWO1G2tO#:WQWO1G2tO#:]QWO1G2tO#:bQWO1G2tOOQQ1G2t1G2tO#:gQ#tO1G2XO6nQWO'#IuO6nQWO'#EXO6nQWO'#HzO#:xQ!LYO,5?nOOQQ1G2]1G2]O!.YQWO1G2cOHcQWO1G2`O#;TQWO1G2`OOQQ1G2a1G2aOHcQWO1G2aO#;YQWO1G2aO#;bQ&jO'#G_OOQQ1G2c1G2cO!%kQ&jO'#H|O!._Q`O1G2fOOQQ1G2f1G2fOOQQ,5=P,5=PO#;jQ#tO,5=RO5_QWO,5=RO#2pQWO,5=UO4{QWO,5=UO!+aQpO,5=UO!+iQ#tO,5=UO5dQ#tO,5=UO#;{QWO'#JUO#<WQWO,5=VOOQQ1G.i1G.iO#<]Q!LYO1G.iO#<hQWO1G.iO!'TQWO1G.iO5VQ!LYO1G.iO#<mQbO,5?sO#<wQWO,5?sO#=SQYO,5=^O#=ZQWO,5=^O6nQWO,5?sOOQQ1G2v1G2vO]QYO1G2vOOQQ1G2|1G2|OOQQ1G3O1G3OO9pQWO1G3QO#=`QYO1G3SO#AWQYO'#HROOQQ1G3V1G3VO9uQWO1G3]O#AeQWO1G3]O5VQ!LYO1G3aOOQQ1G3c1G3cOOQ!LQ'#Fo'#FoO5VQ!LYO1G3eO5VQ!LYO1G3gOOOS1G4p1G4pO#AmQ`O,5;zO#AuQbO1G3oO#BPQWO1G4rO#BXQWO1G4{O#BaQWO,5?YOK^QYO,5:sO6nQWO,5:sO9uQWO,59xOK^QYO,59xO!+aQpO,59xO#BfQ7^O,59xOOQO,5:s,5:sO#BpQ&jO'#HjO#CWQWO,5?XOOQ!LS1G/c1G/cO#C`Q&jO'#HoO#CtQWO,5?cOOQ!LQ1G0^1G0^O!8zQ&jO,59xO#C|QbO1G4|OOQO,5>Y,5>YO6nQWO,5>YOOQO-E;l-E;lO#DWQ!LrO'#D|O!%kQ&jO'#DxOOQO'#Hm'#HmO#DrQ&jO,5:cOOQ!LS,5:c,5:cO#DyQ&jO'#DxO#EXQ&jO'#D|O#EmQ&jO'#D|O!%kQ&jO'#D|O#EwQWO1G/zO#E|Q`O1G/zOOQ!LS1G/z1G/zO)rQYO1G/zOHcQWO1G/zOOQ!LS1G0X1G0XO9uQWO1G0XO!+aQpO1G0XO!+iQ#tO1G0XO#FTQ!LdO1G4yO)rQYO1G4yO#FeQ!LYO1G4yO#FvQWO1G4xO6nQWO,5>[OOQO,5>[,5>[O#GOQWO,5>[OOQO-E;n-E;nO#FvQWO1G4xO#G^Q!LdO,59fO#I]Q!LdO,5;{O#K_Q!LdO,5;}O#MaQ!LdO,5<]OOQ!LS7+%t7+%tO$ iQ!LdO7+%tO$!YQWO'#HkO$!dQWO,5?ZOOQ!LS1G/m1G/mO$!lQYO'#HlO$!yQWO,5?[O$#RQbO,5?[OOQ!LS1G/r1G/rOOQ!LS7+%}7+%}O$#]Q7^O,5:XO)rQYO7+&`O$#gQ7^O,5:POOQO1G1U1G1UOOQO1G1V1G1VO$#tQMhO,5;mOK^QYO,5;lOOQO-E;o-E;oOOQ!LS7+&n7+&nOOQO7+&w7+&wOOOO1G1`1G1`O$$PQWO1G1`OOQ!LS1G1b1G1bO$$UQ!LdO7+&}OOQ!LS,5>a,5>aO$$uQWO,5>aOOQ!LS1G1v1G1vP$$zQWO'#HuPOQ!LS-E;s-E;sO$%kQ#tO1G2RO$&^Q#tO1G2TO$&hQ#tO1G2VOOQ!LS1G1o1G1oO$&oQWO'#HtO$&}QWO,5?jO$&}QWO,5?jO$'VQWO,5?jO$'bQWO,5?jOOQO1G1q1G1qO$'pQ#tO1G1pO$(QQWO'#HvO$(bQWO,5?kOHcQWO,5?kO$(jQ`O,5?kOOQ!LS1G1t1G1tO5VQ!LYO,5<_O5VQ!LYO,5<`O$(tQWO,5<`O#2kQWO,5<`O!+aQpO,5<_O$(yQWO,5<aO5VQ!LYO,5<bO$(tQWO,5<eOOQO-E;u-E;uOOQ!LS1G1x1G1xO!%kQ&jO,5<_O$)RQWO,5<`O!%kQ&jO,5<aO!%kQ&jO,5<`O$)^Q#tO1G4jO$)hQ#tO1G4jOOQO,5>d,5>dOOQO-E;v-E;vOKXQ&jO,59hO)rQYO,59hO$)uQWO1G1kOIoQWO1G1rO$)zQ!LdO7+'OOOQ!LS7+'O7+'OOFfQYO7+'OOOQ!LS7+%V7+%VO$*kQ`O'#JQO#EwQWO7+'sO$*uQWO7+'sO$*}Q`O7+'sOOQQ7+'s7+'sOHcQWO7+'sO)rQYO7+'sOHcQWO7+'sOOQO1G.v1G.vO$+XQ!LbO'#CgO$+iQ!LbO,5<cO$,WQWO,5<cOOQ!LQ1G4f1G4fOOQQ7+$^7+$^O9uQWO7+$^O!+aQpO7+$^OFfQYO7+%tO$,]QWO'#IPO$,hQWO,5?rOOQO1G2u1G2uO5_QWO,5?rOOQO,5>l,5>lOOQO-E<O-E<OOOQ!LS7+&h7+&hO$,pQWO7+(`O5VQ!LYO7+(`O5_QWO7+(`O$,uQWO7+(`O$,zQWO7+'sOOQ!LQ,5>f,5>fOOQ!LQ-E;x-E;xOOQQ7+'}7+'}O$-YQ!LbO7+'zOHcQWO7+'zO$-dQ`O7+'{OOQQ7+'{7+'{OHcQWO7+'{O$-kQWO'#JTO$-vQWO,5<yOOQO,5>h,5>hOOQO-E;z-E;zOOQQ7+(Q7+(QO$.mQ&jO'#GhOOQQ1G2m1G2mOHcQWO1G2mO)rQYO1G2mOHcQWO1G2mO$.tQWO1G2mO$/SQ#tO1G2mO5VQ!LYO1G2pO#2pQWO1G2pO4{QWO1G2pO!+aQpO1G2pO!+iQ#tO1G2pO$/eQWO'#IOO$/pQWO,5?pO$/xQ&jO,5?pOOQ!LQ1G2q1G2qOOQQ7+$T7+$TO$/}QWO7+$TO5VQ!LYO7+$TO$0SQWO7+$TO)rQYO1G5_O)rQYO1G5`O$0XQYO1G2xO$0`QWO1G2xO$0eQYO1G2xO$0lQ!LYO1G5_OOQQ7+(b7+(bO5VQ!LYO7+(lO]QYO7+(nOOQQ'#JZ'#JZOOQQ'#IR'#IRO$0vQYO,5=mOOQQ,5=m,5=mO)rQYO'#HSO$1TQWO'#HUOOQQ7+(w7+(wO$1YQYO7+(wO6nQWO7+(wOOQQ7+({7+({OOQQ7+)P7+)POOQQ7+)R7+)ROOQO1G4t1G4tO$5TQ7^O1G0_O$5_QWO1G0_OOQO1G/d1G/dO$5jQ7^O1G/dO9uQWO1G/dOK^QYO'#D^OOQO,5>U,5>UOOQO-E;h-E;hOOQO,5>Z,5>ZOOQO-E;m-E;mO!+aQpO1G/dOOQO1G3t1G3tO9uQWO,5:dOOQO,5:h,5:hO)rQYO,5:hO$5tQ!LYO,5:hO$6PQ!LYO,5:hO!+aQpO,5:dOOQO-E;k-E;kOOQ!LS1G/}1G/}O!%kQ&jO,5:dO$6_Q!LrO,5:hO$6yQ&jO,5:dO!%kQ&jO,5:hO$7XQ&jO,5:hO$7mQ!LYO,5:hOOQ!LS7+%f7+%fO#EwQWO7+%fO#E|Q`O7+%fOOQ!LS7+%s7+%sO9uQWO7+%sO!+aQpO7+%sO$8RQ!LdO7+*eO)rQYO7+*eOOQO1G3v1G3vO6nQWO1G3vO$8cQWO7+*dO$8kQ!LdO1G2RO$:mQ!LdO1G2TO$<oQ!LdO1G1pO$>wQ#tO,5>VOOQO-E;i-E;iO$?RQbO,5>WO)rQYO,5>WOOQO-E;j-E;jO$?]QWO1G4vO$?eQ7^O1G0YO$AlQ7^O1G0dO$AsQ7^O1G0dO$CtQ7^O1G0dO$C{Q7^O1G0dO$EpQ7^O1G0dO$FTQ7^O1G0dO$HbQ7^O1G0dO$HiQ7^O1G0dO$JjQ7^O1G0dO$JqQ7^O1G0dO$LfQ7^O1G0dO$LyQ!LdO<<IzO$MjQ7^O1G0dO% YQ7^O'#IeO%#VQ7^O1G0wOK^QYO'#FTOOQO'#I|'#I|OOQO1G1X1G1XO%#dQWO1G1WO%#iQ7^O,5>_OOOO7+&z7+&zOOQ!LS1G3{1G3{OIoQWO7+'qO%#sQWO,5>`O5_QWO,5>`OOQO-E;r-E;rO%$RQWO1G5UO%$RQWO1G5UO%$ZQWO1G5UO%$fQ`O,5>bO%$pQWO,5>bOHcQWO,5>bOOQO-E;t-E;tO%$uQ`O1G5VO%%PQWO1G5VOOQO1G1y1G1yOOQO1G1z1G1zO5VQ!LYO1G1zO$(tQWO1G1zO5VQ!LYO1G1yO%%XQWO1G1{OHcQWO1G1{OOQO1G1|1G1|O5VQ!LYO1G2PO!+aQpO1G1yO#2kQWO1G1zO%%^QWO1G1{O%%fQWO1G1zOIoQWO7+*UOOQ!LS1G/S1G/SO%%qQWO1G/SOOQ!LS7+'V7+'VO%%vQ#tO7+'^O%&WQ!LdO<<JjOOQ!LS<<Jj<<JjOHcQWO'#HyO%&wQWO,5?lOOQQ<<K_<<K_OHcQWO<<K_O#EwQWO<<K_O%'PQWO<<K_O%'XQ`O<<K_OHcQWO1G1}OOQQ<<Gx<<GxO9uQWO<<GxO%'cQ!LdO<<I`OOQ!LS<<I`<<I`OOQO,5>k,5>kO%(SQWO,5>kOOQO-E;}-E;}O%(XQWO1G5^O%(aQWO<<KzOOQQ<<Kz<<KzO%(fQWO<<KzO5VQ!LYO<<KzO)rQYO<<K_OHcQWO<<K_OOQQ<<Kf<<KfO$-YQ!LbO<<KfOOQQ<<Kg<<KgO$-dQ`O<<KgO%(kQ&jO'#H{O%(vQWO,5?oOK^QYO,5?oOOQQ1G2e1G2eO#DWQ!LrO'#D|O!%kQ&jO'#GiOOQO'#H}'#H}O%)OQ&jO,5=SOOQQ,5=S,5=SO#3[Q&jO'#D|O%)VQ&jO'#D|O%)kQ&jO'#D|O%)uQ&jO'#GiO%*TQWO7+(XO%*YQWO7+(XO%*bQ`O7+(XOOQQ7+(X7+(XOHcQWO7+(XO)rQYO7+(XOHcQWO7+(XO%*lQWO7+(XOOQQ7+([7+([O5VQ!LYO7+([O#2pQWO7+([O4{QWO7+([O!+aQpO7+([O%*zQWO,5>jOOQO-E;|-E;|OOQO'#Gl'#GlO%+VQWO1G5[O5VQ!LYO<<GoOOQQ<<Go<<GoO%+_QWO<<GoO%+dQWO7+*yO%+iQWO7+*zOOQQ7+(d7+(dO%+nQWO7+(dO%+sQYO7+(dO%+zQWO7+(dO)rQYO7+*yO)rQYO7+*zOOQQ<<LW<<LWOOQQ<<LY<<LYOOQQ-E<P-E<POOQQ1G3X1G3XO%,PQWO,5=nOOQQ,5=p,5=pO9uQWO<<LcO%,UQWO<<LcOK^QYO7+%yOOQO7+%O7+%OO%,ZQ7^O1G4|O9uQWO7+%OOOQO1G0O1G0OO%,eQ!LdO1G0SOOQO1G0S1G0SO)rQYO1G0SO%,oQ!LYO1G0SO9uQWO1G0OO!+aQpO1G0OO%,zQ!LYO1G0SO!%kQ&jO1G0OO%-YQ!LYO1G0SO%-nQ!LrO1G0SO%-xQ&jO1G0OO!%kQ&jO1G0SOOQ!LS<<IQ<<IQOOQ!LS<<I_<<I_O9uQWO<<I_O%.WQ!LdO<<NPOOQO7+)b7+)bO%.hQ!LdO7+'^O%0pQbO1G3rO%0zQ7^O7+%tO%1XQ7^O,59fO%3UQ7^O,5;{O%5RQ7^O,5;}O%7OQ7^O,5<]O%8nQ7^O7+&}O%8{Q7^O7+'OO%9YQWO,5;oOOQO7+&r7+&rO%9_Q#tO<<K]OOQO1G3z1G3zO%9oQWO1G3zO%9zQWO1G3zO%:YQWO7+*pO%:YQWO7+*pOHcQWO1G3|O%:bQ`O1G3|O%:lQWO7+*qOOQO7+'f7+'fO5VQ!LYO7+'fOOQO7+'e7+'eO$(tQWO7+'gO%:tQ`O7+'gOOQO7+'k7+'kO5VQ!LYO7+'eO$(tQWO7+'fO%:{QWO7+'gOHcQWO7+'gO#2kQWO7+'fO%;QQ#tO<<MpOOQ!LS7+$n7+$nO%;[Q`O,5>eOOQO-E;w-E;wO#EwQWOAN@yOOQQAN@yAN@yOHcQWOAN@yO%;fQ!LbO7+'iOOQQAN=dAN=dO5_QWO1G4VO%;sQWO7+*xO5VQ!LYOANAfO%;{QWOANAfOOQQANAfANAfO%<QQWOAN@yO%<YQ`OAN@yOOQQANAQANAQOOQQANARANARO%<dQWO,5>gOOQO-E;y-E;yO%<oQ7^O1G5ZO#2pQWO,5=TO4{QWO,5=TO!+aQpO,5=TOOQO-E;{-E;{OOQQ1G2n1G2nO$6_Q!LrO,5:hO!%kQ&jO,5=TO%<yQ&jO,5=TO%=XQ&jO,5:hOOQQ<<Ks<<KsOHcQWO<<KsO%*TQWO<<KsO%=mQWO<<KsO%=uQ`O<<KsO)rQYO<<KsOHcQWO<<KsOOQQ<<Kv<<KvO5VQ!LYO<<KvO#2pQWO<<KvO4{QWO<<KvO%>PQ&jO1G4UO%>UQWO7+*vOOQQAN=ZAN=ZO5VQ!LYOAN=ZOOQQ<<Ne<<NeOOQQ<<Nf<<NfOOQQ<<LO<<LOO%>^QWO<<LOO%>cQYO<<LOO%>jQWO<<NeO%>oQWO<<NfOOQQ1G3Y1G3YOOQQANA}ANA}O9uQWOANA}O%>tQ7^O<<IeOOQO<<Hj<<HjOOQO7+%n7+%nO%,eQ!LdO7+%nO)rQYO7+%nOOQO7+%j7+%jO9uQWO7+%jO%?OQ!LYO7+%nO!+aQpO7+%jO%?ZQ!LYO7+%nO!%kQ&jO7+%jO%?iQ!LYO7+%nOOQ!LSAN>yAN>yO%?}Q!LdO<<K]O%BVQ7^O<<IzO%BdQ7^O1G1pO%DSQ7^O1G2RO%FPQ7^O1G2TO%G|Q7^O<<JjO%HZQ7^O<<I`OOQO1G1Z1G1ZOOQO7+)f7+)fO%HhQWO7+)fO%HsQWO<<N[O%H{Q`O7+)hOOQO<<KQ<<KQO5VQ!LYO<<KRO$(tQWO<<KROOQO<<KP<<KPO5VQ!LYO<<KQO%IVQ`O<<KRO$(tQWO<<KQOOQQG26eG26eO#EwQWOG26eOOQO7+)q7+)qOOQQG27QG27QO5VQ!LYOG27QOHcQWOG26eOK^QYO1G4RO%I^QWO7+*uO5VQ!LYO1G2oO#2pQWO1G2oO4{QWO1G2oO!+aQpO1G2oO!%kQ&jO1G2oO%-nQ!LrO1G0SO%IfQ&jO1G2oO%*TQWOANA_OOQQANA_ANA_OHcQWOANA_O%ItQWOANA_O%I|Q`OANA_OOQQANAbANAbO5VQ!LYOANAbO#2pQWOANAbOOQO'#Gm'#GmOOQO7+)p7+)pOOQQG22uG22uOOQQANAjANAjO%JWQWOANAjOOQQANDPANDPOOQQANDQANDQO%J]QYOG27iOOQO<<IY<<IYO%,eQ!LdO<<IYOOQO<<IU<<IUO)rQYO<<IYO9uQWO<<IUO%NWQ!LYO<<IYO!+aQpO<<IUO%NcQ!LYO<<IYO%NqQ7^O7+'^OOQO<<MQ<<MQOOQOAN@mAN@mO5VQ!LYOAN@mOOQOAN@lAN@lO$(tQWOAN@mO5VQ!LYOAN@lOOQQLD,PLD,POOQQLD,lLD,lO#EwQWOLD,PO&!aQ7^O7+)mOOQO7+(Z7+(ZO5VQ!LYO7+(ZO#2pQWO7+(ZO4{QWO7+(ZO!+aQpO7+(ZO!%kQ&jO7+(ZOOQQG26yG26yO%*TQWOG26yOHcQWOG26yOOQQG26|G26|O5VQ!LYOG26|OOQQG27UG27UO9uQWOLD-TOOQOAN>tAN>tO%,eQ!LdOAN>tOOQOAN>pAN>pO)rQYOAN>tO9uQWOAN>pO&!kQ!LYOAN>tO&!vQ7^O<<K]OOQOG26XG26XO5VQ!LYOG26XOOQOG26WG26WOOQQ!$( k!$( kOOQO<<Ku<<KuO5VQ!LYO<<KuO#2pQWO<<KuO4{QWO<<KuO!+aQpO<<KuOOQQLD,eLD,eO%*TQWOLD,eOOQQLD,hLD,hOOQQ!$(!o!$(!oOOQOG24`G24`O%,eQ!LdOG24`OOQOG24[G24[O)rQYOG24`OOQOLD+sLD+sOOQOANAaANAaO5VQ!LYOANAaO#2pQWOANAaO4{QWOANAaOOQQ!$(!P!$(!POOQOLD)zLD)zO%,eQ!LdOLD)zOOQOG26{G26{O5VQ!LYOG26{O#2pQWOG26{OOQO!$'Mf!$'MfOOQOLD,gLD,gO5VQ!LYOLD,gOOQO!$(!R!$(!ROK^QYO'#DmO&$fQbO'#IgOK^QYO'#DeO&$mQ!LdO'#CgO&%WQbO'#CgO&%hQYO,5:nOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO,5:xOK^QYO'#HsO&'eQWO,5;zO&(tQWO,5:xOK^QYO,5;]O!'TQWO'#CzO!'TQWO'#CzOHcQWO'#FaO&'mQWO'#FaOHcQWO'#FcO&'mQWO'#FcOHcQWO'#FqO&'mQWO'#FqOK^QYO,5?bO&%hQYO1G0YO&({Q7^O'#CgOK^QYO1G1cOHcQWO,5<gO&'mQWO,5<gOHcQWO,5<iO&'mQWO,5<iOHcQWO,5<UO&'mQWO,5<UO&%hQYO1G1dOK^QYO7+&`OHcQWO1G1rO&'mQWO1G1rO&%hQYO7+'OO&%hQYO7+%tOHcQWO7+'qO&'mQWO7+'qO&)VQWO'#ESO&)[QWO'#ESO&)dQWO'#EqO&)iQWO'#IvO&)tQWO'#ItO&*PQWO,5:nO&*UQ#tO,5;wO&*]QWO'#FjO&*bQWO'#FjO&*gQWO,5;xO&*oQWO,5:nO&*wQ7^O1G0tO&+OQWO,5<WO&+TQWO,5<WO&+YQWO1G1dO&+_QWO1G0YO&+dQ#tO1G2VO&+kQ#tO1G2VO3qQWO'#F_O4{QWO'#F^OBYQWO'#EROK^QYO,5;YO!'_QWO'#FlO!'_QWO'#FlOIoQWO,5<kOIoQWO,5<k", stateData: "&,e~O&}OSSOSTOS~OPTOQTOWwO]bO^gOamOblOgbOiTOjbOkbOmTOoTOtROvbOwbOxbO!OSO!YjO!_UO!bTO!cTO!dTO!eTO!fTO!ikO#ZqO#knO#o]O$voO$xrO$zpO${pO%OsO%QtO%TuO%UuO%WvO%exO%kyO%mzO%o{O%q|O%t}O%z!OO&O!PO&Q!QO&S!RO&U!SO&W!TO'PPO']QO'q`O~OPZXYZX^ZXiZXqZXrZXtZX|ZX![ZX!]ZX!_ZX!eZX!tZX#OcX#RZX#SZX#TZX#UZX#VZX#WZX#XZX#YZX#[ZX#^ZX#`ZX#aZX#fZX&{ZX']ZX'eZX'lZX'mZX~O!W$cX~P$tO&x!VO&y!UO&z!XO~OPTOQTO]bOa!hOb!gOgbOiTOjbOkbOmTOoTOtROvbOwbOxbO!O!`O!YjO!_UO!bTO!cTO!dTO!eTO!fTO!i!fO#k!iO#o]O'P!YO']QO'q`O~O{!^O|!ZOy'`Py'iP~P'^O}!jO~P]OPTOQTO]bOa!hOb!gOgbOiTOjbOkbOmTOoTOtROvbOwbOxbO!O!`O!YjO!_UO!bTO!cTO!dTO!eTO!fTO!i!fO#k!iO#o]O'P8cO']QO'q`O~OPTOQTO]bOa!hOb!gOgbOiTOjbOkbOmTOoTOtROvbOwbOxbO!O!`O!YjO!_UO!bTO!cTO!dTO!eTO!fTO!i!fO#k!iO#o]O']QO'q`O~O{!oO!|!rO!}!oO'P8dO!^'fP~P+oO#O!sO~O!W!tO#O!sO~OP#ZOY#aOi#OOq!xOr!xOt!yO|#_O![#QO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO#W#QO#X#QO#Y#QO#[#RO#^#TO#`#VO#a#WO']QO'e#XO'l!zO'm!{O~O^'ZX&{'ZX!^'ZXy'ZX!O'ZX$w'ZX!W'ZX~P.ZO!t#bO#f#bOP'[XY'[X^'[Xi'[Xq'[Xr'[Xt'[X|'[X!['[X!]'[X!_'[X!e'[X#R'[X#S'[X#T'[X#U'[X#V'[X#W'[X#Y'[X#['[X#^'[X#`'[X#a'[X']'[X'e'[X'l'[X'm'[X~O#X'[X&{'[Xy'[X!^'[X'_'[X!O'[X$w'[X!W'[X~P0kO!t#bO~O#q#cO#x#gO~O!O#hO#o]O#{#iO#}#kO~O]#nOg#zOi#oOj#nOk#nOm#{Oo#|Ot#tO!O#uO!Y$RO!_#rO!}$SO#k$PO$U#}O$W$OO$Z$QO'P#mO'T'VP~O!_$TO~O!W$VO~O^$WO&{$WO~O'P$[O~O!_$TO'P$[O'Q$^O'U$_O~Ob$eO!_$TO'P$[O~O]$nOq$jO!O$gO!_$iO$x$mO'P$[O'Q$^O['yP~O!i$oO~Ot$pO!O$qO'P$[O~Ot$pO!O$qO%Q$uO'P$[O~O'P$vO~O#ZqO$xrO$zpO${pO%OsO%QtO%TuO%UuO~Oa%POb%OO!i$|O$v$}O%Y${O~P7^Oa%SOblO!O%RO!ikO#ZqO$voO$zpO${pO%OsO%QtO%TuO%UuO%WvO~O_%VO!t%YO$x%TO'Q$^O~P8]O!_%ZO!b%_O~O!_%`O~O!OSO~O^$WO&w%hO&{$WO~O^$WO&w%kO&{$WO~O^$WO&w%mO&{$WO~O&x!VO&y!UO&z%qO~OPZXYZXiZXqZXrZXtZX|ZX|cX![ZX!]ZX!_ZX!eZX!tZX!tcX#OcX#RZX#SZX#TZX#UZX#VZX#WZX#XZX#YZX#[ZX#^ZX#`ZX#aZX#fZX']ZX'eZX'lZX'mZX~OyZXycX~P:xO{%sOy&]X|&]X~P)rO|!ZOy'`X~OP#ZOY#aOi#OOq!xOr!xOt!yO|!ZO![#QO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO#W#QO#X#QO#Y#QO#[#RO#^#TO#`#VO#a#WO']QO'e#XO'l!zO'm!{O~Oy'`X~P=oOy%xO~Ot%{O!R&VO!S&OO!T&OO'Q$^O~O]%|Oj%|O{&PO'Y%yO}'aP}'kP~P?rOy'hX|'hX!W'hX!^'hX'e'hX~O!t'hX#O!wX}'hX~P@kO!t&WOy'jX|'jX~O|&XOy'iX~Oy&ZO~O!t#bO~P@kOR&_O!O&[O!j&^O'P$[O~Ob&dO!_$TO'P$[O~Oq$jO!_$iO~O}&eO~P]Oq!xOr!xOt!yO!]!vO!_!wO']QOP!aaY!aai!aa|!aa![!aa!e!aa#R!aa#S!aa#T!aa#U!aa#V!aa#W!aa#X!aa#Y!aa#[!aa#^!aa#`!aa#a!aa'e!aa'l!aa'm!aa~O^!aa&{!aay!aa!^!aa'_!aa!O!aa$w!aa!W!aa~PBtO!^&fO~O!W!tO!t&hO'e&gO|'gX^'gX&{'gX~O!^'gX~PE^O|&lO!^'fX~O!^&nO~Ot$pO!O$qO!}&oO'P$[O~OPTOQTO]bOa!hOb!gOgbOiTOjbOkbOmTOoTOtROvbOwbOxbO!OSO!YjO!_UO!bTO!cTO!dTO!eTO!fTO!i!fO#k!iO#o]O'P8cO']QO'q`O~O]#nOg#zOi#oOj#nOk#nOm#{Oo8uOt#tO!O#uO!Y9wO!_#rO!}8{O#k$PO$U8wO$W8yO$Z$QO'P&sO~O#O&uO~O]#nOg#zOi#oOj#nOk#nOm#{Oo#|Ot#tO!O#uO!Y$RO!_#rO!}$SO#k$PO$U#}O$W$OO$Z$QO'P&sO~O'T'cP~PIoO{&yO!^'dP~P)rO'Y&{O~OP8`OQ8`O]bOa9uOb!gOgbOi8`OjbOkbOm8`Oo8`OtROvbOwbOxbO!O!`O!Y8bO!_UO!b8`O!c8`O!d8`O!e8`O!f8`O!i!fO#k!iO#o]O'P'ZO']QO'q9sO~O!_!wO~O|#_O^$Sa&{$Sa!^$Say$Sa!O$Sa$w$Sa!W$Sa~O#Z'bO~PHcO!W'dO!O'nX#n'nX#q'nX#x'nX~Oq'eO~PNROq'eO!O'nX#n'nX#q'nX#x'nX~O!O'gO#n'kO#q'fO#x'lO~O{'oO~PK^O#q#cO#x'rO~Oq$[Xt$[X!]$[X'e$[X'l$[X'm$[X~OReX|eX!teX'TeX'T$[X~P! kOj'tO~Oq'vOt'wO'e#XO'l'yO'm'{O~O'T'uO~P!!iO'T(OO~O]#nOg#zOi#oOj#nOk#nOm#{Oo8uOt#tO!O#uO!Y9wO!_#rO!}8{O#k$PO$U8wO$W8yO$Z$QO~O{(SO'P(PO!^'rP~P!#WO#O(UO~O{(YO'P(VOy'sP~P!#WO^(cOi(hOt(`O!R(fO!S(_O!T(_O!_(]O!q(gO$n(bO'Q$^O'Y([O~O}(eO~P!${O!]!vOq'XXt'XX'e'XX'l'XX'm'XX|'XX!t'XX~O'T'XX#d'XX~P!%wOR(kO!t(jO|'WX'T'WX~O|(lO'T'VX~O'P(nO~O!_(sO~O!_(]O~Ot$pO{!oO!O$qO!|!rO!}!oO'P$[O!^'fP~O!W!tO#O(wO~OP#ZOY#aOi#OOq!xOr!xOt!yO![#QO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO#W#QO#X#QO#Y#QO#[#RO#^#TO#`#VO#a#WO']QO'e#XO'l!zO'm!{O~O^!Xa|!Xa&{!Xay!Xa!^!Xa'_!Xa!O!Xa$w!Xa!W!Xa~P!(TOR)PO!O&[O!j)OO$w(}O'U$_O~O'P$vO'T'VP~O!W)SO!O'SX^'SX&{'SX~O!_$TO'U$_O~O!_$TO'P$[O'U$_O~O!W!tO#O&uO~O'P)[O}'zP~O|)`O['yX~OY)dO~O[)eO~O!O$gO'P$[O'Q$^O['yP~Ot$pO{)jO!O$qO'P$[Oy'iP~O]&SOj&SO{)kO'Y&{O}'kP~O|)lO^'vX&{'vX~O!t)pO'U$_O~OR)sO!O#uO'U$_O~O!O)uO~Oq)wO!OSO~O!i)|O~Ob*RO~O'P(nO}'xP~Ob$eO~O$xrO'P$vO~P8]OY*XO[*WO~OPTOQTO]bOamOblOgbOiTOjbOkbOmTOoTOtROvbOwbOxbO!YjO!_UO!bTO!cTO!dTO!eTO!fTO!ikO#o]O$voO']QO'q`O~O!O!`O#k!iO'P8cO~P!/bO[*WO^$WO&{$WO~O^*]O#Z*_O$z*_O${*_O~P)rO!_%ZO~O%k*dO~O!O*fO~O%{*iO%|*hOP%yaQ%yaW%ya]%ya^%yaa%yab%yag%yai%yaj%yak%yam%yao%yat%yav%yaw%yax%ya!O%ya!Y%ya!_%ya!b%ya!c%ya!d%ya!e%ya!f%ya!i%ya#Z%ya#k%ya#o%ya$v%ya$x%ya$z%ya${%ya%O%ya%Q%ya%T%ya%U%ya%W%ya%e%ya%k%ya%m%ya%o%ya%q%ya%t%ya%z%ya&O%ya&Q%ya&S%ya&U%ya&W%ya&v%ya'P%ya']%ya'q%ya}%ya%r%ya_%ya%w%ya~O'P*lO~O'_*oO~Oy&]a|&]a~P!(TO|!ZOy'`a~Oy'`a~P=oO|&XOy'ia~O|sX|!UX}sX}!UX!WsX!W!UX!_!UX!tsX'U!UX~O!W*vO!t*uO|!{X|'bX}!{X}'bX!W'bX!_'bX'U'bX~O!W*xO!_$TO'U$_O|!QX}!QX~O]%zOj%zOt%{O'Y([O~OP8`OQ8`O]bOa9uOb!gOgbOi8`OjbOkbOm8`Oo8`OtROvbOwbOxbO!O!`O!Y8bO!_UO!b8`O!c8`O!d8`O!e8`O!f8`O!i!fO#k!iO#o]O']QO'q9sO~O'P9PO~P!9YO|*|O}'aX~O}+OO~O!W*vO!t*uO|!{X}!{X~O|+PO}'kX~O}+RO~O]%zOj%zOt%{O'Q$^O'Y([O~O!S+SO!T+SO~P!<TOt$pO{+VO!O$qO'P$[Oy&bX|&bX~O^+ZO!R+^O!S+YO!T+YO!m+`O!n+_O!o+_O!q+aO'Q$^O'Y([O~O}+]O~P!=UOR+fO!O&[O!j+eO~O!t+lO|'ga!^'ga^'ga&{'ga~O!W!tO~P!>YO|&lO!^'fa~Ot$pO{+oO!O$qO!|+qO!}+oO'P$[O|&dX!^&dX~O^!vi|!vi&{!viy!vi!^!vi'_!vi!O!vi$w!vi!W!vi~P!(TO#O!sa|!sa!^!sa!t!sa!O!sa^!sa&{!say!sa~P!!iO#O'XXP'XXY'XX^'XXi'XXr'XX!['XX!_'XX!e'XX#R'XX#S'XX#T'XX#U'XX#V'XX#W'XX#X'XX#Y'XX#['XX#^'XX#`'XX#a'XX&{'XX']'XX!^'XXy'XX!O'XX$w'XX'_'XX!W'XX~P!%wO|+zO'T'cX~P!!iO'T+|O~O|+}O!^'dX~P!(TO!^,QO~Oy,RO~OP#ZOq!xOr!xOt!yO!]!vO!_!wO!e#ZO']QOY#Qi^#Qii#Qi|#Qi![#Qi#S#Qi#T#Qi#U#Qi#V#Qi#W#Qi#X#Qi#Y#Qi#[#Qi#^#Qi#`#Qi#a#Qi&{#Qi'e#Qi'l#Qi'm#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~O#R#Qi~P!CgO#R!|O~P!CgOP#ZOq!xOr!xOt!yO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O']QOY#Qi^#Qi|#Qi![#Qi#V#Qi#W#Qi#X#Qi#Y#Qi#[#Qi#^#Qi#`#Qi#a#Qi&{#Qi'e#Qi'l#Qi'm#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~Oi#Qi~P!FROi#OO~P!FROP#ZOi#OOq!xOr!xOt!yO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO']QO^#Qi|#Qi#[#Qi#^#Qi#`#Qi#a#Qi&{#Qi'e#Qi'l#Qi'm#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~OY#Qi![#Qi#W#Qi#X#Qi#Y#Qi~P!HmOY#aO![#QO#W#QO#X#QO#Y#QO~P!HmOP#ZOY#aOi#OOq!xOr!xOt!yO![#QO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO#W#QO#X#QO#Y#QO#[#RO']QO^#Qi|#Qi#^#Qi#`#Qi#a#Qi&{#Qi'e#Qi'm#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~O'l#Qi~P!KeO'l!zO~P!KeOP#ZOY#aOi#OOq!xOr!xOt!yO![#QO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO#W#QO#X#QO#Y#QO#[#RO#^#TO']QO'l!zO^#Qi|#Qi#`#Qi#a#Qi&{#Qi'e#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~O'm#Qi~P!NPO'm!{O~P!NPOP#ZOY#aOi#OOq!xOr!xOt!yO![#QO!]!vO!_!wO!e#ZO#R!|O#S!}O#T!}O#U!}O#V#PO#W#QO#X#QO#Y#QO#[#RO#^#TO#`#VO']QO'l!zO'm!{O~O^#Qi|#Qi#a#Qi&{#Qi'e#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~P#!kOPZXYZXiZXqZXrZXtZX![ZX!]ZX!_ZX!eZX!tZX#OcX#RZX#SZX#TZX#UZX#VZX#WZX#XZX#YZX#[ZX#^ZX#`ZX#aZX#fZX']ZX'eZX'lZX'mZX|ZX}ZX~O#dZX~P#%OOP#ZOY8sOi8hOq!xOr!xOt!yO![8jO!]!vO!_!wO!e#ZO#R8fO#S8gO#T8gO#U8gO#V8iO#W8jO#X8jO#Y8jO#[8kO#^8mO#`8oO#a8pO']QO'e#XO'l!zO'm!{O~O#d,TO~P#'YOP'[XY'[Xi'[Xq'[Xr'[Xt'[X!['[X!]'[X!_'[X!e'[X#R'[X#S'[X#T'[X#U'[X#V'[X#W'[X#Y'[X#['[X#^'[X#`'[X#a'[X']'[X'e'[X'l'[X'm'[X|'[X~O!t8tO#f8tO#X'[X#d'[X}'[X~P#)TO^&ga|&ga&{&ga!^&ga'_&gay&ga!O&ga$w&ga!W&ga~P!(TOP#QiY#Qi^#Qii#Qir#Qi|#Qi![#Qi!]#Qi!_#Qi!e#Qi#R#Qi#S#Qi#T#Qi#U#Qi#V#Qi#W#Qi#X#Qi#Y#Qi#[#Qi#^#Qi#`#Qi#a#Qi&{#Qi']#Qiy#Qi!^#Qi'_#Qi!O#Qi$w#Qi!W#Qi~P!!iO^#ei|#ei&{#eiy#ei!^#ei'_#ei!O#ei$w#ei!W#ei~P!(TO#q,VO~O#q,WO~O!W'dO!t,XO!O#uX#n#uX#q#uX#x#uX~O{,YO~O!O'gO#n,[O#q'fO#x,]O~O|8qO}'ZX~P#'YO},^O~O#x,`O~O],cOj,cOy,dO~O|cX!WcX!^cX!^$[X'ecX~P! kO!^,jO~P!!iO|,kO!W!tO'e&gO!^'rX~O!^,pO~Oy$[X|$[X!W$cX~P! kO|,rOy'sX~P!!iO!W,tO~Oy,vO~O{(SO'P$[O!^'rP~Oi,zO!W!tO!_$TO'U$_O'e&gO~O!W)SO~O}-QO~P!${O!S-RO!T-RO'Q$^O'Y([O~Ot-TO'Y([O~O!q-UO~O'P$vO|&lX'T&lX~O|(lO'T'Va~Oq-ZOr-ZOt-[O'ena'lna'mna|na!tna~O'Tna#dna~P#3|Oq'vOt'wO'e$Ta'l$Ta'm$Ta|$Ta!t$Ta~O'T$Ta#d$Ta~P#4rOq'vOt'wO'e$Va'l$Va'm$Va|$Va!t$Va~O'T$Va#d$Va~P#5eO]-]O~O#O-^O~O'T$ea|$ea#d$ea!t$ea~P!!iO#O-aO~OR-jO!O&[O!j-iO$w-hO~O'T-kO~O]#nOi#oOj#nOk#nOm#{Oo8uOt#tO!O#uO!Y9wO!_#rO!}8{O#k$PO$U8wO$W8yO$Z$QO~Og-mO'P-lO~P#7[O!W)SO!O'Sa^'Sa&{'Sa~O#O-sO~OYZX|cX}cX~O|-tO}'zX~O}-vO~OY-wO~O!O$gO'P$[O[&tX|&tX~O|)`O['ya~O!^-zO~P!(TO]-|O~OY-}O~O[.OO~OR-jO!O&[O!j-iO$w-hO'U$_O~O|)lO^'va&{'va~O!t.UO~OR.XO!O#uO~O'Y&{O}'wP~OR.cO!O._O!j.bO$w.aO'U$_O~OY.mO|.kO}'xX~O}.nO~O[.pO^$WO&{$WO~O].qO~O#X.sO%i.tO~P0kO!t#bO#X.sO%i.tO~O^.uO~P)rO^.wO~O%r.{OP%piQ%piW%pi]%pi^%pia%pib%pig%pii%pij%pik%pim%pio%pit%piv%piw%pix%pi!O%pi!Y%pi!_%pi!b%pi!c%pi!d%pi!e%pi!f%pi!i%pi#Z%pi#k%pi#o%pi$v%pi$x%pi$z%pi${%pi%O%pi%Q%pi%T%pi%U%pi%W%pi%e%pi%k%pi%m%pi%o%pi%q%pi%t%pi%z%pi&O%pi&Q%pi&S%pi&U%pi&W%pi&v%pi'P%pi']%pi'q%pi}%pi_%pi%w%pi~O_/RO}/PO%w/QO~P]O!OSO!_/UO~O|#_O'_$Sa~Oy&]i|&]i~P!(TO|!ZOy'`i~O|&XOy'ii~Oy/YO~O|!Qa}!Qa~P#'YO]%zOj%zO{/`O'Y([O|&^X}&^X~P?rO|*|O}'aa~O]&SOj&SO{)kO'Y&{O|&cX}&cX~O|+PO}'ka~Oy'ji|'ji~P!(TO^$WO!W!tO!_$TO!e/kO!t/iO&{$WO'U$_O'e&gO~O}/nO~P!=UO!S/oO!T/oO'Q$^O'Y([O~O!R/qO!S/oO!T/oO!q/rO'Q$^O'Y([O~O!n/sO!o/sO~P#EXO!O&[O~O!O&[O~P!!iO|'gi!^'gi^'gi&{'gi~P!(TO!t/|O|'gi!^'gi^'gi&{'gi~O|&lO!^'fi~Ot$pO!O$qO!}0OO'P$[O~O#OnaPnaYna^naina![na!]na!_na!ena#Rna#Sna#Tna#Una#Vna#Wna#Xna#Yna#[na#^na#`na#ana&{na']na!^nayna!Ona$wna'_na!Wna~P#3|O#O$TaP$TaY$Ta^$Tai$Tar$Ta![$Ta!]$Ta!_$Ta!e$Ta#R$Ta#S$Ta#T$Ta#U$Ta#V$Ta#W$Ta#X$Ta#Y$Ta#[$Ta#^$Ta#`$Ta#a$Ta&{$Ta']$Ta!^$Tay$Ta!O$Ta$w$Ta'_$Ta!W$Ta~P#4rO#O$VaP$VaY$Va^$Vai$Var$Va![$Va!]$Va!_$Va!e$Va#R$Va#S$Va#T$Va#U$Va#V$Va#W$Va#X$Va#Y$Va#[$Va#^$Va#`$Va#a$Va&{$Va']$Va!^$Vay$Va!O$Va$w$Va'_$Va!W$Va~P#5eO#O$eaP$eaY$ea^$eai$ear$ea|$ea![$ea!]$ea!_$ea!e$ea#R$ea#S$ea#T$ea#U$ea#V$ea#W$ea#X$ea#Y$ea#[$ea#^$ea#`$ea#a$ea&{$ea']$ea!^$eay$ea!O$ea!t$ea$w$ea'_$ea!W$ea~P!!iO^!vq|!vq&{!vqy!vq!^!vq'_!vq!O!vq$w!vq!W!vq~P!(TO|&_X'T&_X~PIoO|+zO'T'ca~O{0WO|&`X!^&`X~P)rO|+}O!^'da~O|+}O!^'da~P!(TO#d!aa}!aa~PBtO#d!Xa|!Xa}!Xa~P#'YO!O0kO#o]O#v0lO~O}0pO~O^$Pq|$Pq&{$Pqy$Pq!^$Pq'_$Pq!O$Pq$w$Pq!W$Pq~P!(TOy0qO~O],cOj,cO~Oq'vOt'wO'm'{O'e$oi'l$oi|$oi!t$oi~O'T$oi#d$oi~P$%SOq'vOt'wO'e$qi'l$qi'm$qi|$qi!t$qi~O'T$qi#d$qi~P$%uO#d0rO~P!!iO{0tO'P$[O|&hX!^&hX~O|,kO!^'ra~O|,kO!W!tO!^'ra~O|,kO!W!tO'e&gO!^'ra~O'T$^i|$^i#d$^i!t$^i~P!!iO{0{O'P(VOy&jX|&jX~P!#WO|,rOy'sa~O|,rOy'sa~P!!iO!W!tO~O!W!tO#X1VO~Oi1ZO!W!tO'e&gO~O|'Wi'T'Wi~P!!iO!t1^O|'Wi'T'Wi~P!!iO!^1aO~O^$Qq|$Qq&{$Qqy$Qq!^$Qq'_$Qq!O$Qq$w$Qq!W$Qq~P!(TO|1eO!O'tX~P!!iO!O&[O$w1hO~O!O&[O$w1hO~P!!iO!O$[X$lZX^$[X&{$[X~P! kO$l1lOqfXtfX!OfX'efX'lfX'mfX^fX&{fX~O$l1lO~O'P)[O|&sX}&sX~O|-tO}'za~O[1uO~O]1xO~OR1zO!O&[O!j1yO$w1hO~O^$WO&{$WO~P!!iO!O#uO~P!!iO|2PO!t2RO}'wX~O}2SO~Ot(`O!R2]O!S2UO!T2UO!m2[O!n2ZO!o2ZO!q2YO'Q$^O'Y([O~O}2XO~P$-{OR2dO!O._O!j2cO$w2bO~OR2dO!O._O!j2cO$w2bO'U$_O~O'P(nO|&rX}&rX~O|.kO}'xa~O'Y2mO~O]2oO~O[2qO~O!^2tO~P)rO^2vO~O^2vO~P)rO#X2xO%i2yO~PE^O_/RO}2}O%w/QO~P]O!W3PO~O%|3QOP%yqQ%yqW%yq]%yq^%yqa%yqb%yqg%yqi%yqj%yqk%yqm%yqo%yqt%yqv%yqw%yqx%yq!O%yq!Y%yq!_%yq!b%yq!c%yq!d%yq!e%yq!f%yq!i%yq#Z%yq#k%yq#o%yq$v%yq$x%yq$z%yq${%yq%O%yq%Q%yq%T%yq%U%yq%W%yq%e%yq%k%yq%m%yq%o%yq%q%yq%t%yq%z%yq&O%yq&Q%yq&S%yq&U%yq&W%yq&v%yq'P%yq']%yq'q%yq}%yq%r%yq_%yq%w%yq~O|!{i}!{i~P#'YO!t3SO|!{i}!{i~O|!Qi}!Qi~P#'YO^$WO!t3ZO&{$WO~O^$WO!W!tO!t3ZO&{$WO~O^$WO!W!tO!_$TO!e3_O!t3ZO&{$WO'U$_O'e&gO~O!S3`O!T3`O'Q$^O'Y([O~O!R3cO!S3`O!T3`O!q3dO'Q$^O'Y([O~O^$WO!W!tO!e3_O!t3ZO&{$WO'e&gO~O|'gq!^'gq^'gq&{'gq~P!(TO|&lO!^'fq~O#O$oiP$oiY$oi^$oii$oir$oi![$oi!]$oi!_$oi!e$oi#R$oi#S$oi#T$oi#U$oi#V$oi#W$oi#X$oi#Y$oi#[$oi#^$oi#`$oi#a$oi&{$oi']$oi!^$oiy$oi!O$oi$w$oi'_$oi!W$oi~P$%SO#O$qiP$qiY$qi^$qii$qir$qi![$qi!]$qi!_$qi!e$qi#R$qi#S$qi#T$qi#U$qi#V$qi#W$qi#X$qi#Y$qi#[$qi#^$qi#`$qi#a$qi&{$qi']$qi!^$qiy$qi!O$qi$w$qi'_$qi!W$qi~P$%uO#O$^iP$^iY$^i^$^ii$^ir$^i|$^i![$^i!]$^i!_$^i!e$^i#R$^i#S$^i#T$^i#U$^i#V$^i#W$^i#X$^i#Y$^i#[$^i#^$^i#`$^i#a$^i&{$^i']$^i!^$^iy$^i!O$^i!t$^i$w$^i'_$^i!W$^i~P!!iO|&_a'T&_a~P!!iO|&`a!^&`a~P!(TO|+}O!^'di~O#d!vi|!vi}!vi~P#'YOP#ZOq!xOr!xOt!yO!]!vO!_!wO!e#ZO']QOY#Qii#Qi![#Qi#S#Qi#T#Qi#U#Qi#V#Qi#W#Qi#X#Qi#Y#Qi#[#Qi#^#Qi#`#Qi#a#Qi#d#Qi'e#Qi'l#Qi'm#Qi|#Qi}#Qi~O#R#Qi~P$?rO#R8fO~P$?rOP#ZOq!xOr!xOt!yO!]!vO!_!wO!e#ZO#R8fO#S8gO#T8gO#U8gO']QOY#Qi![#Qi#V#Qi#W#Qi#X#Qi#Y#Qi#[#Qi#^#Qi#`#Qi#a#Qi#d#Qi'e#Qi'l#Qi'm#Qi|#Qi}#Qi~Oi#Qi~P$AzOi8hO~P$AzOP#ZOi8hOq!xOr!xOt!yO!]!vO!_!wO!e#ZO#R8fO#S8gO#T8gO#U8gO#V8iO']QO#[#Qi#^#Qi#`#Qi#a#Qi#d#Qi'e#Qi'l#Qi'm#Qi|#Qi}#Qi~OY#Qi![#Qi#W#Qi#X#Qi#Y#Qi~P$DSOY8sO![8jO#W8jO#X8jO#Y8jO~P$DSOP#ZOY8sOi8hOq!xOr!xOt!yO![8jO!]!vO!_!wO!e#ZO#R8fO#S8gO#T8gO#U8gO#V8iO#W8jO#X8jO#Y8jO#[8kO']QO#^#Qi#`#Qi#a#Qi#d#Qi'e#Qi'm#Qi|#Qi}#Qi~O'l#Qi~P$FhO'l!zO~P$FhOP#ZOY8sOi8hOq!xOr!xOt!yO![8jO!]!vO!_!wO!e#ZO#R8fO#S8gO#T8gO#U8gO#V8iO#W8jO#X8jO#Y8jO#[8kO#^8mO']QO'l!zO#`#Qi#a#Qi#d#Qi'e#Qi|#Qi}#Qi~O'm#Qi~P$HpO'm!{O~P$HpOP#ZOY8sOi8hOq!xOr!xOt!yO![8jO!]!vO!_!wO!e#ZO#R8fO#S8gO#T8gO#U8gO#V8iO#W8jO#X8jO#Y8jO#[8kO#^8mO#`8oO']QO'l!zO'm!{O~O#a#Qi#d#Qi'e#Qi|#Qi}#Qi~P$JxO^#by|#by&{#byy#by!^#by'_#by!O#by$w#by!W#by~P!(TOP#QiY#Qii#Qir#Qi![#Qi!]#Qi!_#Qi!e#Qi#R#Qi#S#Qi#T#Qi#U#Qi#V#Qi#W#Qi#X#Qi#Y#Qi#[#Qi#^#Qi#`#Qi#a#Qi#d#Qi']#Qi|#Qi}#Qi~P!!iO!]!vOP'XXY'XXi'XXq'XXr'XXt'XX!['XX!_'XX!e'XX#R'XX#S'XX#T'XX#U'XX#V'XX#W'XX#X'XX#Y'XX#['XX#^'XX#`'XX#a'XX#d'XX']'XX'e'XX'l'XX'm'XX|'XX}'XX~O#d#ei|#ei}#ei~P#'YO}3tO~O|&ga}&ga~P#'YO!W!tO'e&gO|&ha!^&ha~O|,kO!^'ri~O|,kO!W!tO!^'ri~Oy&ja|&ja~P!!iO!W3{O~O|,rOy'si~P!!iO|,rOy'si~Oy4RO~O!W!tO#X4XO~Oi4YO!W!tO'e&gO~Oy4[O~O'T$`q|$`q#d$`q!t$`q~P!!iO^$Qy|$Qy&{$Qyy$Qy!^$Qy'_$Qy!O$Qy$w$Qy!W$Qy~P!(TO|1eO!O'ta~O!O&[O$w4aO~O!O&[O$w4aO~P!!iO^!vy|!vy&{!vyy!vy!^!vy'_!vy!O!vy$w!vy!W!vy~P!(TOY4dO~O|-tO}'zi~O]4fO~O[4gO~O'Y&{O|&oX}&oX~O|2PO}'wa~O}4tO~P$-{O!R4wO!S4vO!T4vO!q/rO'Q$^O'Y([O~O!n4xO!o4xO~P%)VO!S4vO!T4vO'Q$^O'Y([O~O!O._O~O!O._O$w4zO~O!O._O$w4zO~P!!iOR5PO!O._O!j5OO$w4zO~OY5UO|&ra}&ra~O|.kO}'xi~O]5XO~O!^5YO~O!^5ZO~O!^5[O~O!^5[O~P)rO^5^O~O!W5aO~O!^5cO~O|'ji}'ji~P#'YO^$WO&{$WO~P!(TO^$WO!t5hO&{$WO~O^$WO!W!tO!t5hO&{$WO~O^$WO!W!tO!e5mO!t5hO&{$WO'e&gO~O!_$TO'U$_O~P%-YO!S5nO!T5nO'Q$^O'Y([O~O|'gy!^'gy^'gy&{'gy~P!(TO#O$`qP$`qY$`q^$`qi$`qr$`q|$`q![$`q!]$`q!_$`q!e$`q#R$`q#S$`q#T$`q#U$`q#V$`q#W$`q#X$`q#Y$`q#[$`q#^$`q#`$`q#a$`q&{$`q']$`q!^$`qy$`q!O$`q!t$`q$w$`q'_$`q!W$`q~P!!iO|&`i!^&`i~P!(TO#d!vq|!vq}!vq~P#'YOq-ZOr-ZOt-[OPnaYnaina![na!]na!_na!ena#Rna#Sna#Tna#Una#Vna#Wna#Xna#Yna#[na#^na#`na#ana#dna']na'ena'lna'mna|na}na~Oq'vOt'wOP$TaY$Tai$Tar$Ta![$Ta!]$Ta!_$Ta!e$Ta#R$Ta#S$Ta#T$Ta#U$Ta#V$Ta#W$Ta#X$Ta#Y$Ta#[$Ta#^$Ta#`$Ta#a$Ta#d$Ta']$Ta'e$Ta'l$Ta'm$Ta|$Ta}$Ta~Oq'vOt'wOP$VaY$Vai$Var$Va![$Va!]$Va!_$Va!e$Va#R$Va#S$Va#T$Va#U$Va#V$Va#W$Va#X$Va#Y$Va#[$Va#^$Va#`$Va#a$Va#d$Va']$Va'e$Va'l$Va'm$Va|$Va}$Va~OP$eaY$eai$ear$ea![$ea!]$ea!_$ea!e$ea#R$ea#S$ea#T$ea#U$ea#V$ea#W$ea#X$ea#Y$ea#[$ea#^$ea#`$ea#a$ea#d$ea']$ea|$ea}$ea~P!!iO#d$Pq|$Pq}$Pq~P#'YO#d$Qq|$Qq}$Qq~P#'YO}5xO~O'T$sy|$sy#d$sy!t$sy~P!!iO!W!tO|&hi!^&hi~O!W!tO'e&gO|&hi!^&hi~O|,kO!^'rq~Oy&ji|&ji~P!!iO|,rOy'sq~Oy6PO~P!!iOy6PO~O|'Wy'T'Wy~P!!iO|&ma!O&ma~P!!iO!O$kq^$kq&{$kq~P!!iO|-tO}'zq~O]6YO~O!O&[O$w6ZO~O!O&[O$w6ZO~P!!iO!t6[O|&oa}&oa~O|2PO}'wi~P#'YO!S6bO!T6bO'Q$^O'Y([O~O!R6dO!S6bO!T6bO!q3dO'Q$^O'Y([O~O!O._O$w6gO~O!O._O$w6gO~P!!iO'Y6mO~O|.kO}'xq~O!^6pO~O!^6pO~P)rO!^6rO~O!^6sO~O|!{y}!{y~P#'YO^$WO!t6xO&{$WO~O^$WO!W!tO!t6xO&{$WO~O^$WO!W!tO!e6|O!t6xO&{$WO'e&gO~O#O$syP$syY$sy^$syi$syr$sy|$sy![$sy!]$sy!_$sy!e$sy#R$sy#S$sy#T$sy#U$sy#V$sy#W$sy#X$sy#Y$sy#[$sy#^$sy#`$sy#a$sy&{$sy']$sy!^$syy$sy!O$sy!t$sy$w$sy'_$sy!W$sy~P!!iO#d#by|#by}#by~P#'YOP$^iY$^ii$^ir$^i![$^i!]$^i!_$^i!e$^i#R$^i#S$^i#T$^i#U$^i#V$^i#W$^i#X$^i#Y$^i#[$^i#^$^i#`$^i#a$^i#d$^i']$^i|$^i}$^i~P!!iOq'vOt'wO'm'{OP$oiY$oii$oir$oi![$oi!]$oi!_$oi!e$oi#R$oi#S$oi#T$oi#U$oi#V$oi#W$oi#X$oi#Y$oi#[$oi#^$oi#`$oi#a$oi#d$oi']$oi'e$oi'l$oi|$oi}$oi~Oq'vOt'wOP$qiY$qii$qir$qi![$qi!]$qi!_$qi!e$qi#R$qi#S$qi#T$qi#U$qi#V$qi#W$qi#X$qi#Y$qi#[$qi#^$qi#`$qi#a$qi#d$qi']$qi'e$qi'l$qi'm$qi|$qi}$qi~O#d$Qy|$Qy}$Qy~P#'YO#d!vy|!vy}!vy~P#'YO!W!tO|&hq!^&hq~O|,kO!^'ry~Oy&jq|&jq~P!!iOy7SO~P!!iO|2PO}'wq~O!S7_O!T7_O'Q$^O'Y([O~O!O._O$w7bO~O!O._O$w7bO~P!!iO!^7eO~O%|7fOP%y!ZQ%y!ZW%y!Z]%y!Z^%y!Za%y!Zb%y!Zg%y!Zi%y!Zj%y!Zk%y!Zm%y!Zo%y!Zt%y!Zv%y!Zw%y!Zx%y!Z!O%y!Z!Y%y!Z!_%y!Z!b%y!Z!c%y!Z!d%y!Z!e%y!Z!f%y!Z!i%y!Z#Z%y!Z#k%y!Z#o%y!Z$v%y!Z$x%y!Z$z%y!Z${%y!Z%O%y!Z%Q%y!Z%T%y!Z%U%y!Z%W%y!Z%e%y!Z%k%y!Z%m%y!Z%o%y!Z%q%y!Z%t%y!Z%z%y!Z&O%y!Z&Q%y!Z&S%y!Z&U%y!Z&W%y!Z&v%y!Z'P%y!Z']%y!Z'q%y!Z}%y!Z%r%y!Z_%y!Z%w%y!Z~O^$WO!t7jO&{$WO~O^$WO!W!tO!t7jO&{$WO~OP$`qY$`qi$`qr$`q![$`q!]$`q!_$`q!e$`q#R$`q#S$`q#T$`q#U$`q#V$`q#W$`q#X$`q#Y$`q#[$`q#^$`q#`$`q#a$`q#d$`q']$`q|$`q}$`q~P!!iO|&oq}&oq~P#'YO^$WO!t8OO&{$WO~OP$syY$syi$syr$sy![$sy!]$sy!_$sy!e$sy#R$sy#S$sy#T$sy#U$sy#V$sy#W$sy#X$sy#Y$sy#[$sy#^$sy#`$sy#a$sy#d$sy']$sy|$sy}$sy~P!!iO'_'ZX~P.ZO'_ZXyZX!^ZX%iZX!OZX$wZX!WZX~P$tO!WcX!^ZX!^cX'ecX~P:xOP8`OQ8`O]bOa9uOb!gOgbOi8`OjbOkbOm8`Oo8`OtROvbOwbOxbO!OSO!Y8bO!_UO!b8`O!c8`O!d8`O!e8`O!f8`O!i!fO#k!iO#o]O'P'ZO']QO'q9sO~O|8qO}$Sa~O]#nOg#zOi#oOj#nOk#nOm#{Oo8vOt#tO!O#uO!Y9xO!_#rO!}8|O#k$PO$U8xO$W8zO$Z$QO'P&sO~O#Z'bO~P&'mO}ZX}cX~P:xO#O8eO~O!W!tO#O8eO~O!t8tO~O!t8}O|'jX}'jX~O!t8tO|'hX}'hX~O#O9OO~O'T9QO~P!!iO#O9VO~O#O9WO~O!W!tO#O9XO~O!W!tO#O9OO~O#d9YO~P#'YO#O9ZO~O#O9[O~O#O9]O~O#O9^O~O#d9_O~P!!iO#d9`O~P!!iO#o~!]!m!o!|!}'q$U$W$Z$l$v$w$x%O%Q%T%U%W%Y~TS#o'q#q'Y'P&}#Sx~", goto: "#<v(OPPPPPPP(PP(aP)|PPPP-]PP-r2v4i4|P4|PPP4|P4|P6iPP6nP7VPPPP;fPPPP;f>UPPP>[@_P;fPBrPPPPDj;fPPPPPFc;fPPIbJ_PPPJcPJkKlP;f;fNs!#l!([!([!+iPPP!+p;fPPPPPPPPPP!.dP!/uPP;f!1SP;fP;f;f;f;fP;f!3fPP!6]P!9O!9W!9[!9[P!6YP!9`!9`P!<RP!<V;f;f!<]!>}4|P4|P4|4|P!@Q4|4|!At4|4|4|!Cu4|4|!Dc!F[!F[!F`!F[!FhP!F[P4|!Gd4|!Hm4|4|-]PPP!IyPP!Jc!JcP!JcP!Jx!JcPP!KOP!JuP!Ju!KbJg!Ju!LP!LV!LY(P!L](PP!Ld!Ld!LdP(PP(PP(PP(PPP(PP!Lj!LmP!Lm(PPPP(PP(PP(PP(PP(PP(P(P!Lq!L{!MR!Ma!Mg!Mm!Mw!M}!NX!N_!Nm!Ns!Ny# X# n##P##_##e##k##q##w#$R#$X#$_#$i#$s#$yPPPPPPPP#%PPP#%s#)qPP#+U#+]#+eP#/n#2RP#7{P#8P#8S#8V#8b#8eP#8h#8l#9Z#:O#:S#:fPP#:j#:p#:tP#:w#:{#;O#;n#<U#<Z#<^#<a#<g#<j#<n#<rmgOSi{!k$V%^%a%b%d*a*f.{/OQ$dlQ$knQ%UwS&O!`*|Q&c!gS(_#u(dQ)Y$eQ)f$mQ*Q%OQ+S&VS+Y&[+[Q+j&dQ-R(fQ.j*RU/o+^+_+`S2U._2WS3`/q/sU4v2Z2[2]Q5n3cS6b4w4xR7_6d$lZORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$V$i%V%Y%^%`%a%b%d%h%s%{&W&^&h&u&y'u(w)O*]*a*f+e+l+},T-[-a-i-s.b.s.t.u.w.{/O/Q/i/|0W1y2c2v2x2y3Z5O5^5h6x7j8O!j']#Y#h&P'o*u*x,Y/`0k2R3S6[8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vQ(o#|Q)_$gQ*S%RQ*Z%ZQ+t8uQ-n)SQ.r*XQ1r-tQ2k.kR3m8vpdOSiw{!k$V%T%^%a%b%d*a*f.{/OR*U%V&WVOSTijm{!Q!U!Z!h!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$V$i%V%Y%Z%^%`%a%b%d%h%s%{&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9u9vW!aRU!^&PQ$]kQ$clS$hn$mv$rpq!o!r$T$p&X&l&o)j)k)l*_*v+V+o+q/U0OQ$zuQ&`!fQ&b!gS(R#r(]S)X$d$eQ)]$gQ)i$oQ){$|Q*P%OS+i&c&dQ,o(SQ-r)YQ-x)`Q-{)dQ.e)|S.i*Q*RQ/z+jQ0s,kQ1q-tQ1t-wQ1w-}Q2j.jQ3x0tR6W4d!W$al!g$c$d$e%}&b&c&d(^)X)Y*y+X+i+j,{-r/e/l/p/z1Y3^3b5l6{Q)Q$]Q)q$wQ)t$xQ*O%OQ.P)iQ.d){U.h*P*Q*RQ2e.eS2i.i.jQ4q2TQ5T2jS6`4r4uS7]6a6cQ7u7^R8T7vW#x`$_(l9sS$wr%TQ$xsQ$ytR)o$u$T#w`!t!v#a#r#t#}$O$S&_'z'|'}(U(Y(j(k(})P)S)p)s+f+z,r,t-^-h-j.U.X.a.c0r0{1V1^1e1h1l1z2b2d3{4X4a4z5P6Z6g7b8s8w8x8y8z8{8|9R9S9T9U9V9W9Z9[9_9`9s9y9zV(p#|8u8vU&S!`$q+PQ&|!xQ)c$jQ,b'vQ.Y)uQ1_-ZR4m2P&YbORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$V$i%V%Y%Z%^%`%a%b%d%h%s%{&P&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9v$]#^Y!]!l$Z%r%v&q&x'O'P'Q'R'S'T'U'V'W'X'Y'['_'c'm)b*q*z+T+k+y,P,S,U,a-_/Z/^/{0V0Z0[0]0^0_0`0a0b0c0d0e0f0g0j0o1c1o3U3X3h3k3l3q3r4o5d5g5r5v5w6v7X7h7|8W8a9l&ZbORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$V$i%V%Y%Z%^%`%a%b%d%h%s%{&P&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vQ&Q!`R/a*|Y%z!`&O&V*|+SS(^#u(dS+X&[+[S,{(_(fQ,|(`Q-S(gQ.[)wS/l+Y+^S/p+_+`S/t+a2YQ1Y-RQ1[-TQ1]-US2T._2WS3^/o/qQ3a/rQ3b/sS4r2U2]S4u2Z2[S5l3`3cQ5o3dS6a4v4wQ6c4xQ6{5nS7^6b6dR7v7_lgOSi{!k$V%^%a%b%d*a*f.{/OQ%f!OS&p!s8eQ)V$bQ)y$zQ)z${Q+g&aS+x&u9OS-`(w9XQ-p)WQ.^)xQ/S*hQ/T*iQ/]*wQ/x+hS1d-a9]Q1m-qS1p-s9^Q3T/_Q3W/gQ3f/yQ4c1nQ5b3QQ5e3VQ5i3]Q5p3gQ6t5cQ6w5jQ7i6yQ7z7fR7}7k$W#]Y!]!l%r%v&q&x'O'P'Q'R'S'T'U'V'W'X'Y'['_'c'm)b*q*z+T+k+y,P,S,a-_/Z/^/{0V0Z0[0]0^0_0`0a0b0c0d0e0f0g0j0o1c1o3U3X3h3k3l3q3r4o5d5g5r5v5w6v7X7h7|8W8a9lU(i#v&t0iT({$Z,U$W#[Y!]!l%r%v&q&x'O'P'Q'R'S'T'U'V'W'X'Y'['_'c'm)b*q*z+T+k+y,P,S,a-_/Z/^/{0V0Z0[0]0^0_0`0a0b0c0d0e0f0g0j0o1c1o3U3X3h3k3l3q3r4o5d5g5r5v5w6v7X7h7|8W8a9lQ'^#]S(z$Z,UR-b({&YbORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$V$i%V%Y%Z%^%`%a%b%d%h%s%{&P&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vQ%ayQ%bzQ%d|Q%e}R.z*dQ&]!fQ(|$]Q+d&`S-g)Q)iS/u+b+cW1g-d-e-f.PS3e/v/wU4`1i1j1kU6U4_4i4jQ7U6VR7q7WT+Z&[+[S+Z&[+[T2V._2WS&j!n.xQ,n(RQ,y(^S/k+X2TQ0x,oS1S,z-SU3_/p/t4uQ3w0sS4V1Z1]U5m3a3b6cQ5z3xQ6T4YR6|5oQ!uXS&i!n.xQ(x$UQ)T$`Q)Z$fQ+m&jQ,m(RQ,x(^Q,}(aQ-o)UQ.f)}S/j+X2TS0w,n,oS1R,y-SQ1U,|Q1X-OQ2g.gW3[/k/p/t4uQ3v0sQ3z0xS4P1S1]Q4W1[Q5R2hW5k3_3a3b6cS5y3w3xQ6O4RQ6R4VQ6^4pQ6k5SS6z5m5oQ7O5zQ7Q6PQ7T6TQ7Z6_Q7d6lQ7l6|Q7o7SQ7s7[Q8R7tQ8Y8SQ8^8ZQ9f9bQ9o9jR9p9k$nWORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$V$i%V%Y%Z%^%`%a%b%d%h%s%{&W&^&h&u&y'u(w)O*]*a*f+e+l+},T-[-a-i-s.b.s.t.u.w.{/O/Q/i/|0W1y2c2v2x2y3Z5O5^5h6x7j8OS!um!h!j9a#Y#h&P'o*u*x,Y/`0k2R3S6[8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vR9f9u$nXORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$V$i%V%Y%Z%^%`%a%b%d%h%s%{&W&^&h&u&y'u(w)O*]*a*f+e+l+},T-[-a-i-s.b.s.t.u.w.{/O/Q/i/|0W1y2c2v2x2y3Z5O5^5h6x7j8OQ$Ua!W$`l!g$c$d$e%}&b&c&d(^)X)Y*y+X+i+j,{-r/e/l/p/z1Y3^3b5l6{S$fm!hQ)U$aQ)}%OW.g*O*P*Q*RU2h.h.i.jQ4p2TS5S2i2jU6_4q4r4uQ6l5TU7[6`6a6cS7t7]7^S8S7u7vQ8Z8T!j9b#Y#h&P'o*u*x,Y/`0k2R3S6[8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vQ9j9tR9k9u$f[OSTij{!Q!U!Z!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$V$i%V%Y%^%`%a%b%d%h%s%{&W&^&h&u&y'u(w)O*]*a*f+e+l+},T-[-a-i-s.b.s.t.u.w.{/O/Q/i/|0W1y2c2v2x2y3Z5O5^5h6x7j8OU!eRU!^v$rpq!o!r$T$p&X&l&o)j)k)l*_*v+V+o+q/U0OQ*[%Z!h9c#Y#h'o*u*x,Y/`0k2R3S6[8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vR9e&PS&T!`$qR/c+P$lZORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$V$i%V%Y%^%`%a%b%d%h%s%{&W&^&h&u&y'u(w)O*]*a*f+e+l+},T-[-a-i-s.b.s.t.u.w.{/O/Q/i/|0W1y2c2v2x2y3Z5O5^5h6x7j8O!j']#Y#h&P'o*u*x,Y/`0k2R3S6[8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vR*Z%Z!h#SY!]$Z%r%v&q&x'V'W'X'Y'_'c)b*q+T+k+y,P,a-_/{0V0g1c1o3X3h3k5g6v7h7|8W8a!R8l'['m*z,U/Z/^0Z0c0d0e0f0j0o3U3l3q3r4o5d5r5v5w7X9l!d#UY!]$Z%r%v&q&x'X'Y'_'c)b*q+T+k+y,P,a-_/{0V0g1c1o3X3h3k5g6v7h7|8W8a}8n'['m*z,U/Z/^0Z0e0f0j0o3U3l3q3r4o5d5r5v5w7X9l!`#YY!]$Z%r%v&q&x'_'c)b*q+T+k+y,P,a-_/{0V0g1c1o3X3h3k5g6v7h7|8W8al'}#p&v(v,i,q-V-W0T1b3u4Z9g9q9rx9v'['m*z,U/Z/^0Z0j0o3U3l3q3r4o5d5r5v5w7X9l!^9y&r'a(Q(W+c+w,u-c-f.T.V/w0S0y0}1k1|2O2`3j3|4S4]4b4j4}5q5|6S6iZ9z0h3p5s6}7m&YbORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h$V$i%V%Y%Z%^%`%a%b%d%h%s%{&P&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vS#i_#jR0l,X&a^ORSTU_ij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h#j$V$i%V%Y%Z%^%`%a%b%d%h%s%{&P&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,X,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vS#d]#kT'f#f'jT#e]#kT'h#f'j&a_ORSTU_ij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#Y#_#b#h#j$V$i%V%Y%Z%^%`%a%b%d%h%s%{&P&W&^&h&u&y'o'u(w)O*]*a*f*u*x+e+l+},T,X,Y-[-a-i-s.b.s.t.u.w.{/O/Q/`/i/|0W0k1y2R2c2v2x2y3S3Z5O5^5h6[6x7j8O8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9vT#i_#jQ#l_R'q#j$naORSTUij{!Q!U!Z!^!k!s!w!y!|!}#O#P#Q#R#S#T#U#V#W#_#b$V$i%V%Y%Z%^%`%a%b%d%h%s%{&W&^&h&u&y'u(w)O*]*a*f+e+l+},T-[-a-i-s.b.s.t.u.w.{/O/Q/i/|0W1y2c2v2x2y3Z5O5^5h6x7j8O!k9t#Y#h&P'o*u*x,Y/`0k2R3S6[8`8b8e8f8g8h8i8j8k8l8m8n8o8p8q8t8}9O9Q9X9Y9]9^9v#RcOSUi{!Q!U!k!y#h$V%V%Y%Z%^%`%a%b%d%h%{&^'o)O*]*a*f+e,Y-[-i.b.s.t.u.w.{/O/Q0k1y2c2v2x2y5O5^t#v`!v#}$O$S'z'|'}(U(j(k+z-^0r1^9s9y9z!z&t!t#a#r#t&_(Y(})P)S)p)s+f,r,t-h-j.U.X.a.c0{1V1e1h1l1z2b2d3{4X4a4z5P6Z6g7b8w8y8{9R9T9V9Z9_Q(t$Qc0i8s8x8z8|9S9U9W9[9`t#s`!v#}$O$S'z'|'}(U(j(k+z-^0r1^9s9y9zS(a#u(dQ(u$RQ-O(b!z9h!t#a#r#t&_(Y(})P)S)p)s+f,r,t-h-j.U.X.a.c0{1V1e1h1l1z2b2d3{4X4a4z5P6Z6g7b8w8y8{9R9T9V9Z9_b9i8s8x8z8|9S9U9W9[9`Q9m9wR9n9xleOSi{!k$V%^%a%b%d*a*f.{/OQ(X#tQ*m%kQ*n%mR0z,r$S#w`!t!v#a#r#t#}$O$S&_'z'|'}(U(Y(j(k(})P)S)p)s+f+z,r,t-^-h-j.U.X.a.c0r0{1V1^1e1h1l1z2b2d3{4X4a4z5P6Z6g7b8s8w8x8y8z8{8|9R9S9T9U9V9W9Z9[9_9`9s9y9zQ)r$xQ.W)tQ1}.VR4l2OT(c#u(dS(c#u(dT2V._2WQ)T$`Q,}(aQ-o)UQ.f)}Q2g.gQ5R2hQ6^4pQ6k5SQ7Z6_Q7d6lQ7s7[Q8R7tQ8Y8SR8^8Zl'z#p&v(v,i,q-V-W0T1b3u4Z9g9q9r!^9R&r'a(Q(W+c+w,u-c-f.T.V/w0S0y0}1k1|2O2`3j3|4S4]4b4j4}5q5|6S6iZ9S0h3p5s6}7mn'|#p&v(v,g,i,q-V-W0T1b3u4Z9g9q9r!`9T&r'a(Q(W+c+w,u-c-f.T.V/w0Q0S0y0}1k1|2O2`3j3|4S4]4b4j4}5q5|6S6i]9U0h3p5s5t6}7mpdOSiw{!k$V%T%^%a%b%d*a*f.{/OQ%QvR*]%ZpdOSiw{!k$V%T%^%a%b%d*a*f.{/OR%QvQ)v$yR.S)oqdOSiw{!k$V%T%^%a%b%d*a*f.{/OQ.`){S2a.d.eW4y2^2_2`2eU6f4{4|4}U7`6e6h6iQ7w7aR8U7xQ%XwR*V%TR2n.mR6n5US$hn$mR-x)`Q%^xR*a%_R*g%eT.|*f/OQiOQ!kST$Yi!kQ!WQR%p!WQ![RU%t![%u*rQ%u!]R*r%vQ*}&QR/b*}Q+{&vR0U+{Q,O&xS0X,O0YR0Y,PQ+[&[R/m+[Q&Y!cQ*s%wT+W&Y*sQ+Q&TR/d+QQ&m!pQ+n&kU+r&m+n0PR0P+sQ'j#fR,Z'jQ#j_R'p#jQ#`YU'`#`*p8rQ*p8aR8r'mQ,l(RW0u,l0v3y5{U0v,m,n,oS3y0w0xR5{3z#o'x#p&r&v'a(Q(W(q(r(v+c+u+v+w,g,h,i,q,u-V-W-c-f.T.V/w0Q0R0S0T0h0y0}1b1k1|2O2`3j3n3o3p3u3|4S4Z4]4b4j4}5q5s5t5u5|6S6i6}7m9g9q9rQ,s(WU0|,s1O3}Q1O,uR3}0}Q(d#uR-P(dQ(m#yR-Y(mQ1f-cR4^1fQ)m$sR.R)mQ2Q.YS4n2Q6]R6]4oQ)x$zR.])xQ2W._R4s2WQ.l*SS2l.l5VR5V2nQ-u)]S1s-u4eR4e1tQ)a$hR-y)aQ/O*fR2|/OWhOSi!kQ%c{Q(y$VQ*`%^Q*b%aQ*c%bQ*e%dQ.y*aS.|*f/OR2{.{Q$XfQ%g!PQ%j!RQ%l!SQ%n!TQ)h$nQ)n$tQ*U%XQ*k%iS.o*V*YQ/V*jQ/W*mQ/X*nS/h+X2TQ1P,wQ1Q,xQ1W,}Q1v-|Q1{.TQ2f.fQ2p.qQ2z.zY3Y/j/k/p/t4uQ4O1RQ4Q1TQ4T1XQ4h1xQ4k1|Q5Q2gQ5W2o[5f3X3[3_3a3b6cQ5}4PQ6Q4UQ6X4fQ6j5RQ6o5XW6u5g5k5m5oQ7P6OQ7R6RQ7V6YQ7Y6^Q7c6kU7g6v6z6|Q7n7QQ7p7TQ7r7ZQ7y7dS7{7h7lQ8P7oQ8Q7sQ8V7|Q8X8RQ8[8WQ8]8YR8_8^Q$blQ&a!gU)W$c$d$eQ*w%}U+h&b&c&dQ,w(^S-q)X)YQ/_*yQ/g+XS/y+i+jQ1T,{Q1n-rQ3V/eS3]/l/pQ3g/zQ4U1YS5j3^3bQ6y5lR7k6{S#q`9sR)R$_U#y`$_9sR-X(lQ#p`S&r!t)SQ&v!vQ'a#aQ(Q#rQ(W#tQ(q#}Q(r$OQ(v$SQ+c&_Q+u8wQ+v8yQ+w8{Q,g'zQ,h'|Q,i'}Q,q(UQ,u(YQ-V(jQ-W(kd-c(}-h.a1h2b4a4z6Z6g7bQ-f)PQ.T)pQ.V)sQ/w+fQ0Q9RQ0R9TQ0S9VQ0T+zQ0h8sQ0y,rQ0},tQ1b-^Q1k-jQ1|.UQ2O.XQ2`.cQ3j9ZQ3n8xQ3o8zQ3p8|Q3u0rQ3|0{Q4S1VQ4Z1^Q4]1eQ4b1lQ4j1zQ4}2dQ5q9_Q5s9WQ5t9SQ5u9UQ5|3{Q6S4XQ6i5PQ6}9[Q7m9`Q9g9sQ9q9yR9r9zlfOSi{!k$V%^%a%b%d*a*f.{/OS!mU%`Q%i!QQ%o!UQ&}!yQ'n#hS*Y%V%YQ*^%ZQ*j%hQ*t%{Q+b&^Q,_'oQ-e)OQ.v*]Q/v+eQ0n,YQ1`-[Q1j-iQ2_.bQ2r.sQ2s.tQ2u.uQ2w.wQ3O/QQ3s0kQ4i1yQ4|2cQ5]2vQ5_2xQ5`2yQ6h5OR6q5^!vYOSUi{!Q!k!y$V%V%Y%Z%^%`%a%b%d%h%{&^)O*]*a*f+e-[-i.b.s.t.u.w.{/O/Q1y2c2v2x2y5O5^Q!]RQ!lTQ$ZjQ%r!ZQ%v!^Q&q!sQ&x!wQ'O!|Q'P!}Q'Q#OQ'R#PQ'S#QQ'T#RQ'U#SQ'V#TQ'W#UQ'X#VQ'Y#WQ'[#YQ'_#_Q'c#bW'm#h'o,Y0kQ)b$iQ*q%sS*z&P/`Q+T&WQ+k&hQ+y&uQ,P&yQ,S8`Q,U8bQ,a'uQ-_(wQ/Z*uQ/^*xQ/{+lQ0V+}Q0Z8eQ0[8fQ0]8gQ0^8hQ0_8iQ0`8jQ0a8kQ0b8lQ0c8mQ0d8nQ0e8oQ0f8pQ0g,TQ0j8tQ0o8qQ1c-aQ1o-sQ3U8}Q3X/iQ3h/|Q3k0WQ3l9OQ3q9QQ3r9XQ4o2RQ5d3SQ5g3ZQ5r9YQ5v9]Q5w9^Q6v5hQ7X6[Q7h6xQ7|7jQ8W8OQ8a!UR9l9vT!VQ!WR!_RR&R!`S%}!`*|S*y&O&VR/e+SR&w!vR&z!wT!qU$TS!pU$TU$spq*_S&k!o!rQ+p&lQ+s&oQ.Q)lS/}+o+qR3i0O[!bR!^$p&X)j+Vh!nUpq!o!r$T&l&o)l+o+q0OQ.x*_Q/[*vQ3R/UT9d&P)kT!dR$pS!cR$pS%w!^)jS*{&P)kQ+U&XR/f+VT&U!`$qQ#f]R's#kT'i#f'jR0m,XT(T#r(]R(Z#tQ-d(}Q1i-hQ2^.aQ4_1hQ4{2bQ6V4aQ6e4zQ7W6ZQ7a6gR7x7blgOSi{!k$V%^%a%b%d*a*f.{/OQ%WwR*U%TV$tpq*_R.Z)uR*T%RQ$lnR)g$mR)^$gT%[x%_T%]x%_T.}*f/O", nodeNames: "⚠ ArithOp ArithOp extends LineComment BlockComment Script ExportDeclaration export Star as VariableName from String ; default FunctionDeclaration async function VariableDefinition TypeParamList TypeDefinition ThisType this LiteralType ArithOp Number BooleanLiteral VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString null super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyNameDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression await yield delete LogicOp BitOp ParenthesizedExpression ClassExpression class extends ClassBody MethodDeclaration Privacy static abstract PropertyDeclaration readonly Optional TypeAnnotation Equals FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp in instanceof const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplatExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try catch finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement", maxTerm: 321, nodeProps: [[mr.group, -26, 7, 14, 16, 53, 175, 179, 182, 183, 185, 188, 191, 202, 204, 210, 212, 214, 216, 219, 225, 229, 231, 233, 235, 237, 239, 240, "Statement", -30, 11, 13, 23, 26, 27, 37, 38, 39, 40, 42, 47, 55, 63, 69, 70, 83, 84, 93, 94, 110, 113, 115, 116, 117, 118, 120, 121, 139, 140, 142, "Expression", -21, 22, 24, 28, 30, 143, 145, 147, 148, 150, 151, 152, 154, 155, 156, 158, 159, 160, 169, 171, 173, 174, "Type", -2, 74, 78, "ClassItem"], [mr.closedBy, 36, "]", 46, "}", 61, ")", 123, "JSXSelfCloseEndTag JSXEndTag", 137, "JSXEndTag"], [mr.openedBy, 41, "[", 45, "{", 60, "(", 122, "JSXStartTag", 132, "JSXStartTag JSXStartCloseTag"]], skippedNodes: [0, 4, 5], repeatNodeCount: 27, tokenData: "!?v~R!ZOX$tX^%S^p$tpq%Sqr&rrs'zst$ttu/wuv2Xvw2|wx3zxy:byz:rz{;S{|<S|}<g}!O<S!O!P<w!P!QAT!Q!R!-s!R![!/Y![!]!4x!]!^!5[!^!_!5l!_!`!6i!`!a!7a!a!b!9W!b!c$t!c!}/w!}#O!:i#O#P$t#P#Q!:y#Q#R!;Z#R#S/w#S#T!;n#T#o/w#o#p!<O#p#q!<T#q#r!<k#r#s!<}#s#y$t#y#z%S#z$f$t$f$g%S$g#BY/w#BY#BZ!=_#BZ$IS/w$IS$I_!=_$I_$I|/w$I|$JO!=_$JO$JT/w$JT$JU!=_$JU$KV/w$KV$KW!=_$KW&FU/w&FU&FV!=_&FV~/wW$yR#{WO!^$t!_#o$t#p~$t,T%Zg#{W&}+{OX$tX^%S^p$tpq%Sq!^$t!_#o$t#p#y$t#y#z%S#z$f$t$f$g%S$g#BY$t#BY#BZ%S#BZ$IS$t$IS$I_%S$I_$I|$t$I|$JO%S$JO$JT$t$JT$JU%S$JU$KV$t$KV$KW%S$KW&FU$t&FU&FV%S&FV~$t$T&yS#{W!e#{O!^$t!_!`'V!`#o$t#p~$t$O'^S#[#v#{WO!^$t!_!`'j!`#o$t#p~$t$O'qR#[#v#{WO!^$t!_#o$t#p~$t'u(RZ#{W]!ROY'zYZ(tZr'zrs*Rs!^'z!^!_*e!_#O'z#O#P,q#P#o'z#o#p*e#p~'z&r(yV#{WOr(trs)`s!^(t!^!_)p!_#o(t#o#p)p#p~(t&r)gR#v&j#{WO!^$t!_#o$t#p~$t&j)sROr)prs)|s~)p&j*RO#v&j'u*[R#v&j#{W]!RO!^$t!_#o$t#p~$t'm*jV]!ROY*eYZ)pZr*ers+Ps#O*e#O#P+W#P~*e'm+WO#v&j]!R'm+ZROr*ers+ds~*e'm+kU#v&j]!ROY+}Zr+}rs,fs#O+}#O#P,k#P~+}!R,SU]!ROY+}Zr+}rs,fs#O+}#O#P,k#P~+}!R,kO]!R!R,nPO~+}'u,vV#{WOr'zrs-]s!^'z!^!_*e!_#o'z#o#p*e#p~'z'u-fZ#v&j#{W]!ROY.XYZ$tZr.Xrs/Rs!^.X!^!_+}!_#O.X#O#P/c#P#o.X#o#p+}#p~.X!Z.`Z#{W]!ROY.XYZ$tZr.Xrs/Rs!^.X!^!_+}!_#O.X#O#P/c#P#o.X#o#p+}#p~.X!Z/YR#{W]!RO!^$t!_#o$t#p~$t!Z/hT#{WO!^.X!^!_+}!_#o.X#o#p+}#p~.X&i0S_#{W#qS'Yp'P%kOt$ttu/wu}$t}!O1R!O!Q$t!Q![/w![!^$t!_!c$t!c!}/w!}#R$t#R#S/w#S#T$t#T#o/w#p$g$t$g~/w[1Y_#{W#qSOt$ttu1Ru}$t}!O1R!O!Q$t!Q![1R![!^$t!_!c$t!c!}1R!}#R$t#R#S1R#S#T$t#T#o1R#p$g$t$g~1R$O2`S#T#v#{WO!^$t!_!`2l!`#o$t#p~$t$O2sR#{W#f#vO!^$t!_#o$t#p~$t%r3TU'm%j#{WOv$tvw3gw!^$t!_!`2l!`#o$t#p~$t$O3nS#{W#`#vO!^$t!_!`2l!`#o$t#p~$t'u4RZ#{W]!ROY3zYZ4tZw3zwx*Rx!^3z!^!_5l!_#O3z#O#P7l#P#o3z#o#p5l#p~3z&r4yV#{WOw4twx)`x!^4t!^!_5`!_#o4t#o#p5`#p~4t&j5cROw5`wx)|x~5`'m5qV]!ROY5lYZ5`Zw5lwx+Px#O5l#O#P6W#P~5l'm6ZROw5lwx6dx~5l'm6kU#v&j]!ROY6}Zw6}wx,fx#O6}#O#P7f#P~6}!R7SU]!ROY6}Zw6}wx,fx#O6}#O#P7f#P~6}!R7iPO~6}'u7qV#{WOw3zwx8Wx!^3z!^!_5l!_#o3z#o#p5l#p~3z'u8aZ#v&j#{W]!ROY9SYZ$tZw9Swx/Rx!^9S!^!_6}!_#O9S#O#P9|#P#o9S#o#p6}#p~9S!Z9ZZ#{W]!ROY9SYZ$tZw9Swx/Rx!^9S!^!_6}!_#O9S#O#P9|#P#o9S#o#p6}#p~9S!Z:RT#{WO!^9S!^!_6}!_#o9S#o#p6}#p~9S%V:iR!_$}#{WO!^$t!_#o$t#p~$tZ:yR!^R#{WO!^$t!_#o$t#p~$t%R;]U'Q!R#U#v#{WOz$tz{;o{!^$t!_!`2l!`#o$t#p~$t$O;vS#R#v#{WO!^$t!_!`2l!`#o$t#p~$t$u<ZSi$m#{WO!^$t!_!`2l!`#o$t#p~$t&i<nR|&a#{WO!^$t!_#o$t#p~$t&i=OVq%n#{WO!O$t!O!P=e!P!Q$t!Q![>Z![!^$t!_#o$t#p~$ty=jT#{WO!O$t!O!P=y!P!^$t!_#o$t#p~$ty>QR{q#{WO!^$t!_#o$t#p~$ty>bZ#{WjqO!Q$t!Q![>Z![!^$t!_!g$t!g!h?T!h#R$t#R#S>Z#S#X$t#X#Y?T#Y#o$t#p~$ty?YZ#{WO{$t{|?{|}$t}!O?{!O!Q$t!Q![@g![!^$t!_#R$t#R#S@g#S#o$t#p~$ty@QV#{WO!Q$t!Q![@g![!^$t!_#R$t#R#S@g#S#o$t#p~$ty@nV#{WjqO!Q$t!Q![@g![!^$t!_#R$t#R#S@g#S#o$t#p~$t,TA[`#{W#S#vOYB^YZ$tZzB^z{HT{!PB^!P!Q!*|!Q!^B^!^!_Da!_!`!+u!`!a!,t!a!}B^!}#OFY#O#PGi#P#oB^#o#pDa#p~B^XBe[#{WxPOYB^YZ$tZ!PB^!P!QCZ!Q!^B^!^!_Da!_!}B^!}#OFY#O#PGi#P#oB^#o#pDa#p~B^XCb_#{WxPO!^$t!_#Z$t#Z#[CZ#[#]$t#]#^CZ#^#a$t#a#bCZ#b#g$t#g#hCZ#h#i$t#i#jCZ#j#m$t#m#nCZ#n#o$t#p~$tPDfVxPOYDaZ!PDa!P!QD{!Q!}Da!}#OEd#O#PFP#P~DaPEQUxP#Z#[D{#]#^D{#a#bD{#g#hD{#i#jD{#m#nD{PEgTOYEdZ#OEd#O#PEv#P#QDa#Q~EdPEyQOYEdZ~EdPFSQOYDaZ~DaXF_Y#{WOYFYYZ$tZ!^FY!^!_Ed!_#OFY#O#PF}#P#QB^#Q#oFY#o#pEd#p~FYXGSV#{WOYFYYZ$tZ!^FY!^!_Ed!_#oFY#o#pEd#p~FYXGnV#{WOYB^YZ$tZ!^B^!^!_Da!_#oB^#o#pDa#p~B^,TH[^#{WxPOYHTYZIWZzHTz{Ki{!PHT!P!Q!)j!Q!^HT!^!_Mt!_!}HT!}#O!%e#O#P!(x#P#oHT#o#pMt#p~HT,TI]V#{WOzIWz{Ir{!^IW!^!_Jt!_#oIW#o#pJt#p~IW,TIwX#{WOzIWz{Ir{!PIW!P!QJd!Q!^IW!^!_Jt!_#oIW#o#pJt#p~IW,TJkR#{WT+{O!^$t!_#o$t#p~$t+{JwROzJtz{KQ{~Jt+{KTTOzJtz{KQ{!PJt!P!QKd!Q~Jt+{KiOT+{,TKp^#{WxPOYHTYZIWZzHTz{Ki{!PHT!P!QLl!Q!^HT!^!_Mt!_!}HT!}#O!%e#O#P!(x#P#oHT#o#pMt#p~HT,TLu_#{WT+{xPO!^$t!_#Z$t#Z#[CZ#[#]$t#]#^CZ#^#a$t#a#bCZ#b#g$t#g#hCZ#h#i$t#i#jCZ#j#m$t#m#nCZ#n#o$t#p~$t+{MyYxPOYMtYZJtZzMtz{Ni{!PMt!P!Q!$a!Q!}Mt!}#O! w#O#P!#}#P~Mt+{NnYxPOYMtYZJtZzMtz{Ni{!PMt!P!Q! ^!Q!}Mt!}#O! w#O#P!#}#P~Mt+{! eUT+{xP#Z#[D{#]#^D{#a#bD{#g#hD{#i#jD{#m#nD{+{! zWOY! wYZJtZz! wz{!!d{#O! w#O#P!#k#P#QMt#Q~! w+{!!gYOY! wYZJtZz! wz{!!d{!P! w!P!Q!#V!Q#O! w#O#P!#k#P#QMt#Q~! w+{!#[TT+{OYEdZ#OEd#O#PEv#P#QDa#Q~Ed+{!#nTOY! wYZJtZz! wz{!!d{~! w+{!$QTOYMtYZJtZzMtz{Ni{~Mt+{!$f_xPOzJtz{KQ{#ZJt#Z#[!$a#[#]Jt#]#^!$a#^#aJt#a#b!$a#b#gJt#g#h!$a#h#iJt#i#j!$a#j#mJt#m#n!$a#n~Jt,T!%j[#{WOY!%eYZIWZz!%ez{!&`{!^!%e!^!_! w!_#O!%e#O#P!(W#P#QHT#Q#o!%e#o#p! w#p~!%e,T!&e^#{WOY!%eYZIWZz!%ez{!&`{!P!%e!P!Q!'a!Q!^!%e!^!_! w!_#O!%e#O#P!(W#P#QHT#Q#o!%e#o#p! w#p~!%e,T!'hY#{WT+{OYFYYZ$tZ!^FY!^!_Ed!_#OFY#O#PF}#P#QB^#Q#oFY#o#pEd#p~FY,T!(]X#{WOY!%eYZIWZz!%ez{!&`{!^!%e!^!_! w!_#o!%e#o#p! w#p~!%e,T!(}X#{WOYHTYZIWZzHTz{Ki{!^HT!^!_Mt!_#oHT#o#pMt#p~HT,T!)qc#{WxPOzIWz{Ir{!^IW!^!_Jt!_#ZIW#Z#[!)j#[#]IW#]#^!)j#^#aIW#a#b!)j#b#gIW#g#h!)j#h#iIW#i#j!)j#j#mIW#m#n!)j#n#oIW#o#pJt#p~IW,T!+TV#{WS+{OY!*|YZ$tZ!^!*|!^!_!+j!_#o!*|#o#p!+j#p~!*|+{!+oQS+{OY!+jZ~!+j$P!,O[#{W#f#vxPOYB^YZ$tZ!PB^!P!QCZ!Q!^B^!^!_Da!_!}B^!}#OFY#O#PGi#P#oB^#o#pDa#p~B^]!,}[#nS#{WxPOYB^YZ$tZ!PB^!P!QCZ!Q!^B^!^!_Da!_!}B^!}#OFY#O#PGi#P#oB^#o#pDa#p~B^y!-zd#{WjqO!O$t!O!P>Z!P!Q$t!Q![!/Y![!^$t!_!g$t!g!h?T!h#R$t#R#S!/Y#S#U$t#U#V!0p#V#X$t#X#Y?T#Y#b$t#b#c!0`#c#d!2O#d#l$t#l#m!3W#m#o$t#p~$ty!/a_#{WjqO!O$t!O!P>Z!P!Q$t!Q![!/Y![!^$t!_!g$t!g!h?T!h#R$t#R#S!/Y#S#X$t#X#Y?T#Y#b$t#b#c!0`#c#o$t#p~$ty!0gR#{WjqO!^$t!_#o$t#p~$ty!0uW#{WO!Q$t!Q!R!1_!R!S!1_!S!^$t!_#R$t#R#S!1_#S#o$t#p~$ty!1fW#{WjqO!Q$t!Q!R!1_!R!S!1_!S!^$t!_#R$t#R#S!1_#S#o$t#p~$ty!2TV#{WO!Q$t!Q!Y!2j!Y!^$t!_#R$t#R#S!2j#S#o$t#p~$ty!2qV#{WjqO!Q$t!Q!Y!2j!Y!^$t!_#R$t#R#S!2j#S#o$t#p~$ty!3]Z#{WO!Q$t!Q![!4O![!^$t!_!c$t!c!i!4O!i#R$t#R#S!4O#S#T$t#T#Z!4O#Z#o$t#p~$ty!4VZ#{WjqO!Q$t!Q![!4O![!^$t!_!c$t!c!i!4O!i#R$t#R#S!4O#S#T$t#T#Z!4O#Z#o$t#p~$t%w!5RR!WV#{W#d%hO!^$t!_#o$t#p~$t!P!5cR^w#{WO!^$t!_#o$t#p~$t+c!5wR'Ud![%Y#o&s'qP!P!Q!6Q!^!_!6V!_!`!6dW!6VO#}W#v!6[P#V#v!_!`!6_#v!6dO#f#v#v!6iO#W#v%w!6pT!t%o#{WO!^$t!_!`'V!`!a!7P!a#o$t#p~$t$P!7WR#O#w#{WO!^$t!_#o$t#p~$t%w!7lT'T!s#W#v#xS#{WO!^$t!_!`!7{!`!a!8]!a#o$t#p~$t$O!8SR#W#v#{WO!^$t!_#o$t#p~$t$O!8dT#V#v#{WO!^$t!_!`2l!`!a!8s!a#o$t#p~$t$O!8zS#V#v#{WO!^$t!_!`2l!`#o$t#p~$t%w!9_V'e%o#{WO!O$t!O!P!9t!P!^$t!_!a$t!a!b!:U!b#o$t#p~$t$`!9{Rr$W#{WO!^$t!_#o$t#p~$t$O!:]S#{W#a#vO!^$t!_!`2l!`#o$t#p~$t&e!:pRt&]#{WO!^$t!_#o$t#p~$tZ!;QRyR#{WO!^$t!_#o$t#p~$t$O!;bS#^#v#{WO!^$t!_!`2l!`#o$t#p~$t$P!;uR#{W']#wO!^$t!_#o$t#p~$t~!<TO!O~%r!<[T'l%j#{WO!^$t!_!`2l!`#o$t#p#q!:U#q~$t$u!<tR}$k#{W'_QO!^$t!_#o$t#p~$tX!=UR!fP#{WO!^$t!_#o$t#p~$t,T!=lr#{W#qS'Yp'P%k&}+{OX$tX^%S^p$tpq%Sqt$ttu/wu}$t}!O1R!O!Q$t!Q![/w![!^$t!_!c$t!c!}/w!}#R$t#R#S/w#S#T$t#T#o/w#p#y$t#y#z%S#z$f$t$f$g%S$g#BY/w#BY#BZ!=_#BZ$IS/w$IS$I_!=_$I_$I|/w$I|$JO!=_$JO$JT/w$JT$JU!=_$JU$KV/w$KV$KW!=_$KW&FU/w&FU&FV!=_&FV~/w", tokenizers: [Gs, Qe, Bs, 0, 1, 2, 3, 4, 5, 6, 7, 8, ro], topRules: { Script: [0, 6] }, dialects: { jsx: 11074, ts: 11076 }, dynamicPrecedences: { 140: 1, 167: 1 }, specialized: [{ term: 277, get: (t, e) => function (t, e) { return "extends" == t && e.dialectEnabled(1) ? 3 : -1 }(t, e) << 1 | 1 }, { term: 277, get: t => ih[t] || -1 }, { term: 286, get: t => nh[t] || -1 }, { term: 58, get: t => rh[t] || -1 }], tokenPrec: 11096 }); const oh = er.baseTheme({ ".cm-tooltip.cm-tooltip-autocomplete": { "& > ul": { fontFamily: "monospace", whiteSpace: "nowrap", overflow: "auto", maxWidth_fallback: "700px", maxWidth: "min(700px, 95vw)", maxHeight: "10em", listStyle: "none", margin: 0, padding: 0, "& > li": { cursor: "pointer", padding: "1px 1em 1px 3px", lineHeight: 1.2 }, "& > li[aria-selected]": { background_fallback: "#bdf", backgroundColor: "Highlight", color_fallback: "white", color: "HighlightText" } } }, ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": { content: '"···"', opacity: .5, display: "block", textAlign: "center" }, ".cm-tooltip.cm-completionInfo": { position: "absolute", padding: "3px 9px", width: "max-content", maxWidth: "300px" }, ".cm-completionInfo.cm-completionInfo-left": { right: "100%" }, ".cm-completionInfo.cm-completionInfo-right": { left: "100%" }, "&light .cm-snippetField": { backgroundColor: "#00000022" }, "&dark .cm-snippetField": { backgroundColor: "#ffffff22" }, ".cm-snippetFieldPosition": { verticalAlign: "text-top", width: 0, height: "1.15em", margin: "0 -0.7px -.7em", borderLeft: "1.4px dotted #888" }, ".cm-completionMatchedText": { textDecoration: "underline" }, ".cm-completionDetail": { marginLeft: "0.5em", fontStyle: "italic" }, ".cm-completionIcon": { fontSize: "90%", width: ".8em", display: "inline-block", textAlign: "center", paddingRight: ".6em", opacity: "0.6" }, ".cm-completionIcon-function, .cm-completionIcon-method": { "&:after": { content: "'ƒ'" } }, ".cm-completionIcon-class": { "&:after": { content: "'○'" } }, ".cm-completionIcon-interface": { "&:after": { content: "'◌'" } }, ".cm-completionIcon-variable": { "&:after": { content: "'𝑥'" } }, ".cm-completionIcon-constant": { "&:after": { content: "'𝐶'" } }, ".cm-completionIcon-type": { "&:after": { content: "'𝑡'" } }, ".cm-completionIcon-enum": { "&:after": { content: "'∪'" } }, ".cm-completionIcon-property": { "&:after": { content: "'□'" } }, ".cm-completionIcon-keyword": { "&:after": { content: "'🔑︎'" } }, ".cm-completionIcon-namespace": { "&:after": { content: "'▢'" } }, ".cm-completionIcon-text": { "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" } } }); class ah { constructor(t, e, i, n) { this.field = t, this.line = e, this.from = i, this.to = n } } class lh { constructor(t, e, i) { this.field = t, this.from = e, this.to = i } map(t) { return new lh(this.field, t.mapPos(this.from, -1), t.mapPos(this.to, 1)) } } class hh { constructor(t, e) { this.lines = t, this.fieldPositions = e } instantiate(n, t) { let e = [], r = [t]; var s, i = n.doc.lineAt(t), o = /^\s*/.exec(i.text)[0]; for (s of this.lines) { if (e.length) { let e = o, i = /^\t*/.exec(s)[0].length; for (let t = 0; t < i; t++)e += n.facet(Jr); r.push(t + e.length - i), s = e + s.slice(i) } e.push(s), t += s.length + 1 } i = this.fieldPositions.map(t => new lh(t.field, r[t.line] + t.from, r[t.line] + t.to)); return { text: e, ranges: i } } static parse(t) { let r = [], s = [], o = [], a; for (var l of t.split(/\r\n?|\n/)) { for (; a = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(l);) { let e = a[1] ? +a[1] : null, i = a[2] || a[3], n = -1; for (let t = 0; t < r.length; t++)(null != e ? r[t].seq == e : i && r[t].name == i) && (n = t); if (n < 0) { let t = 0; for (; t < r.length && (null == e || null != r[t].seq && r[t].seq < e);)t++; r.splice(t, 0, { seq: e, name: i || null }), n = t; for (var h of o) h.field >= n && h.field++ } o.push(new ah(n, s.length, a.index, a.index + i.length)), l = l.slice(0, a.index) + i + l.slice(a.index + a[0].length) } s.push(l) } return new hh(s, o) } } let ch = Me.widget({ widget: new class extends Ve { toDOM() { let t = document.createElement("span"); return t.className = "cm-snippetFieldPosition", t } ignoreEvent() { return !1 } } }), Oh = Me.mark({ class: "cm-snippetField" }); class dh { constructor(t, e) { this.ranges = t, this.active = e, this.deco = Me.set(t.map(t => (t.from == t.to ? ch : Oh).range(t.from, t.to))) } map(e) { return new dh(this.ranges.map(t => t.map(e)), this.active) } selectionInsideField(t) { return t.ranges.every(e => this.ranges.some(t => t.field == this.active && t.from <= e.from && t.to >= e.to)) } } const uh = rt.define({ map(t, e) { return t && t.map(e) } }), fh = rt.define(), ph = M.define({ create() { return null }, update(t, e) { for (var i of e.effects) { if (i.is(uh)) return i.value; if (i.is(fh) && t) return new dh(t.ranges, i.value) } return t = (t = t && e.docChanged ? t.map(e.changes) : t) && e.selection && !t.selectionInsideField(e.selection) ? null : t }, provide: t => er.decorations.from(t, t => t ? t.deco : Me.none) }); function mh(t, e) { return _.create(t.filter(t => t.field == e).map(t => _.range(t.from, t.to))) } function gh(s) { return ({ state: t, dispatch: e }) => { let i = t.field(ph, !1); if (!i || s < 0 && 0 == i.active) return !1; let n = i.active + s, r = 0 < s && !i.ranges.some(t => t.field == n + s); return e(t.update({ selection: mh(i.ranges, n), effects: uh.of(r ? null : new dh(i.ranges, n)) })), !0 } } var Qh, vh, wh; const $h = [{ key: "Tab", run: gh(1), shift: gh(-1) }, { key: "Escape", run: ({ state: t, dispatch: e }) => { return !!t.field(ph, !1) && (e(t.update({ effects: uh.of(null) })), !0) } }], yh = L.define({ combine(t) { return t.length ? t[0] : $h } }), bh = E.override(cr.compute([yh], t => t.facet(yh))); function xh(t, e) { return Object.assign(Object.assign({}, e), { apply: function (t) { let a = hh.parse(t); return (i, t, e, n) => { var { text: r, ranges: s } = a.instantiate(i.state, e); let o = { changes: { from: e, to: n, insert: d.of(r) } }; if (s.length && (o.selection = mh(s, 0)), 1 < s.length) { let t = new dh(s, 0), e = o.effects = [uh.of(t)]; void 0 === i.state.field(ph, !1) && e.push(rt.appendConfig.of([ph.init(() => t), bh, kh, oh])) } i.dispatch(i.state.update(o)) } }(t) }) } const kh = er.domEventHandlers({ mousedown(t, e) { let i = e.state.field(ph, !1), n; if (!i || null == (n = e.posAtCoords({ x: t.clientX, y: t.clientY }))) return !1; let r = i.ranges.find(t => t.from <= n && t.to >= n); return !(!r || r.field == i.active) && (e.dispatch({ selection: mh(i.ranges, r.field), effects: uh.of(i.ranges.some(t => t.field > r.field) ? new dh(i.ranges, r.field) : null) }), !0) } }); xh("function ${name}(${params}) {\n\t${}\n}", { label: "function", detail: "definition", type: "keyword" }), xh("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}", { label: "for", detail: "loop", type: "keyword" }), xh("for (let ${name} of ${collection}) {\n\t${}\n}", { label: "for", detail: "of loop", type: "keyword" }), xh("try {\n\t${}\n} catch (${error}) {\n\t${}\n}", { label: "try", detail: "block", type: "keyword" }), xh("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}", { label: "class", detail: "definition", type: "keyword" }), xh('import {${names}} from "${module}"\n${}', { label: "import", detail: "named", type: "keyword" }), xh('import ${name} from "${module}"\n${}', { label: "import", detail: "default", type: "keyword" }); const Sh = Yr.define({ parser: sh.configure({ props: [ns.add({ IfStatement: hs({ except: /^\s*({|else\b)/ }), TryStatement: hs({ except: /^\s*({|catch|finally)\b/ }), LabeledStatement: t => t.baseIndent, SwitchBody: t => { var e = t.textAfter, i = /^\s*\}/.test(e), e = /^\s*(case|default)\b/.test(e); return t.baseIndent + (i ? 0 : e ? 1 : 2) * t.unit }, Block: ([{ closing: Qh, align: vh = !0, units: wh = 1 }] = [{ closing: "}" }], t => ls(t, vh, wh, Qh)), ArrowFunction: t => t.baseIndent + t.unit, "TemplateString BlockComment": () => -1, "Statement Property": hs({ except: /^{/ }), JSXElement(t) { var e = /^\s*<\//.test(t.textAfter); return t.lineIndent(t.state.doc.lineAt(t.node.from)) + (e ? 0 : t.unit) }, JSXEscape(t) { var e = /\s*\}/.test(t.textAfter); return t.lineIndent(t.state.doc.lineAt(t.node.from)) + (e ? 0 : t.unit) }, "JSXOpenTag JSXSelfClosingTag"(t) { return t.column(t.node.from) + t.unit } }), cs.add({ "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": Os, BlockComment(t) { return { from: t.from + 2, to: t.to - 2 } } }), Vo({ "get set async static": No.modifier, "for while do if else switch try catch finally return throw break continue default case": No.controlKeyword, "in of await yield void typeof delete instanceof": No.operatorKeyword, "export import let var const function class extends": No.definitionKeyword, "with debugger from as new": No.keyword, TemplateString: No.special(No.string), Super: No.atom, BooleanLiteral: No.bool, this: No.self, null: No.null, Star: No.modifier, VariableName: No.variableName, "CallExpression/VariableName": No.function(No.variableName), VariableDefinition: No.definition(No.variableName), Label: No.labelName, PropertyName: No.propertyName, "CallExpression/MemberExpression/PropertyName": No.function(No.propertyName), "FunctionDeclaration/VariableDefinition": No.function(No.definition(No.variableName)), "ClassDeclaration/VariableDefinition": No.definition(No.className), PropertyNameDefinition: No.definition(No.propertyName), UpdateOp: No.updateOperator, LineComment: No.lineComment, BlockComment: No.blockComment, Number: No.number, String: No.string, ArithOp: No.arithmeticOperator, LogicOp: No.logicOperator, BitOp: No.bitwiseOperator, CompareOp: No.compareOperator, RegExp: No.regexp, Equals: No.definitionOperator, "Arrow : Spread": No.punctuation, "( )": No.paren, "[ ]": No.squareBracket, "{ }": No.brace, ".": No.derefOperator, ", ;": No.separator, TypeName: No.typeName, TypeDefinition: No.definition(No.typeName), "type enum interface implements namespace module declare": No.definitionKeyword, "abstract global privacy readonly": No.modifier, "is keyof unique infer": No.operatorKeyword, JSXAttributeValue: No.string, JSXText: No.content, "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": No.angleBracket, "JSXIdentifier JSXNameSpacedName": No.tagName, "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": No.propertyName })] }), languageData: { closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }, commentTokens: { line: "//", block: { open: "/*", close: "*/" } }, indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/, wordChars: "$" } }); Sh.configure({ dialect: "ts" }), Sh.configure({ dialect: "jsx" }), Sh.configure({ dialect: "jsx ts" }); Ds = Yr.define({ parser: Ds.configure({ props: [ns.add({ Element(t) { var e = /^(\s*)(<\/)?/.exec(t.textAfter); return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.state.doc.lineAt(t.node.from)) + (e[2] ? 0 : t.unit) }, "OpenTag CloseTag SelfClosingTag"(t) { return t.column(t.node.from) + t.unit }, Document(e) { if (e.pos + /\s*/.exec(e.textAfter)[0].length < e.node.to) return e.continue(); let i = null, t; for (let t = e.node; ;) { var n = t.lastChild; if (!n || "Element" != n.name || n.to != t.to) break; i = t = n } return i && (!(t = i.lastChild) || "CloseTag" != t.name && "SelfClosingTag" != t.name) ? e.lineIndent(e.state.doc.lineAt(i.from)) + e.unit : null } }), cs.add({ Element(t) { var e = t.firstChild, i = t.lastChild; return e && "OpenTag" == e.name ? { from: e.to, to: "CloseTag" == i.name ? i.from : t.to } : null } }), Vo({ AttributeValue: No.string, "Text RawText": No.content, "StartTag StartCloseTag SelfCloserEndTag EndTag SelfCloseEndTag": No.angleBracket, TagName: No.tagName, "MismatchedCloseTag/TagName": [No.tagName, No.invalid], AttributeName: No.propertyName, UnquotedAttributeValue: No.string, Is: No.definitionOperator, "EntityReference CharacterReference": No.character, Comment: No.blockComment, ProcessingInst: No.processingInstruction, DoctypeDecl: No.documentMeta })], nested: Yl([{ tag: "script", attrs(t) { return !t.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type) }, parser: Sh.parser }, { tag: "style", attrs(t) { return (!t.lang || "css" == t.lang) && (!t.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t.type)) }, parser: Jl.parser }]) }), languageData: { commentTokens: { block: { open: "\x3c!--", close: "--\x3e" } }, indentOnInput: /^\s*<\/$/ } }); const Ph = zr({ block: { open: "\x3c!--", close: "--\x3e" } }); Ds = Ja.configure({ props: [Vo({ "Blockquote/...": No.quote, HorizontalRule: No.contentSeparator, "ATXHeading1/... SetextHeading1/...": No.heading1, "ATXHeading2/... SetextHeading2/...": No.heading2, "ATXHeading3/...": No.heading3, "ATXHeading4/...": No.heading4, "ATXHeading5/...": No.heading5, "ATXHeading6/...": No.heading6, "Comment CommentBlock": No.comment, Escape: No.escape, Entity: No.character, "Emphasis/...": No.emphasis, "StrongEmphasis/...": No.strong, "Link/... Image/...": No.link, "OrderedList/... BulletList/...": No.list, "BlockQuote/...": No.quote, "InlineCode/... CodeBlock FencedCode": No.monospace, URL: No.url, "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": No.processingInstruction, "CodeInfo LinkLabel": No.labelName, LinkTitle: No.string, Paragraph: No.content }), cs.add(t => { if (t.is("Block") && !t.is("Document")) return (t, e) => ({ from: e.doc.lineAt(t.from).to, to: t.to }) }), ns.add({ Document: () => null }), Lr.add({ Document: Ph })], htmlParser: Ds.parser.configure({ dialect: "noMatch" }) }); const Th = Xh(Ds), Wh = Xh(Ds.configure([ds, me, eo, { defineNodes: ["Emoji"], parseInline: [{ name: "Emoji", parse(t, e, i) { let n; return 58 == e && (n = /^[a-zA-Z_0-9]+:/.exec(t.slice(i + 1, t.end))) ? t.addElement(t.elt("Emoji", i, i + 1 + n[0].length)) : -1 } }] }, { props: [Vo({ "TableDelimiter SubscriptMark SuperscriptMark StrikethroughMark": No.processingInstruction, "TableHeader/...": No.heading, "Strikethrough/...": No.strikethrough, TaskMarker: No.atom, Task: No.list, Emoji: No.character, "Subscript Superscript": No.special(No.content), TableCell: No.content })] }])); function Xh(t) { return new qr(Ph, t, t.nodeSet.types.find(t => "Document" == t.name)) } function Rh(t, e) { return e.sliceString(t.from, t.from + 50) } function _h(e, n, r) { let s = []; for (let t = e; t && "Document" != t.name; t = t.parent)"ListItem" != t.name && "Blockquote" != t.name || s.push(t); let o = [], a = 0; for (let i = s.length - 1; 0 <= i; i--) { let t = s[i], e; var l; "Blockquote" == t.name && (e = /^\s*> ?/.exec(n.slice(a))) ? (o.push({ from: a, string: e[0], node: t }), a += e[0].length) : "ListItem" == t.name && "OrderedList" == t.parent.name && (e = /^\s*\d+([.)])\s*/.exec(Rh(t, r))) ? (l = 4 <= e[1].length ? e[0].length - e[1].length + 1 : e[0].length, o.push({ from: a, string: n.slice(a, a + l).replace(/\S/g, " "), node: t }), a += l) : "ListItem" == t.name && "BulletList" == t.parent.name && (e = /^\s*[-+*] (\s*)/.exec(Rh(t, r))) && (l = 4 <= e[1].length ? e[0].length - e[1].length : e[0].length, o.push({ from: a, string: n.slice(a, a + l).replace(/\S/g, " "), node: t }), a += l) } return o } const Ch = [{ key: "Enter", run: ({ state: l, dispatch: t }) => { let i = Mr(l), e = null, n = l.changeByRange(o => { if (o.empty && Wh.isActiveAt(l, o.from)) { let n = l.doc.lineAt(o.from), t = _h(i.resolve(o.from, -1), n.text, l.doc), r = o.from, s = []; if (t.length) { let e = t[t.length - 1], i = e.from + e.string.length; var a = o.from - n.from >= i && !/\S/.test(n.text.slice(i, o.from - n.from)); if (a) { let t = /List/.test(e.node.name) ? e.from : i; for (; 0 < t && /\s/.test(n.text[t - 1]);)t--; r = n.from + t } if ("ListItem" == e.node.name) { if (a && 0 < n.from && !/[^\s>]/.test(l.doc.lineAt(n.from - 1).text)) return { range: _.cursor(r), changes: { from: r, to: o.from } }; r < o.from && e.node.parent.from == e.node.from ? e.string = "" : (e.node.from >= n.from ? e.string = n.text.slice(e.from, e.from + e.string.length) : e.string = /^\s*/.exec(n.text)[0].slice(0, e.string.length), "OrderedList" == e.node.parent.name && r == o.from && (e.string = e.string.replace(/\d+/, t => +t + 1), function (i, n, r) { for (let t = -1, e = i; ;) { if ("ListItem" == e.name) { var s = /^(\s*)(\d+)(?=[.)])/.exec(n.sliceString(e.from, e.from + 10)); if (!s) return; var o = +s[2]; if (0 <= t) { if (o != t + 1) return; r.push({ from: e.from + s[1].length, to: e.from + s[0].length, insert: String(t + 2) }) } t = o } o = e.nextSibling; if (!o) break; e = o } }(e.node, l.doc, s))) } } let e = t.map(t => t.string).join(""); return o.from - n.from < e.length && (e = ""), s.push({ from: r, to: o.from, insert: d.of(["", e]) }), { range: _.cursor(r + 1 + e.length), changes: s } } return e = { range: o } }); return !e && (t(l.update(n, { scrollIntoView: !0 })), !0) } }, { key: "Backspace", run: ({ state: s, dispatch: t }) => { let o = Mr(s), a = null, e = s.changeByRange(e => { if (e.empty && Wh.isActiveAt(s, e.from)) { let t = s.doc.lineAt(e.from); var i = _h(o.resolve(e.from, -1), t.text, s.doc); if (i.length) { var n = i[i.length - 1], r = n.from + n.string.length; if (e.from > r + t.from && !/\S/.test(t.text.slice(r, e.from - t.from))) return { range: _.cursor(r + t.from), changes: { from: r + t.from, to: e.from } }; if (e.from - t.from == r) { i = t.from + n.from; return "ListItem" == n.node.name && n.node.parent.from < n.node.from && /\S/.test(t.text.slice(n.from, r)) ? { range: e, changes: { from: i, to: i + n.string.length, insert: n.string } } : { range: _.cursor(i), changes: { from: i, to: e.from } } } } } return a = { range: e } }); return !a && (t(s.update(e, { scrollIntoView: !0 })), !0) } }]; function Ah(t = {}) { let { codeLanguages: e, defaultCodeLanguage: i, addKeymap: n = !0, base: { parser: r } = Th } = t, s = t.extensions ? [t.extensions] : []; if (!(r instanceof Sa)) throw new RangeError("Base parser provided to `markdown` should be a Markdown parser"); var o, a; return (e || i) && s.push((o = e || [], a = i, { codeParser(t) { let e = t && Ur.matchLanguageName(o, t, !0); return e ? e.support ? e.support.language.parser : Er.getSkippingParser(e.load()) : a ? a.parser : null } })), new Nr(Xh(r.configure(s)), n ? E.extend(cr.of(Ch)) : []) } var Lh = [{ type: "undo", title: "撤销", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18"><path d="M76 463.7l294.8 294.9c19.5 19.4 52.8 5.6 52.8-21.9V561.5c202.5-8.2 344.1 59.5 501.6 338.3 8.5 15 31.5 7.9 30.6-9.3-30.5-554.7-453-571.4-532.3-569.6v-174c0-27.5-33.2-41.3-52.7-21.8L75.9 420c-12 12.1-12 31.6.1 43.7z"/></svg>' }, { type: "redo", title: "重做", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18"><path d="M946.8 420L651.9 125.1c-19.5-19.5-52.7-5.7-52.7 21.8v174c-79.3-1.8-501.8 14.9-532.3 569.6-.9 17.2 22.1 24.3 30.6 9.3C255 621 396.6 553.3 599.1 561.5v175.2c0 27.5 33.3 41.3 52.8 21.9l294.8-294.9c12.1-12.1 12.1-31.6.1-43.7z"/></svg>' }, { type: "bold", title: "加粗", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M341.333 469.333h192a106.667 106.667 0 1 0 0-213.333h-192v213.333zm426.667 192a192 192 0 0 1-192 192H256V170.667h277.333a192 192 0 0 1 138.923 324.522A191.915 191.915 0 0 1 768 661.333zM341.333 554.667V768H576a106.667 106.667 0 1 0 0-213.333H341.333z"/></svg>' }, { type: "italic", title: "倾斜", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M640 853.333H298.667V768h124.885l90.283-512H384v-85.333h341.333V256H600.448l-90.283 512H640z"/></svg>' }, { type: "delete", title: "删除", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M731.904 597.333c9.813 22.016 14.763 46.507 14.763 73.387 0 57.259-22.358 102.059-67.03 134.272-44.757 32.213-106.496 48.341-185.301 48.341-69.973 0-139.221-16.256-207.787-48.81v-96.256c64.854 37.418 131.2 56.149 199.083 56.149 108.843 0 163.413-31.232 163.797-93.739a94.293 94.293 0 0 0-27.648-68.394l-5.12-4.992H128v-85.334h768v85.334H731.904zm-173.995-128H325.504a174.336 174.336 0 0 1-20.523-22.272c-18.432-23.808-27.648-52.565-27.648-86.442 0-52.736 19.883-97.579 59.606-134.528 39.808-36.95 101.29-55.424 184.533-55.424 62.763 0 122.837 13.994 180.139 41.984v91.818c-51.2-29.312-107.307-43.946-168.363-43.946-105.813 0-158.677 33.365-158.677 100.096 0 17.92 9.301 33.536 27.904 46.89 18.602 13.355 41.557 23.979 68.821 32 26.453 7.68 55.339 17.664 86.613 29.824z"/></svg>' }, { type: "code-inline", title: "行内代码", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M416.328 512.336a96 96 0 1 0 192 0 96 96 0 1 0-192 0zM336.328 860c-12.288 0-24.568-6-33.944-17.992l-224-286.584c-18.744-23.984-18.744-62.856 0-86.84l224-286.592c18.744-23.976 49.136-23.976 67.88 0 18.744 23.984 18.744 62.864 0 86.848L180.208 512l190.056 243.168c18.744 23.968 18.744 62.856 0 86.832-9.368 12-21.648 18-33.936 18zm352 0c12.28 0 24.568-6 33.936-17.992l224-286.584c18.752-23.984 18.752-62.856 0-86.84l-224-286.592c-18.744-23.976-49.136-23.976-67.872 0-18.752 23.984-18.752 62.864 0 86.848L844.448 512 654.392 755.168c-18.752 23.968-18.752 62.856 0 86.832 9.376 12 21.656 18 33.936 18z"/></svg>' }, { type: "hr", title: "横线", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M896 469.333H128c-25.6 0-42.667 17.067-42.667 42.667S102.4 554.667 128 554.667h768c25.6 0 42.667-17.067 42.667-42.667S921.6 469.333 896 469.333z"/></svg>' }, { type: "quote", title: "引用", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M195.541 739.03C151.595 692.351 128 640 128 555.135c0-149.333 104.832-283.179 257.28-349.355l38.101 58.795c-142.293 76.97-170.112 176.853-181.205 239.83 22.912-11.862 52.907-16 82.304-13.27 76.97 7.125 137.643 70.315 137.643 148.864a149.333 149.333 0 0 1-149.334 149.333 165.163 165.163 0 0 1-117.248-50.304zm426.667 0c-43.947-46.678-67.541-99.03-67.541-183.894 0-149.333 104.832-283.179 257.28-349.355l38.101 58.795c-142.293 76.97-170.112 176.853-181.205 239.83 22.912-11.862 52.906-16 82.304-13.27 76.97 7.125 137.642 70.315 137.642 148.864a149.333 149.333 0 0 1-149.333 149.333 165.163 165.163 0 0 1-117.248-50.304z"/></svg>' }, { type: "title", title: "标题", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="22" height="22"><path d="M256 213.333h104.875v267.094h324.48V213.333h104.874v640H685.355V570.07h-324.48v283.264H256z"/></svg>' }, { type: "ordered-list", title: "有序列表", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M341.333 170.667H896V256H341.333v-85.333zm-128-42.667v128H256v42.667H128V256h42.667v-85.333H128V128h85.333zM128 597.333V490.667h85.333v-21.334H128v-42.666h128v106.666h-85.333v21.334H256v42.666H128zM213.333 832H128v-42.667h85.333V768H128v-42.667h128V896H128v-42.667h85.333V832zm128-362.667H896v85.334H341.333v-85.334zm0 298.667H896v85.333H341.333V768z"/></svg>' }, { type: "unordered-list", title: "无序列表", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M341.333 170.667H896V256H341.333v-85.333zM192 277.333a64 64 0 1 1 0-128 64 64 0 0 1 0 128zM192 576a64 64 0 1 1 0-128 64 64 0 0 1 0 128zm0 294.4a64 64 0 1 1 0-128 64 64 0 0 1 0 128zm149.333-401.067H896v85.334H341.333v-85.334zm0 298.667H896v85.333H341.333V768z"/></svg>' }, { type: "link", title: "超链接", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="15" height="15"><path d="M879.2 131.6c-103-95.5-264.1-88-361.4 11.2L474.7 184c-13.1 13.1-3.7 35.6 13.1 37.5 26.2 1.9 52.4 7.5 78.7 15 7.5 1.9 16.9 0 22.5-5.6l9.4-9.4c54.3-54.3 142.3-59.9 198.5-11.2 63.7 54.3 65.5 151.7 7.5 209.7L662 562.3c-18.7 18.7-41.2 30-63.7 37.5-30 7.5-61.8 5.6-89.9-5.6-16.9-7.5-33.7-16.9-48.7-31.8-7.5-7.5-13.1-15-18.7-24.3-7.5-13.1-24.3-15-33.7-3.7l-52.4 52.4c-7.5 7.5-7.5 18.7-1.9 28.1 7.5 11.2 16.9 20.6 26.2 30 13.1 13.1 30 26.2 44.9 35.6 26.2 16.9 56.2 28.1 86.1 33.7 58.1 11.2 121.7 1.9 174.2-26.2 20.6-11.2 41.2-26.2 58.1-43.1l142.3-142.3c104.9-103.2 101.2-271.8-5.6-371zM534.7 803.9l-39.3-5.6s-26.2-5.6-39.3-11.2c-7.5-1.9-16.9 0-22.5 5.6l-9.4 9.4c-54.3 54.3-142.3 59.9-198.5 11.2-63.7-54.3-65.5-151.7-7.5-209.7l142.3-142.3c18.7-18.7 41.2-30 63.7-37.5 30-7.5 61.8-5.6 89.9 5.6 16.9 7.5 33.7 16.9 48.7 31.8 7.5 7.5 13.1 15 18.7 24.3 7.5 13.1 24.3 15 33.7 3.7l52.4-52.4c7.5-7.5 7.5-18.7 1.9-28.1-7.5-11.2-16.9-20.6-26.2-30-13.1-13.1-28.1-26.2-44.9-35.6-26.2-16.9-56.2-28.1-88-33.7-58.1-11.2-121.7-1.9-174.2 26.2-20.6 11.2-41.2 26.2-58.1 43.1L141.4 515.5c-99.3 99.3-106.7 260.3-11.2 361.4C229.5 985.5 398 987.4 501 884.4l46.8-46.8c13.1-9.4 3.7-31.9-13.1-33.7z"/></svg>' }, { type: "image", title: "插入图片", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><path d="M46.545 977.455V46.545h930.91v930.91zm93.091-186.182v93.09h744.728V717.918l-214.11-228.305zm0-107.055l548.585-311.854 196.143 209.454V139.636H139.636zm99.282-376.227a82.758 82.758 0 0 1 82.758-82.758 82.758 82.758 0 0 1 82.757 82.758 82.758 82.758 0 0 1-82.757 82.805 82.804 82.804 0 0 1-82.758-82.898z"/></svg>' }, { type: "table", title: "表格", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18"><path d="M892.8 108h-763c-26.2 0-47.5 21.3-47.5 47.5v714c0 26.2 21.3 47.5 47.5 47.5h763c26.2 0 47.5-21.3 47.5-47.5v-714c0-26.2-21.3-47.5-47.5-47.5zm-291 294.7v172.1H411.7V402.7h190.1zm76 0h186.5v172.1H677.8V402.7zM864.3 184v142.7h-706V184h706zM158.4 841V402.7h177.3v172.1H159.8v76h175.9v188.9h76V650.8h190.1v188.9h76V650.8h186.5V841H158.4z"/></svg>' }, { type: "code-block", title: "代码块", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M902.4 454.4l-144-144a40.704 40.704 0 0 0-57.6 57.6l144 144-144 144a40.704 40.704 0 0 0 57.6 57.6l144-144a81.472 81.472 0 0 0 0-115.2zm-636.8-144l-144 144a81.472 81.472 0 0 0 0 115.2l144 144a40.704 40.704 0 0 0 57.6-57.6l-144-144 144-144a40.704 40.704 0 0 0-57.6-57.6zm109.568 544.064l195.072-706.56a40.704 40.704 0 0 1 78.528 21.632l-195.072 706.56a40.704 40.704 0 0 1-78.528-21.696z" /></svg>' }, { type: "html", title: "原生HTML", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M128 64l69.8 791.6L511 960l315.2-104.4L896 64H128zm616.4 255.8H376.8l8.2 98.8h351.2L709 715.4l-195.8 54v.6H511l-197.4-54.6-12-151.6H397l7 76.2 107 29 107.4-29 12-124.4H296.6L271 224.4h482.2l-8.8 95.4z"/></svg>' }, { type: "time", title: "当前时间", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18"><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"/><path d="M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z"/></svg>' }, { type: "indent", title: "缩进", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M692.019 192c-22.087 0-39.992 17.935-39.992 40.059v277.192c-.638-9.212-4.471-18.244-11.522-25.286l-280.74-280.353c-15.504-15.483-40.643-15.483-56.147 0-15.505 15.483-15.505 40.587 0 56.07L556.282 512 303.617 764.316c-15.505 15.482-15.505 40.587 0 56.07 15.504 15.484 40.643 15.483 56.146 0l280.74-280.352a40.074 40.074 0 0 0 2.726-3.012c5.322-6.517 8.247-14.329 8.797-22.275V791.82c0 22.122 17.905 40.057 39.992 40.057s39.993-17.935 39.993-40.057V232.059c.001-22.124-17.906-40.059-39.992-40.059z"/></svg>' }, { type: "character", title: "实体符号", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"/><path d="M517.6 351.3c53 0 89 33.8 93 83.4.3 4.2 3.8 7.4 8 7.4h56.7c2.6 0 4.7-2.1 4.7-4.7 0-86.7-68.4-147.4-162.7-147.4C407.4 290 344 364.2 344 486.8v52.3C344 660.8 407.4 734 517.3 734c94 0 162.7-58.8 162.7-141.4 0-2.6-2.1-4.7-4.7-4.7h-56.8c-4.2 0-7.6 3.2-8 7.3-4.2 46.1-40.1 77.8-93 77.8-65.3 0-102.1-47.9-102.1-133.6v-52.6c.1-87 37-135.5 102.2-135.5z"/></svg>' }, { type: "emoji", title: "符号表情", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="19" height="19"><path d="M512 56.889A455.111 455.111 0 0 0 56.889 512 455.111 455.111 0 0 0 512 967.111 455.111 455.111 0 0 0 967.111 512 455.111 455.111 0 0 0 512 56.889zm111.047 270.336A69.086 69.086 0 0 1 671.29 307.2c17.863 0 35.67 7.396 48.242 20.025 12.629 12.572 20.025 30.379 20.025 48.242 0 17.863-7.396 35.669-20.025 48.241-12.8 12.744-30.151 19.912-48.242 20.025a68.95 68.95 0 0 1-48.242-20.025 68.95 68.95 0 0 1-20.025-48.241c0-17.863 7.396-35.67 20.025-48.242zm-318.578 0a69.086 69.086 0 0 1 48.242-20.025c17.863 0 35.67 7.396 48.242 20.025 12.63 12.572 20.025 30.379 20.025 48.242 0 17.863-7.396 35.669-20.025 48.241-12.8 12.744-30.151 19.912-48.242 20.025a68.95 68.95 0 0 1-48.242-20.025 68.95 68.95 0 0 1-20.025-48.241c0-17.863 7.396-35.67 20.025-48.242zM786.375 566.67c-10.24 132.893-118.556 236.544-270.563 235.975-156.331 1.707-264.704-107.178-270.507-235.975a23.324 23.324 0 0 1-2.446-10.41c0-13.597 11.605-24.633 26.282-24.52h493.796c14.336 0 26.055 11.037 26.055 24.52a24.292 24.292 0 0 1-2.617 10.41z"/></svg>' }, { type: "expression", title: "图片表情", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M512 63.488q93.184 0 174.592 35.328t142.336 95.744 96.256 142.336 35.328 174.08q0 93.184-35.328 174.592t-96.256 142.336-142.336 96.256T512 959.488q-92.16 0-174.08-35.328t-142.336-96.256T99.84 685.568 64.512 510.976q0-92.16 35.328-174.08t95.744-142.336T337.92 98.816 512 63.488zM247.808 274.432q13.312 43.008 28.672 78.848 13.312 30.72 29.696 59.904t33.792 37.376q17.408 9.216 36.864 1.536t35.84-20.992q18.432-15.36 37.888-38.912zm501.76 537.6q8.192-3.072 12.8-8.192t6.144-11.264 1.536-11.776-1.024-7.68q-2.048-8.192-5.12-11.264-12.288-28.672-35.84-51.712t-56.32-39.936-73.728-26.112-88.064-9.216-89.6 10.24-76.288 28.672-57.856 43.008-33.28 53.248q-1.024 1.024-1.024 3.072-2.048 6.144 1.024 20.48t18.432 18.432q23.552-29.696 57.344-53.248 29.696-20.48 73.728-36.864t105.472-16.384 107.008 16.384 75.264 36.864q34.816 23.552 59.392 53.248zM680.96 450.56q17.408-8.192 33.792-37.376t29.696-59.904q15.36-35.84 28.672-78.848l-202.752 117.76q19.456 23.552 37.888 38.912 16.384 13.312 35.84 20.992t36.864-1.536z"/></svg>' }, { type: "task-no", title: "任务 - 未完成", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18"><path d="M831.55 128.531c38.35 0 63.911 25.568 63.911 63.91v639.104c0 38.355-25.561 63.916-63.91 63.916H192.44c-38.34 0-63.908-25.56-63.908-63.916V192.442c0-38.343 25.567-63.91 63.908-63.91h639.11m0-63.91H192.44c-70.3 0-127.816 57.518-127.816 127.82v639.103c0 70.308 57.515 127.833 127.816 127.833h639.11c70.294 0 127.822-57.525 127.822-127.833V192.442c0-70.302-57.527-127.82-127.823-127.82zm0 0"/></svg>' }, { type: "task-yes", title: "任务 - 已完成", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18"><path d="M831.551 64.623h-639.11c-70.3 0-127.816 57.517-127.816 127.819v639.103c0 70.308 57.515 127.833 127.816 127.833h639.11c70.294 0 127.822-57.525 127.822-127.833V192.442c0-70.302-57.527-127.82-127.822-127.82zM646.217 486.44c-108.652 159.779-204.52 345.115-204.52 345.115L192.443 550.351l63.916-70.303 153.385 146.994s76.695-127.822 178.95-236.469c102.261-108.652 223.689-198.127 223.689-198.127l19.17 63.916c0-.001-102.255 108.646-185.337 230.078z"/></svg>' }, { type: "mtitle", title: "居中标题", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M967.1 455.3H672.2c-23.5-66.1-86-113.8-160.2-113.8s-136.7 47.6-160.2 113.8H56.9C25.5 455.3 0 480.7 0 512.2c0 31.4 25.5 56.9 56.9 56.9h294.9c23.5 66.1 86 113.8 160.2 113.8s136.7-47.6 160.2-113.8h294.9c31.4 0 56.9-25.5 56.9-56.9 0-31.5-25.5-56.9-56.9-56.9zM512 569.1c-31.4 0-56.9-25.5-56.9-56.9s25.5-56.9 56.9-56.9 56.9 25.5 56.9 56.9c0 31.3-25.5 56.9-56.9 56.9z"/></svg>' }, { type: "dplayer", title: "M3U8/MP4视频", innerHTML: '<svg viewBox="0 0 1170 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18"><path d="M508.197 298.642c-39.278-20.919-69.34-5.12-69.34 35.109v211.822c0 40.301 29.989 56.027 69.12 34.889L698.88 477.257c38.985-21.065 39.57-55.442.293-76.361L508.197 298.642z"/><path d="M1060.571 877.714H109.714C49.225 877.714 0 828.562 0 768V109.714C0 49.225 49.225 0 109.714 0h950.857c60.416 0 109.715 49.225 109.715 109.714V768c0 60.562-49.299 109.714-109.715 109.714zM109.714 73.143a36.571 36.571 0 0 0-36.571 36.571V768c0 20.114 16.457 36.571 36.571 36.571h950.857c20.115 0 36.572-16.457 36.572-36.571V109.714a36.571 36.571 0 0 0-36.572-36.571H109.714zM219.43 950.857h731.428V1024H219.43v-73.143z"/></svg>' }, { type: "bilibili", title: "哔哩哔哩视频", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18"><path d="M1023.488 344.064c-3.072-143.36-128-170.496-128-170.496s-97.28-.512-224.256-1.536l92.16-89.088s14.336-18.432-10.24-38.912-26.624-11.264-34.816-6.144c-7.68 5.632-117.76 113.664-137.216 133.12-50.176 0-102.4-.512-153.088-.512h17.92s-132.096-130.56-140.8-136.192-9.728-14.336-34.816 6.144c-24.576 20.48-10.24 38.912-10.24 38.912l94.208 91.648c-102.4 0-190.464.512-231.424 2.048C-9.728 210.944.512 344.064.512 344.064s1.536 285.696 0 429.568c14.336 144.384 125.44 167.424 125.44 167.424s44.032 1.024 76.8 1.024c3.072 9.216 6.144 54.272 56.32 54.272s56.32-54.272 56.32-54.272 369.152-1.536 399.872-1.536c1.536 15.872 9.216 57.344 59.904 56.32 50.176-1.024 53.76-59.904 53.76-59.904s17.408-1.536 68.608 0C1017.344 914.944 1024 774.656 1024 774.656s-2.048-287.232-.512-430.592zM920.576 800.768c0 22.528-17.92 40.96-39.936 40.96H153.6c-22.016 0-39.936-18.432-39.936-40.96V318.464c0-22.528 17.92-40.96 39.936-40.96h727.04c22.016 0 39.936 18.432 39.936 40.96v482.304z"/><path d="M403.968 414.208l-214.016 40.96 18.432 80.384 211.456-40.96-15.872-80.384zm115.2 212.48c-52.224 112.128-99.328 27.648-99.328 27.648l-34.816 22.528s69.12 94.208 134.656 22.528c77.312 71.68 136.704-23.04 136.704-23.04l-31.744-20.48c0-.512-55.808 79.872-105.472-29.184zM624.64 494.08l211.968 40.96 17.92-80.384-213.504-40.96-16.384 80.384z"/></svg>' }, { type: "netease-list", title: "网易云列表", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18"><path d="M919.438 376.378c-3.328 17.214-8.767 31.228-16.254 42.043-7.487 10.815-13.822 15.87-19.005 15.166-5.248-.768-9.92-4.48-14.015-11.198-4.095-6.72-7.295-19.07-9.535-36.988-3.711-29.18-13.246-50.682-28.54-64.504-15.295-13.822-38.972-23.741-71.095-29.692-33.596-6.72-63.225-20.35-89.013-40.956-25.725-20.54-47.227-39.802-64.377-57.784-16.382-15.742-29.053-21.31-38.012-16.83s-13.437 12.734-13.437 24.7v48.25l-1.088 493.444v63.93c.768 17.916-2.048 37.946-8.383 60.023-6.335 22.077-18.302 42.81-35.836 62.264s-40.89 36.092-69.943 49.915c-29.117 13.822-65.337 21.884-108.595 24.124-44.027 2.24-83.766-5.631-119.217-23.55-35.452-17.916-62.905-40.569-82.295-67.83-19.39-27.26-28.923-57.21-28.54-89.718.384-32.508 14.335-62.967 41.98-91.38 27.644-28.413 57.464-48.25 89.589-59.45 32.06-11.197 63.03-17.405 92.916-18.492 29.884-1.088 56.505.96 80.054 6.143 23.485 5.247 40.827 10.11 52.025 14.59 0 0 .384-505.026 1.152-615.669 0-21.693 5.631-39.42 16.766-53.306 11.2-13.821 26.11-21.884 44.795-24.124 15.614-2.368 28.477.768 38.524 9.407 10.11 8.574 20.35 20.541 30.78 35.9 10.494 15.293 23.356 32.699 38.65 52.153 15.295 19.454 36.029 38.522 62.137 57.21 22.397 17.212 41.979 29.499 58.809 36.986a4986.732 4986.732 0 0 0 47.034 20.734c14.526 6.335 28.924 14.014 43.13 22.973 14.207 8.96 29.885 23.55 47.035 43.706 17.15 19.454 27.644 39.612 31.356 60.537 3.647 20.99 3.84 40.06.448 57.273z"/></svg>' }, { type: "netease-single", title: "网易云单首", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M837.766 364.816c-50.828-54.107-111.313-91.2-187.245-98.706-7.324-.728-18.983-5.028-20.404-9.983-6.595-23.064-12.826-46.784-14.283-70.54-1.64-26.6 20.368-44.744 46.748-39.425 16.724 3.389 32.392 12.389 48.277 19.457 10.968 4.883 20.988 12.389 32.32 15.923 27.472 8.49 53.378-7.725 58.589-35.78 4.408-23.684-4.41-42.922-22.154-58.153-28.857-24.776-62.998-37.748-100.054-44.743-70.977-13.409-152.74 38.768-169.648 108.908-8.453 35.088-1.712 68.755 10.457 101.51 6.486 17.527 1.968 24.595-16.032 30.862-118.308 41.32-182.508 155.436-154.49 276.075 16.506 71.123 59.465 121.733 131.862 138.604 74.44 17.344 136.818-7.943 182.62-69.192 37.056-49.516 39.133-105.519 23.976-163.197-7.943-30.242-17.198-60.156-26.672-92.948 5.575 1.094 7.397 1.203 9.037 1.786 125.486 45.436 188.959 183.858 125.232 318.813-63.91 135.325-211.911 183.348-344.362 155.072-166.26-35.526-278.955-210.93-245.286-377.62 23.61-116.924 91.564-198.32 200.253-246.342 8.27-3.68 16.797-7.251 24.266-12.28 15.595-10.53 24.886-25.687 23.064-44.633-1.93-19.93-11.878-37.93-32.136-42.011-16.215-3.28-36.036-3.68-50.72 2.696-166.223 72.107-260.848 197.994-272.869 379.884-18.655 282.566 246.128 504.023 521.296 440.882 171.833-39.424 293.167-182.18 303.986-330.804 7.105-97.248-18.619-182.763-85.625-254.11zm-309.05 234.651c-39.06 3.352-71.233-23.83-77.609-65.548-11.113-72.545 19.894-127.162 85.48-151.94 12.606-4.774 18.18-2.915 21.934 10.858 8.745 32.1 19.493 63.617 28.675 95.609 3.133 10.93 3.972 22.554 5.83 33.885-.219 42.922-25.578 73.82-64.31 77.136z"/></svg>' }, { type: "abtn", title: "多彩按钮", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="22" height="22"><path d="M839.68 163.84a163.84 163.84 0 0 1 163.84 163.84v327.68A163.84 163.84 0 0 1 839.68 819.2H184.32A163.84 163.84 0 0 1 20.48 655.36V327.68a163.84 163.84 0 0 1 163.84-163.84h655.36zm0 81.92H184.32a81.92 81.92 0 0 0-81.715 75.776l-.205 6.144v327.68a81.92 81.92 0 0 0 75.776 81.715l6.144.205h655.36a81.92 81.92 0 0 0 81.715-75.776l.205-6.144V327.68a81.92 81.92 0 0 0-75.776-81.715l-6.144-.205z"/><path d="M347.013 483.574c1.639-1.925 3.236-4.014 4.792-6.185 6.759-11.141 10.322-24.371 10.322-39.199 0-20.808-6.799-37.806-20.111-50.463-13.435-12.656-31.785-18.964-54.6-18.964H197.96c-7.619 0-13.64 6.758-13.64 15.032v215.532c0 8.397 6.144 15.073 13.64 15.073h89.702c23.634 0 42.476-5.038 56.443-15.278 17.367-13.23 26.132-33.587 26.132-60.457 0-17.94-4.26-32.89-12.697-44.237a54.682 54.682 0 0 0-10.527-10.854zm-47.39-28.836c-1.557 1.393-6.882 4.506-20.726 4.506h-35.308v-31.417h35.84c13.025 0 18.31 2.785 20.316 4.26.697.573 2.867 2.417 2.867 10.24 0 6.308-1.228 10.65-2.99 12.41zm-56.034 63.693h40.182c14.582 0 20.644 3.195 22.815 5.038 2.826 2.457 4.3 7.373 4.3 14.623 0 7.454-2.498 10.444-6.266 12.861-3.236 1.966-9.462 4.383-21.668 4.383h-39.363V518.43zM586.26 368.64H426.27c-7.577 0-13.639 6.8-13.639 15.073v30.229c0 8.397 6.144 15.032 13.64 15.032h50.299v170.27c0 8.357 6.144 15.033 13.68 15.033H522.2c7.619 0 13.64-6.758 13.64-15.032V429.097h50.34c7.577 0 13.64-6.758 13.64-15.032v-30.27c.081-8.356-6.063-15.155-13.518-15.155zm239.862 0h-32.276c-7.619 0-13.64 6.8-13.64 15.073v108.503l-72.704-117.022a13.19 13.19 0 0 0-11.264-6.554H664.29c-7.618 0-13.64 6.8-13.64 15.073v215.532c0 8.356 6.145 15.032 13.64 15.032h31.95c7.618 0 13.639-6.758 13.639-15.032v-110.47l73.728 119.071c2.54 4.137 6.8 6.554 11.264 6.554H826c7.618 0 13.68-6.8 13.68-15.073V383.795c.082-8.356-6.062-15.155-13.517-15.155z"/></svg>' }, { type: "anote", title: "便条按钮", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="22" height="22"><path d="M856.73 796.7h-690c-57.9 0-105-47.1-105-105v-360c0-57.9 47.1-105 105-105h690c57.9 0 105 47.1 105 105v360c0 57.89-47.1 105-105 105zm-690-500.01c-19.3 0-35 15.7-35 35v360c0 19.3 15.7 35 35 35h690c19.3 0 35-15.7 35-35v-360c0-19.3-15.7-35-35-35h-690z"/><path d="M233.16 431.69H790.3v160H233.16z"/></svg>' }, { type: "dotted", title: "彩色虚线", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M111.09 562.26a42.6 42.6 0 1 1 0-85.19h127.78a42.6 42.6 0 0 1 0 85.19zm340.75-3a42.59 42.59 0 1 1 0-85.18h127.78a42.59 42.59 0 1 1 0 85.18zm340.75 0a42.59 42.59 0 0 1 0-85.18h127.79a42.59 42.59 0 1 1 0 85.18zm0 0"/></svg>' }, { type: "hide", title: "回复可见", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M342.016 640.512a483.328 483.328 0 0 1-126.976-63.488l-104.96 102.4a51.2 51.2 0 0 1-71.168-74.24l102.4-96.256a419.328 419.328 0 0 1-84.48-133.12 51.2 51.2 0 1 1 95.744-34.816 278.016 278.016 0 0 0 15.872 32.256 378.88 378.88 0 0 0 55.808 77.312A381.952 381.952 0 0 0 512 563.2a382.464 382.464 0 0 0 286.208-112.64 378.88 378.88 0 0 0 58.368-77.312 278.016 278.016 0 0 0 13.824-32.256 51.2 51.2 0 1 1 95.744 34.816 419.328 419.328 0 0 1-84.48 133.12l102.4 96.256a51.2 51.2 0 0 1-71.168 73.216L807.936 576a460.8 460.8 0 0 1-125.952 62.976l58.368 102.4a51.2 51.2 0 0 1-88.576 51.2l-74.752-130.048A521.728 521.728 0 0 1 512 665.6q-32.256 0-62.976-3.072l-76.8 129.536a51.2 51.2 0 0 1-88.576-51.2z"/></svg>' }, { type: "card-default", title: "默认卡片", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M928 160H96a32 32 0 0 0-32 32v672a32 32 0 0 0 32 32h832a32 32 0 0 0 32-32V192a32 32 0 0 0-32-32zm-32 672H128V224h768v608zM230.592 448.096H544a32 32 0 1 0 0-64H230.592a32 32 0 0 0 0 64zm0 192H544a32 32 0 1 0 0-64H230.592a32 32 0 1 0 0 64zM768 704a32 32 0 0 0 32-32V350.016a32 32 0 1 0-64 0V672a32 32 0 0 0 32 32z"/></svg>' }, { type: "message", title: "消息提示", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M195.181 164.694c-13.024-13.029-34.144-13.029-47.159 0-13.029 13.019-13.029 34.134 0 47.163l47.159 47.158c13.024 13.024 34.129 13.024 47.162 0 13.019-13.019 13.019-34.129 0-47.158l-47.162-47.163zm633.634 0l-47.162 47.163c-13.02 13.029-13.02 34.139 0 47.158 13.009 13.024 34.129 13.024 47.162 0l47.148-47.158c13.029-13.029 13.029-34.139 0-47.163-13.019-13.024-34.124-13.024-47.148 0zM111.809 428.626H45.115c-18.416 0-33.352 14.928-33.352 33.342 0 18.419 14.933 33.351 33.352 33.351h66.698c18.415 0 33.347-14.931 33.347-33.351 0-18.415-14.933-33.342-33.347-33.342h-.004zm867.072 0h-66.698c-18.416 0-33.352 14.928-33.352 33.342 0 18.419 14.933 33.351 33.352 33.351h66.693c18.419 0 33.361-14.931 33.361-33.351 0-18.415-14.941-33.342-33.361-33.342h.005zM478.648 45.108v66.698c0 18.42 14.928 33.347 33.347 33.347 18.41 0 33.351-14.928 33.351-33.347V45.108c0-18.415-14.941-33.347-33.351-33.347-18.419 0-33.347 14.933-33.347 33.347zM278.557 511.993c0-128.923 104.506-233.438 233.438-233.438 128.927 0 233.442 104.516 233.442 233.438 0 128.926-104.515 233.447-233.442 233.447-128.932 0-233.438-104.52-233.438-233.447zm-66.698 0c0 165.78 134.365 300.155 300.137 300.155 165.766 0 300.141-134.375 300.141-300.155 0-165.767-134.376-300.137-300.141-300.137-165.767.001-300.137 134.371-300.137 300.137zm233.437 466.895c0 18.405 14.933 33.351 33.352 33.351h66.698c18.419 0 33.347-14.946 33.347-33.351 0-18.429-14.928-33.347-33.347-33.347h-66.698c-18.419 0-33.352 14.918-33.352 33.347zm-66.693-100.045c0 18.405 14.933 33.346 33.342 33.346h200.096c18.419 0 33.351-14.941 33.351-33.346 0-18.434-14.931-33.357-33.351-33.357H411.945c-18.414 0-33.342 14.923-33.342 33.357zm0 0"/></svg>' }, { type: "progress", title: "进度条", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="22" height="22"><path d="M757.76 323.482a188.518 188.518 0 0 1 0 377.036H266.24a188.518 188.518 0 1 1 0-377.036h491.52zm0 66.56H502.63l-72.96 243.814H757.71a121.958 121.958 0 0 0 8.397-243.558l-8.397-.308z"/></svg>' }, { type: "callout", title: "标注", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18"><path d="M842.13 910h-72.36c-19.88 0-36-16.12-36-36s16.12-36 36-36h72.36c19.88 0 36 16.12 36 36s-16.11 36-36 36zm-177.69 0h-72.23c-19.88 0-36-16.12-36-36s16.12-36 36-36h72.23c19.88 0 36 16.12 36 36s-16.12 36-36 36zm-177.57 0h-72.23c-19.88 0-36-16.12-36-36s16.12-36 36-36h72.23c19.88 0 36 16.12 36 36s-16.11 36-36 36zm-177.56 0h-72.23c-19.88 0-36-16.12-36-36s16.12-36 36-36h72.23c19.88 0 36 16.12 36 36s-16.12 36-36 36zM150 878.02c-19.88 0-36-16.1-36-35.98V769.8c0-19.88 16.12-36 36-36s36 16.12 36 36V842c0 19.88-16.12 36.02-36 36.02zm724-55.2c-19.88 0-36-16.12-36-36v-72.23c0-19.88 16.12-36 36-36s36 16.12 36 36v72.23c0 19.88-16.12 36-36 36zM150 700.47c-19.88 0-36-16.12-36-36v-72.23c0-19.88 16.12-36 36-36s36 16.12 36 36v72.23c0 19.88-16.12 36-36 36zm724-55.22c-19.88 0-36-16.12-36-36v-72.23c0-19.88 16.12-36 36-36s36 16.12 36 36v72.23c0 19.89-16.12 36-36 36zM150 522.91c-19.88 0-36-16.12-36-36v-72.23c0-19.88 16.12-36 36-36s36 16.12 36 36v72.23c0 19.88-16.12 36-36 36zm724-55.22c-19.88 0-36-16.12-36-36v-72.23c0-19.88 16.12-36 36-36s36 16.12 36 36v72.23c0 19.88-16.12 36-36 36zM150 345.34c-19.88 0-36-16.12-36-36v-72.23c0-19.88 16.12-36 36-36s36 16.12 36 36v72.23c0 19.89-16.12 36-36 36zm724-55.21c-19.88 0-36-16.12-36-36V182c0-19.88 16.12-36.05 36-36.05s36 16.07 36 35.95v72.23c0 19.88-16.12 36-36 36zM786.85 186h-72.23c-19.88 0-36-16.12-36-36s16.12-36 36-36h72.23c19.88 0 36 16.12 36 36s-16.12 36-36 36zm-177.56 0h-72.23c-19.88 0-36-16.12-36-36s16.12-36 36-36h72.23c19.88 0 36 16.12 36 36s-16.12 36-36 36zm-177.56 0H359.5c-19.88 0-36-16.12-36-36s16.12-36 36-36h72.23c19.88 0 36 16.12 36 36s-16.12 36-36 36zm-177.57 0H182c-19.88 0-36.03-16.12-36.03-36s16.08-36 35.97-36h72.23c19.88 0 36 16.12 36 36s-16.13 36-36.01 36z"/><path d="M213 120v784c0 4.42-3.58 8-8 8h-84c-4.42 0-8-3.58-8-8V120c0-4.42 3.58-8 8-8h84c4.42 0 8 3.58 8 8z"/></svg>' }, { type: "mp3", title: "外部音乐", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M736 249.6c-12.8-6.4-32-6.4-44.8 6.4-12.8 12.8-6.4 32 6.4 44.8C761.6 352 800 428.8 800 512c0 76.8-32 153.6-89.6 204.8-12.8 12.8-12.8 32 0 44.8 12.8 12.8 32 12.8 44.8 0C825.6 697.6 864 608 864 512c-6.4-102.4-51.2-198.4-128-262.4z"/><path d="M640 345.6c-12.8-6.4-32-6.4-44.8 6.4-12.8 12.8-6.4 32 6.4 44.8 38.4 25.6 57.6 70.4 57.6 115.2s-19.2 83.2-44.8 108.8c-12.8 12.8-12.8 32 0 44.8 12.8 12.8 32 12.8 44.8 0 44.8-38.4 64-96 64-153.6-6.4-64-38.4-128-83.2-166.4zM499.2 211.2L288 345.6H185.6c-12.8 0-19.2 6.4-19.2 19.2v313.6c0 12.8 12.8 25.6 19.2 25.6H288l211.2 115.2H512c12.8 0 19.2-6.4 19.2-19.2V230.4c0-6.4 0-6.4-6.4-12.8 0-6.4-19.2-12.8-25.6-6.4z"/></svg>' }, { type: "tabs", title: "标签页", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M904 788c4.31 0 7.853 2.735 8 6.12v63.548c0 3.412-3.455 6.216-7.732 6.33L904 864H120c-4.31 0-7.853-2.735-8-6.12v-63.548c0-3.412 3.455-6.216 7.732-6.33L120 788h784zm0-192c4.31 0 7.853 2.735 8 6.12v63.548c0 3.412-3.455 6.216-7.732 6.33L904 672H120c-4.31 0-7.853-2.735-8-6.12v-63.548c0-3.412 3.455-6.216 7.732-6.33L120 596h784zm-8-436c8.837 0 16 7.163 16 16v288c0 8.837-7.163 16-16 16H608c-8.837 0-16-7.163-16-16V176c0-8.837 7.163-16 16-16h288zm-384 0c8.695 0 15.828 7.03 16 15.686V464c0 8.695-7.03 15.828-15.686 16H128c-8.695 0-15.828-7.03-16-15.686V176c0-8.695 7.03-15.828 15.686-16H512zm-56 72H184v176h272V232z"/></svg>' }, { type: "card-list", title: "卡片列表", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M359.79 156.52L189.31 330.2a68.454 68.454 0 0 0-19.6 47.95v444.68c0 37.8 30.65 68.45 68.46 68.45h547.66c37.81 0 68.46-30.65 68.46-68.45V200.77c0-37.8-30.65-68.45-68.46-68.45h-.67l-377.19 3.7a68.458 68.458 0 0 0-48.18 20.5zm-48.86-47.95a136.921 136.921 0 0 1 96.37-41l377.19-3.7c.67-.01.67-.01 1.34-.01 75.62 0 136.92 61.29 136.92 136.9v622.06c0 75.61-61.3 136.9-136.92 136.9H238.17c-75.62 0-136.92-61.29-136.92-136.9V378.15c0-35.86 14.08-70.3 39.2-95.89l170.48-173.69z"/><path d="M683.04 353.45v34.12c0 9.42-7.66 17.06-17.1 17.06H358.07c-9.45 0-17.1-7.64-17.1-17.06v-34.12c0-9.42 7.66-17.06 17.1-17.06h307.86c9.45 0 17.11 7.64 17.11 17.06zm0 171.47v34.12c0 9.42-7.66 17.06-17.1 17.06H358.07c-9.45 0-17.1-7.64-17.1-17.06v-34.12c0-9.42 7.66-17.06 17.1-17.06h307.86c9.45 0 17.11 7.64 17.11 17.06zM545.68 695.96v34.12c0 9.42-7.64 17.06-17.06 17.06h-170.6c-9.42 0-17.06-7.64-17.06-17.06v-34.12c0-9.42 7.64-17.06 17.06-17.06h170.6c9.42 0 17.06 7.63 17.06 17.06z"/></svg>' }, { type: "timeline", title: "时间轴", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M365.714 329.143c0-47.543-29.257-87.772-73.143-102.4V36.57C292.571 14.63 277.943 0 256 0s-36.571 14.629-36.571 36.571v190.172c-43.886 14.628-73.143 54.857-73.143 102.4 0 47.543 29.257 87.771 73.143 102.4V588.8c-43.886 14.629-73.143 54.857-73.143 102.4 0 47.543 29.257 87.771 73.143 102.4v193.829c0 21.942 14.628 36.571 36.571 36.571s36.571-14.629 36.571-36.571V797.257c43.886-14.628 73.143-54.857 73.143-102.4 0-47.543-29.257-87.771-73.143-102.4V435.2c43.886-18.286 73.143-58.514 73.143-106.057zM256 731.429c-21.943 0-36.571-14.629-36.571-36.572s14.628-36.571 36.571-36.571 36.571 14.628 36.571 36.571S277.943 731.43 256 731.43zm0-365.715c-21.943 0-36.571-14.628-36.571-36.571S234.057 292.57 256 292.57s36.571 14.629 36.571 36.572-14.628 36.571-36.571 36.571zM768 731.43H475.429c-18.286 0-36.572 14.628-36.572 36.571s14.629 36.571 36.572 36.571H768c18.286 0 36.571-14.628 36.571-36.571S789.943 731.429 768 731.429zm73.143-512H475.429c-18.286 0-36.572 14.628-36.572 36.571s14.629 36.571 36.572 36.571h365.714c18.286 0 36.571-14.628 36.571-36.571s-14.628-36.571-36.571-36.571zM768 438.857c18.286 0 36.571-14.628 36.571-36.571S789.943 365.714 768 365.714H475.429c-18.286 0-36.572 14.629-36.572 36.572s14.629 36.571 36.572 36.571H768zm73.143 146.286H475.429c-18.286 0-36.572 14.628-36.572 36.571s14.629 36.572 36.572 36.572h365.714c18.286 0 36.571-14.629 36.571-36.572s-14.628-36.571-36.571-36.571z"/></svg>' }, { type: "copy", title: "复制文本", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M731.682 676.057V183.323c0-30.233-24.512-54.746-54.748-54.746H184.216c-30.233 0-54.747 24.513-54.747 54.746v492.734c0 30.208 24.514 54.747 54.747 54.747h492.718c30.235 0 54.748-24.539 54.748-54.747zm-109.493 0H238.963c-30.234 0-54.747-24.538-54.747-54.745V238.07c0-30.233 24.513-54.747 54.747-54.747h383.226c30.234 0 54.745 24.513 54.745 54.747v383.243c0 30.206-24.512 54.744-54.745 54.744zm218.986-383.24h-54.746v54.747c30.232 0 54.746 24.513 54.746 54.76V785.55c0 30.207-24.514 54.746-54.746 54.746H403.202c-30.234 0-54.747-24.539-54.747-54.746h-54.747v54.746c0 30.208 24.513 54.748 54.747 54.748h492.72c30.234 0 54.747-24.54 54.747-54.748V347.564c0-30.235-24.514-54.747-54.747-54.747z"/></svg>' }, { type: "card-describe", title: "描述卡片", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M202.667 149.333c-52.651 0-96 43.35-96 96v533.334c0 52.65 43.349 96 96 96h618.666c52.651 0 96-43.35 96-96V245.333c0-52.65-43.349-96-96-96h-448a32 32 0 0 0-5.504.427c-2.816-.213-5.653-.427-8.49-.427H202.667zm0 64h156.672a53.32 53.32 0 0 1 37.696 15.616l102.997 103.019a32 32 0 0 0 22.635 9.365h298.666c18.048 0 32 13.952 32 32v405.334c0 18.048-13.952 32-32 32H202.667c-18.048 0-32-13.952-32-32V245.333c0-18.048 13.952-32 32-32zm269.248 0h349.418c18.048 0 32 13.952 32 32v37.974a94.016 94.016 0 0 0-32-5.974H535.915l-64-64z"/></svg>' }, { type: "lamp", title: "跑马灯", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M848 432a80.064 80.064 0 0 0-73.216 48H217.216A80.096 80.096 0 0 0 144 432a80.096 80.096 0 0 0-80 80c0 44.128 35.904 80 80 80a80 80 0 0 0 73.216-48h557.536a80 80 0 0 0 73.216 48c44.128 0 80-35.872 80-80A80.032 80.032 0 0 0 848 432z"/></svg>' }, { type: "collapse", title: "折叠面板", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="18" height="18"><path d="M944 128H80c-8.8 0-16 7.2-16 16v736c0 8.8 7.2 16 16 16h864c8.8 0 16-7.2 16-16V144c0-8.8-7.2-16-16-16zm-48 64v216H128V192h768zM128 832V472h768v360H128z"/><path d="M706 340.8c6.4 7.6 18 7.6 24.4 0l58.8-69.2c8.8-10.4 1.6-26.4-12-26.4H659.6c-13.6 0-21.2 16-12 26.4l58.4 69.2z"/></svg>' }, { type: "cloud", title: "云盘下载", innerHTML: '<svg viewBox="0 0 1462 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M1435.063 668.453a348.891 348.891 0 0 1-102.766 248.246 348.891 348.891 0 0 1-247.003 102.84H377.71a348.891 348.891 0 0 1-247.004-102.84A348.891 348.891 0 0 1 27.941 668.526c0-93.843 36.498-181.98 102.765-248.32a348.672 348.672 0 0 1 210.36-100.937c17.553-69.486 53.54-133.12 105.544-185.125a399.067 399.067 0 0 1 284.16-117.76c130.853 0 253.806 63.927 329.143 171.154a50.25 50.25 0 0 1-82.286 57.71 302.007 302.007 0 0 0-246.71-128.293 302.08 302.08 0 0 0-286.062 206.483c-5.12 15.36-8.997 40.52-11.63 61.805a37.376 37.376 0 0 1-39.058 32.915 257.902 257.902 0 0 0-65.024 4.535 251.1 251.1 0 0 0-200.631 249.782c2.194 135.607 117.467 246.492 253.074 246.492h699.831c136.631 0 249.93-108.252 252.928-244.736a250.88 250.88 0 0 0-250.514-256.512 250.807 250.807 0 0 0-250.514 249.929 51.931 51.931 0 0 1-45.861 50.688 50.322 50.322 0 0 1-54.71-50.03c0-93.842 36.497-182.052 102.765-248.32a348.891 348.891 0 0 1 248.32-102.839c93.842 0 181.98 36.572 248.32 102.84a349.623 349.623 0 0 1 102.912 248.539z"/></svg>' }, { type: "gird", title: "宫格", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M156.16 896.512h711.168c15.872 0 28.672-12.8 28.672-28.672V156.16c0-15.872-12.8-28.672-28.672-28.672H156.16c-15.872 0-28.672 12.8-28.672 28.672v711.168c0 16.384 12.8 29.184 28.672 29.184zm35.328-352.256h288.768v288.256H191.488V544.256zm352.768 288.256V544.256h288.768v288.256H544.256zm288.768-352.768H544.256V191.488h288.768v288.256zm-353.28-288.256v288.256H191.488V191.488h288.256z"/></svg>' }, { type: "alert", title: "提示", innerHTML: '<svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M193.024 795.99c0 17.692 14.222 32.028 31.972 32.028h574.008a31.972 31.972 0 0 0 31.972-32.029V562.972a318.976 318.976 0 1 0-637.952 0V795.99zm71.964-233.018a247.012 247.012 0 0 1 494.024 0v193.024H404.025V584.988a10.012 10.012 0 0 0-10.013-10.012H349.98a10.012 10.012 0 0 0-9.955 10.012v171.008h-75.037V562.972zM216.918 310.5l39.594-39.595a8.021 8.021 0 0 0 0-11.321l-67.925-67.868a8.021 8.021 0 0 0-11.264 0l-39.595 39.594a8.021 8.021 0 0 0 0 11.264l67.868 67.926a8.021 8.021 0 0 0 11.321 0zM886.5 231.31l-39.595-39.594a8.021 8.021 0 0 0-11.321 0l-67.868 67.868a8.021 8.021 0 0 0 0 11.32L807.31 310.5a8.021 8.021 0 0 0 11.264 0l67.926-67.926a8.021 8.021 0 0 0 0-11.264zM832 892.018H192a31.972 31.972 0 0 0-32.028 31.971v24.007c0 4.38 3.64 7.965 8.02 7.965h688.015c4.38 0 7.965-3.584 7.965-7.965V923.99A31.972 31.972 0 0 0 832 892.018zM484.01 179.996h55.98a7.951 7.951 0 0 0 7.964-7.964V75.947a8.021 8.021 0 0 0-7.965-7.965h-55.978a8.021 8.021 0 0 0-7.965 7.965v95.971c0 4.438 3.527 8.022 7.965 8.022z"/></svg>' }, { type: "clean", title: "清屏", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M479.3 863.6L899.9 443c37.4-37.4 37.4-98.3 0-135.8L716.7 124.1C698.5 106 674.4 96 648.7 96c-25.8 0-50.4 10.8-68.6 29l-455 455c-18.2 18.2-29 42.8-29 68.6 0 25.7 9.9 49.9 28.1 68l183.1 183.2c18.1 18.1 42.2 28.1 67.9 28.1 3 0 5.9-.1 8.8-.4v.1h512c17.7 0 32-14.3 32-32s-14.3-32-32-32H479.3zm-126.8-9L169.4 671.5c-6-6-9.4-14.1-9.4-22.6 0-8.5 3.3-16.6 9.4-22.6l104.9-104.9 228.4 228.4-104.9 104.8c-6 6-14.1 9.4-22.6 9.4-8.6 0-16.6-3.3-22.7-9.4z"/></svg>' }, { type: "download", title: "下载", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M64.3 874.8v62.6c0 4.8 3.9 8.7 8.7 8.7h878c4.8 0 8.7-3.9 8.7-8.7v-62.6c0-4.8-3.9-8.7-8.7-8.7H73c-4.8 0-8.7 3.9-8.7 8.7zm418.9-99.9c3.2 2.9 6.8 5.3 10.9 7.1 5.2 2.3 10.7 3.4 16.1 3.4 9.8 0 19.5-3.6 27-10.5l291.4-270.4c3.5-3.2 3.7-8.7.5-12.2l-42.3-46.2c-3.3-3.6-8.8-3.8-12.3-.5L550.2 654.5v-528c0-4.8-3.9-8.7-8.7-8.7h-62.6c-4.8 0-8.7 3.9-8.7 8.7v527.9L239.6 442.9c-3.5-3.2-9-3-12.3.5L185 489.7c-3.2 3.5-3 9 .5 12.3l297.7 272.9z"/></svg>' }, { type: "fullScreen", title: "全屏/取消全屏", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M181.2 803.4V637H98v208c0 45.9 37.2 83.2 83.2 83.2h208V845H222.8c-23 0-41.6-18.6-41.6-41.6zM844.8 98.6h-208v83.2h166.4c23 0 41.6 18.6 41.6 41.6v166.4H928v-208c0-46-37.3-83.2-83.2-83.2zm-746.6 83v208h83.2V223.2c0-23 18.6-41.6 41.6-41.6h166.4V98.4h-208c-46 0-83.2 37.3-83.2 83.2zm746.4 455.6v166.4c0 23-18.6 41.6-41.6 41.6H636.6v83.2h208c45.9 0 83.2-37.2 83.2-83.2v-208h-83.2z"/></svg>' }, { type: "preview", title: "预览/取消预览", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M832 128c70.692 0 128 57.308 128 128v512c0 70.692-57.308 128-128 128H192c-70.692 0-128-57.308-128-128V256c0-70.692 57.308-128 128-128h640zm0 72H192c-30.619 0-55.498 24.573-56 55.074V768c0 30.619 24.573 55.498 55.074 55.992L192 824h640c30.619 0 55.498-24.573 56-55.074V256c0-30.619-24.573-55.498-55.074-55.992L832 200zM693.031 450.127l.425.417 128 128c13.918 13.918 14.057 36.398.417 50.487l-.417.425-128 128c-14.059 14.059-36.853 14.059-50.912 0-13.918-13.918-14.057-36.398-.417-50.487l.417-.425L745.09 604 642.544 501.456c-13.918-13.918-14.057-36.398-.417-50.487l.417-.425c13.918-13.918 36.398-14.057 50.487-.417zM284 312c19.882 0 36 16.118 36 36s-16.118 36-36 36h-56c-19.882 0-36-16.118-36-36s16.118-36 36-36h56zm512 0c19.882 0 36 16.118 36 36s-16.118 36-36 36H420c-19.882 0-36-16.118-36-36s16.118-36 36-36h376z"/></svg>' }, { type: "draft", title: "保存草稿", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M96 960a32 32 0 1 1 0-64h832a32 32 0 1 1 0 64H96zm632.96-625.152L593.088 199.104l-340.48 340.48L240 690.432l148.032-14.784 340.8-340.8zm45.184-45.248l45.248-45.248-135.744-135.744-45.248 45.248L774.144 289.6zm-45.12-226.176l135.808 135.808c31.232 31.232 24.832 65.408-.192 90.368L412.16 742.144l-247.168 24.448 20.864-250.688L638.336 63.36c25.024-24.96 59.456-31.168 90.688.064z"/></svg>' }, { type: "publish", title: "发布文章", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M128 554.667h768a42.667 42.667 0 0 0 0-85.334H128a42.667 42.667 0 0 0 0 85.334z"/><path d="M469.333 128v768a42.667 42.667 0 0 0 85.334 0V128a42.667 42.667 0 0 0-85.334 0z"/></svg>' }, { type: "about", title: "关于", innerHTML: '<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="20" height="20"><path d="M881.6 512.1c0 203.7-165.7 369.5-369.5 369.5S142.6 715.8 142.6 512.1s165.7-369.5 369.5-369.5 369.5 165.8 369.5 369.5m77.7 0c0-246.6-200.6-447.2-447.2-447.2S64.9 265.5 64.9 512.1s200.6 447.2 447.2 447.2 447.2-200.6 447.2-447.2M582.5 318.2c9-9 14.2-21.6 14.2-34.3 0-12.8-5.2-25.4-14.2-34.4s-21.6-14.2-34.4-14.2c-12.7 0-25.3 5.2-34.3 14.2-9.1 9-14.3 21.6-14.3 34.4 0 12.7 5.2 25.3 14.3 34.3 9 9 21.5 14.3 34.3 14.3s25.3-5.3 34.4-14.3m-96.6 464.3c-7.6 0-15.2-2.6-21.3-7.5-9.9-7.9-14.5-20.7-12.1-33.1l47.9-243.1-26.4 14.8c-16.4 9.2-37.1 3.4-46.3-13-9.2-16.4-3.4-37.1 12.9-46.3l90.7-51.1c11.6-6.5 25.9-5.7 36.6 2.1 10.8 7.8 16 21.1 13.4 34.1l-49.6 251.9 40.7-17.7c17.2-7.5 37.3.4 44.8 17.6 7.5 17.2-.4 37.3-17.6 44.8l-100.2 43.7c-4.3 1.9-8.9 2.8-13.5 2.8"/></svg>' }]; const zh = new HyperDown, qh = window.JoeConfig.playerAPI; function Vh(t) { if (!window.JoeConfig.canPreview) return $(".cm-preview-content").html("1. 预览已默认关闭<br>2. 点击上方预览按钮启用预览<br>3. 若编辑器卡顿可尝试关闭预览"); -1 !== t.indexOf("　") && (t = t.replace(/　/g, "&emsp;")), -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = -1 !== (t = (t = (t = zh.makeHtml(t)).replace(/\:\:\(\s*(呵呵|哈哈|吐舌|太开心|笑眼|花心|小乖|乖|捂嘴笑|滑稽|你懂的|不高兴|怒|汗|黑线|泪|真棒|喷|惊哭|阴险|鄙视|酷|啊|狂汗|what|疑问|酸爽|呀咩爹|委屈|惊讶|睡觉|笑尿|挖鼻|吐|犀利|小红脸|懒得理|勉强|爱心|心碎|玫瑰|礼物|彩虹|太阳|星星月亮|钱币|茶杯|蛋糕|大拇指|胜利|haha|OK|沙发|手纸|香蕉|便便|药丸|红领巾|蜡烛|音乐|灯泡|开心|钱|咦|呼|冷|生气|弱|吐血|狗头)\s*\)/g, function (t, e) { return e = encodeURI(e).replace(/%/g, ""), `<img class="owo" src="${window.JoeConfig.themeURL}assets/owo/paopao/${e}_2x.png" />` })).replace(/\:\@\(\s*(高兴|小怒|脸红|内伤|装大款|赞一个|害羞|汗|吐血倒地|深思|不高兴|无语|亲亲|口水|尴尬|中指|想一想|哭泣|便便|献花|皱眉|傻笑|狂汗|吐|喷水|看不见|鼓掌|阴暗|长草|献黄瓜|邪恶|期待|得意|吐舌|喷血|无所谓|观察|暗地观察|肿包|中枪|大囧|呲牙|抠鼻|不说话|咽气|欢呼|锁眉|蜡烛|坐等|击掌|惊喜|喜极而泣|抽烟|不出所料|愤怒|无奈|黑线|投降|看热闹|扇耳光|小眼睛|中刀)\s*\)/g, function (t, e) { return e = encodeURI(e).replace(/%/g, ""), `<img class="owo" src="${window.JoeConfig.themeURL}assets/owo/aru/${e}_2x.png" />` })).indexOf("{lamp") ? t.replace(/{lamp\/}/g, '<span class="joe_lamp"></span>') : t).indexOf("{x}") ? t.replace(/{x}/g, '<input type="checkbox" class="joe_checkbox" checked disabled></input>') : t).indexOf("{ }") ? t.replace(/{ }/g, '<input type="checkbox" class="joe_checkbox" disabled></input>') : t).indexOf("{mtitle") ? t.replace(/{mtitle([^}]*)\/}/g, "<joe-mtitle $1></joe-mtitle>") : t).indexOf("{dplayer") ? t.replace(/{dplayer([^}]*)\/}/g, '<joe-dplayer player="' + qh + '" $1></joe-dplayer>') : t).indexOf("{bilibili") ? t.replace(/{bilibili([^}]*)\/}/g, "<joe-bilibili $1></joe-bilibili>") : t).indexOf("{music-list") ? t.replace(/{music-list([^}]*)\/}/g, "<joe-mlist $1></joe-mlist>") : t).indexOf("{music") ? t.replace(/{music([^}]*)\/}/g, "<joe-music $1></joe-music>") : t).indexOf("{mp3") ? t.replace(/{mp3([^}]*)\/}/g, "<joe-mp3 $1></joe-mp3>") : t).indexOf("{abtn") ? t.replace(/{abtn([^}]*)\/}/g, "<joe-abtn $1></joe-abtn>") : t).indexOf("{anote") ? t.replace(/{anote([^}]*)\/}/g, "<joe-anote $1></joe-anote>") : t).indexOf("{copy") ? t.replace(/{copy([^}]*)\/}/g, "<joe-copy $1></joe-copy>") : t).indexOf("{dotted") ? t.replace(/{dotted([^}]*)\/}/g, "<joe-dotted $1></joe-dotted>") : t).indexOf("{message") ? t.replace(/{message([^}]*)\/}/g, "<joe-message $1></joe-message>") : t).indexOf("{progress") ? t.replace(/{progress([^}]*)\/}/g, "<joe-progress $1></joe-progress>") : t).indexOf("{cloud") ? t.replace(/{cloud([^}]*)\/}/g, "<joe-cloud $1></joe-cloud>") : t).indexOf("{hide") ? t.replace(/{hide[^}]*}([\s\S]*?){\/hide}/g, "<joe-hide></joe-hide>") : t).indexOf("{card-default") ? t.replace(/{card-default([^}]*)}([\s\S]*?){\/card-default}/g, '<section style="margin-bottom: 15px"><joe-card-default $1><span class="_temp" style="display: none">$2</span></joe-card-default></section>') : t).indexOf("{callout") ? t.replace(/{callout([^}]*)}([\s\S]*?){\/callout}/g, '<section style="margin-bottom: 15px"><joe-callout $1><span class="_temp" style="display: none">$2</span></joe-callout></section>') : t).indexOf("{card-describe") ? t.replace(/{card-describe([^}]*)}([\s\S]*?){\/card-describe}/g, '<section style="margin-bottom: 15px"><joe-card-describe $1><span class="_temp" style="display: none">$2</span></joe-card-describe></section>') : t).indexOf("{tabs") ? t.replace(/{tabs}([\s\S]*?){\/tabs}/g, '<section style="margin-bottom: 15px"><joe-tabs><span class="_temp" style="display: none">$1</span></joe-tabs></section>') : t).indexOf("{card-list") ? t.replace(/{card-list}([\s\S]*?){\/card-list}/g, '<section style="margin-bottom: 15px"><joe-card-list><span class="_temp" style="display: none">$1</span></joe-card-list></section>') : t).indexOf("{timeline") ? t.replace(/{timeline}([\s\S]*?){\/timeline}/g, '<section style="margin-bottom: 15px"><joe-timeline><span class="_temp" style="display: none">$1</span></joe-timeline></section>') : t).indexOf("{collapse") ? t.replace(/{collapse}([\s\S]*?){\/collapse}/g, '<section style="margin-bottom: 15px"><joe-collapse><span class="_temp" style="display: none">$1</span></joe-collapse></section>') : t).indexOf("{alert") ? t.replace(/{alert([^}]*)}([\s\S]*?){\/alert}/g, '<section style="margin-bottom: 15px"><joe-alert $1><span class="_temp" style="display: none">$2</span></joe-alert></section>') : t).indexOf("{gird") && (t = t.replace(/{gird([^}]*)}([\s\S]*?){\/gird}/g, '<section style="margin-bottom: 15px"><joe-gird $1><span class="_temp" style="display: none">$2</span></joe-gird></section>')), $(".cm-preview-content").html(t), $(".cm-preview-content p:empty").remove(), $(".cm-preview-content pre code").each((t, e) => Prism.highlightElement(e)) } class Yh extends class {
		constructor() {
			$("body").append(`
            <div class="cm-modal">
                <div class="cm-modal__wrapper">
                    <div class="cm-modal__wrapper-header">
                        <div class="cm-modal__wrapper-header--text"></div>
                        <div class="cm-modal__wrapper-header--close">×</div>
                    </div>
                    <div class="cm-modal__wrapper-bodyer"></div>
                    <div class="cm-modal__wrapper-footer">
                        <button class="cm-modal__wrapper-footer--cancle">取消</button>
                        <button class="cm-modal__wrapper-footer--confirm">确定</button>
                    </div>
                </div>
            </div>
        `), $(".cm-modal__wrapper-footer--cancle, .cm-modal__wrapper-header--close").on("click", () => $(".cm-modal").removeClass("active")), $(".cm-modal__wrapper-footer--confirm").on("click", () => { this.options.confirm(), $(".cm-modal").removeClass("active") })
		} _openModal(t = {}) { this.options = Object.assign({ title: "提示", innerHtml: "内容", hasFooter: !0, confirm: () => { }, handler: () => { } }, t), $(".cm-modal__wrapper-header--text").html(this.options.title), $(".cm-modal__wrapper-bodyer").html(this.options.innerHtml), this.options.hasFooter ? $(".cm-modal__wrapper-footer").show() : $(".cm-modal__wrapper-footer").hide(), $(".cm-modal").addClass("active"), this.options.handler() } _getLineCh(t) { var e = t.state.selection.main.head; return e - t.state.doc.lineAt(e).from } _replaceSelection(t, e) { t.dispatch(t.state.replaceSelection(e)) } _setCursor(t, e) { t.dispatch({ selection: { anchor: e } }) } _getSelection(t) { return t.state.sliceDoc(t.state.selection.main.from, t.state.selection.main.to) } _insetAmboText(t, e) { var i = t.state.selection.main.head, n = this._getSelection(t); this._replaceSelection(t, ` ${e + n + e} `), "" === n && this._setCursor(t, i + e.length + 1), t.focus() } _createTableLists(s, t, o = "", a) { $.ajax({ url: t, dataType: "json", success: t => { let e = "", i = ""; for (var n in t) { const r = t[n].split(" "); e += `<div class="tabbar-item ${n === o ? "active" : ""}" data-show="${n}">${n}</div>`, i += `<div class="lists ${n === o ? "active" : ""}" data-show="${n}">${r.map(t => `<div class="lists-item" data-text="${t}">${t}</div>`).join(" ")}</div>` } this._openModal({ title: a, hasFooter: !1, innerHtml: `<div class="tabbar">${e}</div>${i}`, handler: () => { $(".cm-modal__wrapper-bodyer .tabbar-item").on("click", function () { const t = $(this); var e = t.attr("data-show"); const i = $(".cm-modal__wrapper-bodyer .tabbar"); t.addClass("active").siblings().removeClass("active"), i.stop().animate({ scrollLeft: t[0].offsetLeft - i[0].offsetWidth / 2 + t[0].offsetWidth / 2 - 15 }), $(".cm-modal__wrapper-bodyer .lists").removeClass("active"), $(".cm-modal__wrapper-bodyer .lists[data-show='" + e + "']").addClass("active") }); const e = this; $(".cm-modal__wrapper-bodyer .lists-item").on("click", function () { var t = $(this).attr("data-text"); e._replaceSelection(s, ` ${t} `), $(".cm-modal").removeClass("active"), s.focus() }) } }) } }) } handleFullScreen(t) { t.toggleClass("active"), $("body").toggleClass("fullscreen"), $(".cm-container").toggleClass("fullscreen"), $(".cm-preview").width(0) } handlePublish() { $("#btn-submit").click() } handleUndo(t) { bo(t), t.focus() } handleRedo(t) { xo(t), t.focus() } handleIndent(t) { this._replaceSelection(t, "　"), t.focus() } handleTime(t) { const e = new Date; var i = e.getFullYear(), n = String(e.getMonth() + 1).padStart(2, 0), r = String(e.getDate()).padStart(2, 0), s = String(e.getHours()).padStart(2, 0), o = String(e.getMinutes()).padStart(2, 0), a = String(e.getSeconds()).padStart(2, 0), l = ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"][e.getDay()], l = `${this._getLineCh(t) ? "\n" : ""}${i}-${n}-${r} ${s}:${o}:${a} ${l}\n`; this._replaceSelection(t, l), t.focus() } handleHr(t) { var e = `${this._getLineCh(t) ? "\n" : ""}\n------------\n\n`; this._replaceSelection(t, e), t.focus() } handleClean(t) { t.dispatch({ changes: { from: 0, to: t.state.doc.length, insert: "" } }), t.focus() } handleOrdered(t) { const e = this._getSelection(t); if ("" === e) { var i = (this._getLineCh(t) ? "\n\n" : "") + "1. "; this._replaceSelection(t, i) } else { const n = e.split("\n"); for (let t = 0, e = n.length; t < e; t++)n[t] = "" === n[t] ? "" : t + 1 + ". " + n[t]; i = (this._getLineCh(t) ? "\n" : "") + n.join("\n"); this._replaceSelection(t, i) } t.focus() } handleUnordered(t) { const e = this._getSelection(t); if ("" === e) { var i = (this._getLineCh(t) ? "\n" : "") + "- "; this._replaceSelection(t, i) } else { const n = e.split("\n"); for (let t = 0, e = n.length; t < e; t++)n[t] = "" === n[t] ? "" : "- " + n[t]; i = (this._getLineCh(t) ? "\n" : "") + n.join("\n"); this._replaceSelection(t, i) } t.focus() } handleQuote(t) { const e = this._getSelection(t); if ("" === e) this._replaceSelection(t, `${this._getLineCh(t) ? "\n" : ""}> `); else { const n = e.split("\n"); for (let t = 0, e = n.length; t < e; t++)n[t] = "" === n[t] ? "" : "> " + n[t]; var i = (this._getLineCh(t) ? "\n" : "") + n.join("\n"); this._replaceSelection(t, i) } t.focus() } handleDownload(t) { var e = $("#title").val() || "新文章"; const i = document.createElement("a"); t = new Blob([t.state.doc.toString()]); i.download = e + ".md", i.href = URL.createObjectURL(t), i.click(), URL.revokeObjectURL(t) } handleTitle(e, t) {
			const i = $(`
			<div class="cm-tools-item" title="${t.title}">
				${t.innerHTML}
				<div class="cm-tools__dropdown">
					<div class="cm-tools__dropdown-item" data-text="# "> H1 </div>
					<div class="cm-tools__dropdown-item" data-text="## "> H2 </div>
					<div class="cm-tools__dropdown-item" data-text="### "> H3 </div>
					<div class="cm-tools__dropdown-item" data-text="#### "> H4 </div>
					<div class="cm-tools__dropdown-item" data-text="##### "> H5 </div>
					<div class="cm-tools__dropdown-item" data-text="###### "> H6 </div>
				</div>
			</div>
		`); i.on("click", function (t) { t.stopPropagation(), $(this).toggleClass("active") }); const n = this; i.on("click", ".cm-tools__dropdown-item", function (t) { t.stopPropagation(); t = $(this).attr("data-text"); n._getLineCh(e) ? n._replaceSelection(e, "\n\n" + t) : n._replaceSelection(e, t), i.removeClass("active"), e.focus() }), $(document).on("click", () => i.removeClass("active")), $(".cm-tools").append(i)
		} handleLink(i) {
			this._openModal({
				title: "插入链接", innerHtml: `
                <div class="fitem">
                    <label>链接标题</label>
                    <input autocomplete="off" name="title" placeholder="请输入链接标题"/>
                </div>
                <div class="fitem">
                    <label>链接地址</label>
                    <input autocomplete="off" name="url" placeholder="请输入链接地址"/>
                </div>
            `, confirm: () => { var t = $(".cm-modal input[name='title']").val() || "Test", e = $(".cm-modal input[name='url']").val() || "http://"; this._replaceSelection(i, ` [${t}](${e}) `), i.focus() }
			})
		} handleImage(i) {
			this._openModal({
				title: "插入图片", innerHtml: `
                <div class="fitem">
                    <label>图片名称</label>
                    <input autocomplete="off" name="title" placeholder="请输入图片名称"/>
                </div>
                <div class="fitem">
                    <label>图片地址</label>
                    <input autocomplete="off" name="url" placeholder="请输入图片地址"/>
                </div>
            `, confirm: () => { var t = $(".cm-modal input[name='title']").val() || "Test", e = $(".cm-modal input[name='url']").val() || "http://"; this._replaceSelection(i, ` ![${t}](${e}) `), i.focus() }
			})
		} handleTable(o) {
			this._openModal({
				title: "插入表格", innerHtml: `
                <div class="fitem">
                    <label>表格行</label>
                    <input style="width: 50px; flex: none; margin-right: 10px;" value="3" autocomplete="off" name="row"/>
                    <label>表格列</label>
                    <input style="width: 50px; flex: none;" value="3" autocomplete="off" name="column"/>
                </div>
            `, confirm: () => { let e = $(".cm-modal input[name='row']").val(), i = $(".cm-modal input[name='column']").val(); isNaN(e) && (e = 3), isNaN(i) && (i = 3); let n = "", r = "", s = ""; for (let t = 0; t < i; t++)n += "| 表头 ", r += "| :--: "; for (let t = 0; t < e; t++) { for (let t = 0; t < i; t++)s += "| 表格 "; s += "|\n" } var t = `${n}|\n${r}|\n${s}\n`; this._getLineCh(o) ? this._replaceSelection(o, "\n\n" + t) : this._replaceSelection(o, t), o.focus() }
			})
		} handleGird(e) {
			this._openModal({
				title: "插入宫格", innerHtml: `
                <div class="fitem">
                    <label>宫格列数</label>
                    <input value="3" autocomplete="off" name="column" placeholder="请输入宫格列数"/>
                </div>
                <div class="fitem">
                    <label>宫格间隔</label>
                    <input value="15" autocomplete="off" name="gap" placeholder="请输入宫格间隔"/>
                </div>
            `, confirm: () => { var t = `{gird column="${$(".cm-modal input[name='column']").val()}" gap="${$(".cm-modal input[name='gap']").val()}"}\n{gird-item}\n 宫格内容一\n{/gird-item}\n{gird-item}\n 宫格内容二\n{/gird-item}\n{gird-item}\n 宫格内容三\n{/gird-item}\n{/gird}`; this._getLineCh(e) ? this._replaceSelection(e, "\n\n" + t) : this._replaceSelection(e, t), e.focus() }
			})
		} handleCodeBlock(i) {
			const t = "rss+atom+ssml+mathml+svg+html+markup+css+clike+javascript+abap+abnf+actionscript+ada+agda+al+antlr4+apacheconf+apex+apl+applescript+aql+arduino+arff+asciidoc+aspnet+asm6502+autohotkey+autoit+bash+basic+batch+bbcode+birb+bison+bnf+brainfuck+brightscript+bro+bsl+c+csharp+cpp+cfscript+chaiscript+cil+clojure+cmake+cobol+coffeescript+concurnas+csp+coq+crystal+css-extras+csv+cypher+d+dart+dataweave+dax+dhall+diff+django+dns-zone-file+docker+dot+ebnf+editorconfig+eiffel+ejs+elixir+elm+etlua+erb+erlang+excel-formula+fsharp+factor+false+firestore-security-rules+flow+fortran+ftl+gml+gcode+gdscript+gedcom+gherkin+git+glsl+go+graphql+groovy+haml+handlebars+haskell+haxe+hcl+hlsl+http+hpkp+hsts+ichigojam+icon+icu-message-format+idris+ignore+inform7+ini+io+j+java+javadoc+javadoclike+javastacktrace+jexl+jolie+jq+jsdoc+js-extras+json+json5+jsonp+jsstacktrace+js-templates+julia+keyman+kotlin+kumir+latex+latte+less+lilypond+liquid+lisp+livescript+llvm+log+lolcode+lua+makefile+markdown+markup-templating+matlab+mel+mizar+mongodb+monkey+moonscript+n1ql+n4js+nand2tetris-hdl+naniscript+nasm+neon+nevod+nginx+nim+nix+nsis+objectivec+ocaml+opencl+openqasm+oz+parigp+parser+pascal+pascaligo+psl+pcaxis+peoplecode+perl+php+phpdoc+php-extras+plsql+powerquery+powershell+processing+prolog+promql+properties+protobuf+pug+puppet+pure+purebasic+purescript+python+qsharp+q+qml+qore+r+racket+jsx+tsx+reason+regex+rego+renpy+rest+rip+roboconf+robotframework+ruby+rust+sas+sass+scss+scala+scheme+shell-session+smali+smalltalk+smarty+sml+solidity+solution-file+soy+sparql+splunk-spl+sqf+sql+squirrel+stan+iecst+stylus+swift+t4-templating+t4-cs+t4-vb+tap+tcl+tt2+textile+toml+turtle+twig+typescript+typoscript+unrealscript+uri+v+vala+vbnet+velocity+verilog+vhdl+vim+visual-basic+warpscript+wasm+wiki+xeora+xml-doc+xojo+xquery+yaml+yang+zig".split("+").sort((t, e) => t.localeCompare(e)), e = sessionStorage.getItem("selectType") || ""; let n = ""; t.forEach(t => { n += `<option ${e === t ? "selected" : ""} value="${t}">${t.toUpperCase()}</option>` }), this._openModal({
				title: "插入代码块", innerHtml: `
                <div class="fitem">
                    <label>语言类型</label>
                    <select name="type">
                        <option value="">- 请选择语言类型 -</option>
                        ${n}
                    </select>
                </div>
            `, confirm: () => { var t, e = $(".cm-modal select[name='type']").val(); e && (t = `\`\`\`${e}\ncode here...\n\`\`\``, this._getLineCh(i) ? this._replaceSelection(i, "\n\n" + t) : this._replaceSelection(i, t), i.focus(), sessionStorage.setItem("selectType", e)) }
			})
		} handleAbout() {
			this._openModal({
				title: "关于", hasFooter: !1, innerHtml: `
                <ul>
                    <li>短代码功能正在开发中...</li>
                    <li>仅支持网络图片粘贴上传（截图等）</li>
                    <li>本编辑器仅供Joe主题使用，未经允许不得移植至其他主题！</li>
                </ul>
            `})
		} handleTask(t, e) { this._replaceSelection(t, ` ${e ? "{x}" : "{ }"} `), t.focus() } handleNetease(n, r) {
			this._openModal({
				title: r ? "网易云歌单" : "网易云单首", innerHtml: `
				<div class="fitem">
					<label>歌${r ? "单" : "曲"}　ID</label>
					<input autocomplete="off" name="id" placeholder="请输入歌${r ? "单" : "曲"}ID"/>
				</div>
				<div class="fitem">
					<label>主题色彩</label>
					<input style="width: 44px;padding: 0 2px;flex: none" autocomplete="off" value="#1989fa" name="color" type="color"/>
				</div>
				<div class="fitem">
					<label>自动播放</label>
					<select name="autoplay">
						<option value="1" selected>是</option>
						<option value="0">否</option>
					</select>
				</div>
            `, confirm: () => { var t = $(".cm-modal input[name='id']").val(), e = $(".cm-modal input[name='color']").val(), i = $(".cm-modal select[name='autoplay']").val(), i = `\n{${r ? "music-list" : "music"} id="${t}" color="${e}" ${"1" === i ? 'autoplay="autoplay"' : ""}/}\n\n`; this._getLineCh(n) ? this._replaceSelection(n, "\n" + i) : this._replaceSelection(n, i), n.focus() }
			})
		} handleBilibili(e) {
			this._openModal({
				title: "BiliBili视频", innerHtml: `
				<div class="fitem">
					<label>视频Bvid</label>
					<input autocomplete="off" name="bvid" placeholder="请输入视频Bvid"/>
				</div>
				<div class="fitem">
					<label>视频选集</label>
					<input autocomplete="off" name="bvp" placeholder="请输入视频第n集" value="1"/>
				</div>
            `, confirm: () => { var t = `\n{bilibili bvid="${$(".cm-modal input[name='bvid']").val()}" bvp="${$(".cm-modal input[name='bvp']").val()}"/}\n\n`; this._getLineCh(e) ? this._replaceSelection(e, "\n" + t) : this._replaceSelection(e, t), e.focus() }
			})
		} handleDplayer(e) {
			this._openModal({
				title: "M3U8/MP4视频", innerHtml: `
				<div class="fitem">
					<label>视频地址</label>
					<input autocomplete="off" name="src" placeholder="请输入视频地址"/>
				</div>
            `, confirm: () => { var t = `\n{dplayer src="${$(".cm-modal input[name='src']").val()}"/}\n\n`; this._getLineCh(e) ? this._replaceSelection(e, "\n" + t) : this._replaceSelection(e, t), e.focus() }
			})
		} handleDraft() { $("#btn-save").click() } handleExpression(s) { $.ajax({ url: window.JoeConfig.expressionAPI, dataType: "json", success: t => { let i = "", n = ""; for (let e in t) { const r = t[e]; i += `<div class="tabbar-item ${"泡泡" === e ? "active" : ""}" data-show="${e}">${e}</div>`, n += `<div class="lists ${"泡泡" === e ? "active" : ""}" data-show="${e}">${r.map(t => `<div class="lists-item" data-text="${t.data}">${"颜文字" === e ? t.icon : `<img src="${window.JoeConfig.themeURL + t.icon}">`}</div>`).join(" ")}</div>` } this._openModal({ title: "普通表情", hasFooter: !1, innerHtml: `<div class="tabbar">${i}</div>${n}`, handler: () => { $(".cm-modal__wrapper-bodyer .tabbar-item").on("click", function () { var t = $(this).attr("data-show"); $(this).addClass("active").siblings().removeClass("active"), $(".cm-modal__wrapper-bodyer .lists").removeClass("active"), $(".cm-modal__wrapper-bodyer .lists[data-show='" + t + "']").addClass("active") }); const e = this; $(".cm-modal__wrapper-bodyer .lists-item").on("click", function () { var t = $(this).attr("data-text"); e._replaceSelection(s, ` ${t} `), $(".cm-modal").removeClass("active"), s.focus() }) } }) } }) } handleMtitle(e) {
			this._openModal({
				title: "居中标题", innerHtml: `
				<div class="fitem">
					<label>标题内容</label>
					<input autocomplete="off" maxlength="10" name="text" placeholder="请输入标题内容（10字以内）"/>
				</div>
            `, confirm: () => { var t = `\n{mtitle title="${$(".cm-modal input[name='text']").val()}"/}\n\n`; this._getLineCh(e) ? this._replaceSelection(e, "\n" + t) : this._replaceSelection(e, t), e.focus() }
			})
		} handleHtml(t) { var e = `${this._getLineCh(t) ? "\n" : ""}!!!\n<p align="center">居中</p>\n<p align="right">居右</p>\n<font size="5" color="red">颜色大小</font>\n!!!\n`; this._replaceSelection(t, e), t.focus() } handleHide(t) { var e = `${this._getLineCh(t) ? "\n\n" : "\n"}{hide}\n需要隐藏的内容\n{/hide}\n\n`; this._replaceSelection(t, e), t.focus() } handleAbtn(s) {
			this._openModal({
				title: "多彩按钮", innerHtml: `
				<div class="fitem">
					<label>按钮图标</label>
					<input autocomplete="off" name="icon" placeholder="请输入fa图标，例：fa-download"/>
				</div>
				<div class="fitem">
					<label>图标大全</label>
					<a href="https://fontawesome.dashgame.com" target="_blank">fontawesome.dashgame.com</a>
				</div>
				<div class="fitem">
					<label>按钮颜色</label>
					<input style="width: 44px;padding: 0 2px;flex: none" autocomplete="off" value="#ff6800" name="color" type="color"/>
				</div>
				<div class="fitem">
					<label>跳转链接</label>
					<input autocomplete="off" name="href" placeholder="请输入跳转链接"/>
				</div>
				<div class="fitem">
					<label>按钮圆角</label>
					<input autocomplete="off" name="radius" placeholder="请输入按钮圆角，例：17.5px"/>
				</div>
				<div class="fitem">
					<label>按钮内容</label>
					<input autocomplete="off" name="content" placeholder="请输入按钮内容"/>
				</div>
            `, confirm: () => { var t = $(".cm-modal input[name='icon']").val(), e = $(".cm-modal input[name='color']").val(), i = $(".cm-modal input[name='href']").val(), n = $(".cm-modal input[name='radius']").val(), r = $(".cm-modal input[name='content']").val(); this._replaceSelection(s, ` {abtn icon="${t}" color="${e}" href="${i}" radius="${n}" content="${r}"/} `), s.focus() }
			})
		} handleAnote(r) {
			this._openModal({
				title: "便条按钮", innerHtml: `
				<div class="fitem">
					<label>按钮图标</label>
					<input autocomplete="off" name="icon" placeholder="请输入fa图标，例：fa-download"/>
				</div>
				<div class="fitem">
					<label>图标大全</label>
					<a href="https://fontawesome.dashgame.com" target="_blank">fontawesome.dashgame.com</a>
				</div>
				<div class="fitem">
					<label>跳转链接</label>
					<input autocomplete="off" name="href" placeholder="请输入跳转链接"/>
				</div>
				<div class="fitem">
					<label>按钮类型</label>
					<select name="type">
						<option value="secondary" selected>secondary</option>
						<option value="success">success</option>
						<option value="warning">warning</option>
						<option value="error">error</option>
						<option value="info">info</option>
					</select>
				</div>
				<div class="fitem">
					<label>按钮内容</label>
					<input autocomplete="off" name="content" placeholder="请输入按钮内容"/>
				</div>
            `, confirm: () => { var t = $(".cm-modal input[name='icon']").val(), e = $(".cm-modal input[name='href']").val(), i = $(".cm-modal select[name='type']").val(), n = $(".cm-modal input[name='content']").val(); this._replaceSelection(r, ` {anote icon="${t}" href="${e}" type="${i}" content="${n}"/} `), r.focus() }
			})
		} handleDotted(e) {
			this._openModal({
				title: "彩色虚线", innerHtml: `
				<div class="fitem">
					<label>开始颜色</label>
					<input style="width: 44px;padding: 0 2px;flex: none" autocomplete="off" value="#ff6c6c" name="startColor" type="color"/>
				</div>
				<div class="fitem">
					<label>结束颜色</label>
					<input style="width: 44px;padding: 0 2px;flex: none" autocomplete="off" value="#1989fa" name="endColor" type="color"/>
				</div>
            `, confirm: () => { var t = `\n{dotted startColor="${$(".cm-modal input[name='startColor']").val()}" endColor="${$(".cm-modal input[name='endColor']").val()}"/}\n\n`; this._getLineCh(e) ? this._replaceSelection(e, "\n" + t) : this._replaceSelection(e, t), e.focus() }
			})
		} handleCardDefault(e) {
			this._openModal({
				title: "默认卡片", innerHtml: `
				<div class="fitem">
					<label>卡片标题</label>
					<input autocomplete="off" name="label" placeholder="请输入卡片标题"/>
				</div>
				<div class="fitem">
					<label>卡片宽度</label>
					<input autocomplete="off" name="width" placeholder="请输入卡片宽度，例如：100%"/>
				</div>
            `, confirm: () => { var t = `\n{card-default label="${$(".cm-modal input[name='label']").val()}" width="${$(".cm-modal input[name='width']").val()}"}\n卡片内容\n{/card-default}\n\n`; this._getLineCh(e) ? this._replaceSelection(e, "\n" + t) : this._replaceSelection(e, t), e.focus() }
			})
		} handleMessage(e) {
			this._openModal({
				title: "消息提示", innerHtml: `
				<div class="fitem">
					<label>消息类型</label>
					<select name="type">
						<option value="success" selected>success</option>
						<option value="info">info</option>
						<option value="warning">warning</option>
						<option value="error">error</option>
					</select>
				</div>
				<div class="fitem" style="align-items: flex-start">
					<label>消息内容</label>
					<textarea autocomplete="off" name="content" placeholder="请输入消息内容"></textarea>
				</div>
            `, confirm: () => { var t = `\n{message type="${$(".cm-modal select[name='type']").val()}" content="${$(".cm-modal textarea[name='content']").val()}"/}\n\n`; this._getLineCh(e) ? this._replaceSelection(e, "\n" + t) : this._replaceSelection(e, t), e.focus() }
			})
		} handleProgress(e) {
			this._openModal({
				title: "进度条", innerHtml: `
				<div class="fitem">
					<label>百分比数</label>
					<input autocomplete="off" name="percentage" placeholder="请输入百分比（最大100%）"/>
				</div>
				<div class="fitem">
					<label>自定义色</label>
					<input style="width: 44px;padding: 0 2px;flex: none" autocomplete="off" value="#ff6c6c" name="color" type="color"/>
				</div>
            `, confirm: () => { var t = `\n{progress percentage="${$(".cm-modal input[name='percentage']").val()}" color="${$(".cm-modal input[name='color']").val()}"/}\n\n`; this._getLineCh(e) ? this._replaceSelection(e, "\n" + t) : this._replaceSelection(e, t), e.focus() }
			})
		} handleCallout(e) {
			this._openModal({
				title: "插入标注", innerHtml: `
				<div class="fitem">
					<label>边框颜色</label>
					<input style="width: 44px;padding: 0 2px;flex: none" autocomplete="off" value="#f0ad4e" name="color" type="color"/>
				</div>
            `, confirm: () => { var t = `\n{callout color="${$(".cm-modal input[name='color']").val()}"}\n标注内容\n{/callout}\n\n`; this._getLineCh(e) ? this._replaceSelection(e, "\n" + t) : this._replaceSelection(e, t), e.focus() }
			})
		} handleMp3(e) {
			this._openModal({
				title: "插入音乐", innerHtml: `
				<div class="fitem">
					<label>音频名称</label>
					<input autocomplete="off" name="name" placeholder="请输入音频名称"/>
				</div>
				<div class="fitem">
					<label>音频地址</label>
					<input autocomplete="off" name="url" placeholder="请输入音频地址"/>
				</div>
				<div class="fitem">
					<label>音频封面</label>
					<input autocomplete="off" name="cover" placeholder="请输入图片地址"/>
				</div>
				<div class="fitem">
					<label>主题色彩</label>
					<input style="width: 44px;padding: 0 2px;flex: none" autocomplete="off" value="#f0ad4e" name="theme" type="color"/>
				</div>
				<div class="fitem">
					<label>自动播放</label>
					<select name="autoplay">
						<option value="1" selected>是</option>
						<option value="0">否</option>
					</select>
				</div>
            `, confirm: () => { var t = `\n{mp3 name="${$(".cm-modal input[name='name']").val()}" url="${$(".cm-modal input[name='url']").val()}" cover="${$(".cm-modal input[name='cover']").val()}" theme="${$(".cm-modal input[name='theme']").val()}" ${"1" === $(".cm-modal select[name='autoplay']").val() ? 'autoplay="autoplay"' : ""}/}\n\n`; this._getLineCh(e) ? this._replaceSelection(e, "\n" + t) : this._replaceSelection(e, t), e.focus() }
			})
		} handleTabs(t) { var e = `${this._getLineCh(t) ? "\n\n" : "\n"}{tabs}\n{tabs-pane label="标签一"}\n 标签一内容\n{/tabs-pane}\n{tabs-pane label="标签二"}\n 标签二内容\n{/tabs-pane}\n{/tabs}\n\n`; this._replaceSelection(t, e), t.focus() } handleCardList(t) { var e = `${this._getLineCh(t) ? "\n\n" : "\n"}{card-list}\n{card-list-item}\n 列表一内容\n{/card-list-item}\n{card-list-item}\n 列表二内容\n{/card-list-item}\n{/card-list}\n\n`; this._replaceSelection(t, e), t.focus() } handleTimeline(t) { var e = `${this._getLineCh(t) ? "\n\n" : "\n"}{timeline}\n{timeline-item color="#19be6b"}\n 正式上线\n{/timeline-item}\n{timeline-item color="#ed4014"}\n 删库跑路\n{/timeline-item}\n{/timeline}\n\n`; this._replaceSelection(t, e), t.focus() } handleCardDescribe(t) { var e = `${this._getLineCh(t) ? "\n\n" : "\n"}{card-describe title="卡片描述"}\n卡片内容\n{/card-describe}\n\n`; this._replaceSelection(t, e), t.focus() } handleCopy(e) {
			this._openModal({
				title: "复制文本", innerHtml: `
				<div class="fitem">
					<label>显示文案</label>
					<input autocomplete="off" name="showText" placeholder="请输入显示文案"/>
				</div>
				<div class="fitem" style="align-items: flex-start">
					<label>复制内容</label>
					<textarea autocomplete="off" name="copyText" placeholder="请输入需要复制的内容"></textarea>
				</div>
            `, confirm: () => { var t = `\n{copy showText="${$(".cm-modal input[name='showText']").val()}" copyText="${$(".cm-modal textarea[name='copyText']").val()}"/}\n\n`; this._getLineCh(e) ? this._replaceSelection(e, "\n" + t) : this._replaceSelection(e, t), e.focus() }
			})
		} handleLamp(t) { var e = `${this._getLineCh(t) ? "\n\n" : "\n"}{lamp/}\n\n`; this._replaceSelection(t, e), t.focus() } handleCollapse(t) { var e = `${this._getLineCh(t) ? "\n\n" : "\n"}{collapse}\n{collapse-item label="折叠标题一" open}\n 折叠内容一\n{/collapse-item}\n{collapse-item label="折叠标题二"}\n 折叠内容二\n{/collapse-item}\n{/collapse}\n\n`; this._replaceSelection(t, e), t.focus() } handleAlert(e) {
			this._openModal({
				title: "警告提示", innerHtml: `
				<div class="fitem">
					<label>提示类型</label>
					<select name="type">
						<option value="info" selected>info</option>
						<option value="success">success</option>
						<option value="warning">warning</option>
						<option value="error">error</option>
					</select>
				</div>
            `, confirm: () => { var t = `\n{alert type="${$(".cm-modal select[name='type']").val()}"}\n警告提示\n{/alert}\n\n`; this._getLineCh(e) ? this._replaceSelection(e, "\n" + t) : this._replaceSelection(e, t), e.focus() }
			})
		} handleCloud(e) {
			this._openModal({
				title: "网盘下载", innerHtml: `
				<div class="fitem">
					<label>网盘类型</label>
					<select name="type">
						<option value="default" selected>默认网盘</option>
						<option value="360">360网盘</option>
						<option value="bd">百度网盘</option>
						<option value="ty">天翼网盘</option>
						<option value="ct">城通网盘</option>
						<option value="wy">微云网盘</option>
						<option value="github">Github仓库</option>
						<option value="lz">蓝奏云网盘</option>
					</select>
				</div>
				<div class="fitem">
					<label>显示标题</label>
					<input autocomplete="off" name="title" placeholder="请输入显示标题"/>
				</div>
				<div class="fitem">
					<label>下载地址</label>
					<input autocomplete="off" name="url" placeholder="请输入网盘地址"/>
				</div>
				<div class="fitem">
					<label>提取密码</label>
					<input autocomplete="off" name="password" placeholder="请输入提取码（非必填）"/>
				</div>
            `, confirm: () => { var t = $(".cm-modal select[name='type']").val(), t = `\n{cloud title="${$(".cm-modal input[name='title']").val()}" type="${t}" url="${$(".cm-modal input[name='url']").val()}" password="${$(".cm-modal input[name='password']").val()}"/}\n\n`; this._getLineCh(e) ? this._replaceSelection(e, "\n" + t) : this._replaceSelection(e, t), e.focus() }
			})
		}
	}{
			constructor() { var t; super(), this.plugins = [(t = {}, [$o, wo.of(t), er.domEventHandlers({ beforeinput(t, e) { return "historyUndo" == t.inputType ? bo(e) : "historyRedo" == t.inputType && xo(e) } })]), Uo, (t = {}, [ps.of(t), Qs]), [er.inputHandler.of(Ws), ks]], this._isPasting = !1, this.init_ViewPort(), this.init_Editor(), this.init_Preview(), this.init_Tools(), this.init_Insert(), this.init_AutoSave() } init_ViewPort() { 0 < $('meta[name="viewport"]').length ? $('meta[name="viewport"]').attr("content", "width=device-width, user-scalable=no, initial-scale=1.0, shrink-to-fit=no, viewport-fit=cover") : $("head").append('<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, shrink-to-fit=no, viewport-fit=cover">') } init_Editor() {
				$("#text").before(`
            <div class="cm-container">
                <div class="cm-tools"></div>
                <div class="cm-mainer">
                    <div class="cm-resize"></div>
                    <div class="cm-preview"><div class="cm-preview-content"></div></div>
					<div class="cm-autosave"></div>
                </div>
                <div class="cm-progress-left"></div>
                <div class="cm-progress-right"></div>
            </div>
        `), Vh($("#text").val()); let e = null; const s = new er({ state: pt.create({ doc: $("#text").val(), extensions: [...this.plugins, Ah({ base: Wh }), cr.of([mo, ...Xs, ...po, ...Co]), er.updateListener.of(t => { t.docChanged && e !== t.state.doc.toString() && (e = t.state.doc.toString(), window.requestAnimationFrame ? window.requestAnimationFrame(() => Vh(t.state.doc.toString())) : Vh(t.state.doc.toString())) }), er.domEventHandlers({ paste: e => { var n = e.clipboardData; if (n && n.items) { const r = n.items; if (r.length) { let i = null; for (let t = 0; t < r.length; t++)if (-1 !== r[t].type.indexOf("image")) { e.preventDefault(), i = r[t].getAsFile(); break } if (i) { let e = window.JoeConfig.uploadAPI; if (e) { n = $('input[name="cid"]').val(); if (n && (e = e + "&cid=" + n), !this._isPasting) { this._isPasting = !0; n = Date.now().toString(36) + ".png"; let t = new FormData; t.append("name", n), t.append("file", i, n), $.ajax({ url: e, method: "post", data: t, contentType: !1, processData: !1, dataType: "json", xhr: () => { const t = $.ajaxSettings.xhr(); if (t.upload) return t.upload.addEventListener("progress", t => { t = t.loaded / t.total * 100; $(".cm-progress-left").width(t / 2 + "%"), $(".cm-progress-right").width(t / 2 + "%") }, !1), t }, success: t => { $(".cm-progress-left").width(0), $(".cm-progress-right").width(0), this._isPasting = !1; t = `${super._getLineCh(s) ? "\n" : ""}![${t[1].title}](${t[0]})\n`; super._replaceSelection(s, t), s.focus() }, error: () => { $(".cm-progress-left").width(0), $(".cm-progress-right").width(0), this._isPasting = !1 } }) } } } } } } })], tabSize: 4 }) }); $(".cm-mainer").prepend(s.dom), $("#text")[0].form && $("#text")[0].form.addEventListener("submit", () => $("#text").val(s.state.doc.toString())), this.cm = s
			} init_Preview() { const n = (t, e, i) => { let n = e + (t - i); n <= 0 && (n = 0), n >= $(".cm-mainer").outerWidth() - 16 && (n = $(".cm-mainer").outerWidth() - 16), $(".cm-preview").width(n) }; $(".cm-resize").on({ mousedown: t => { t.preventDefault(), t.stopPropagation(); const e = $(".cm-preview").outerWidth(), i = t.clientX; return $(".cm-preview").addClass("move"), document.onmousemove = t => { window.requestAnimationFrame ? requestAnimationFrame(() => n(i, e, t.clientX)) : n(i, e, t.clientX) }, !(document.onmouseup = () => { document.onmousemove = null, document.onmouseup = null, $(".cm-preview").removeClass("move") }) }, touchstart: t => { t.preventDefault(), t.stopPropagation(); const e = $(".cm-preview").outerWidth(), i = t.originalEvent.targetTouches[0].clientX; return $(".cm-preview").addClass("move"), document.ontouchmove = t => { window.requestAnimationFrame ? requestAnimationFrame(() => n(i, e, t.targetTouches[0].clientX)) : n(i, e, t.targetTouches[0].clientX) }, !(document.ontouchend = () => { document.ontouchmove = null, document.ontouchend = null, $(".cm-preview").removeClass("move") }) } }) } init_Tools() { Lh.forEach(e => { if ("title" === e.type) super.handleTitle(this.cm, e); else { const i = $(`<div class="cm-tools-item" title="${e.title}">${e.innerHTML}</div>`); i.on("click", t => { switch (t.preventDefault(), e.type) { case "fullScreen": super.handleFullScreen(i); break; case "publish": super.handlePublish(); break; case "undo": super.handleUndo(this.cm); break; case "redo": super.handleRedo(this.cm); break; case "time": super.handleTime(this.cm); break; case "bold": super._insetAmboText(this.cm, "**"); break; case "italic": super._insetAmboText(this.cm, "*"); break; case "delete": super._insetAmboText(this.cm, "~~"); break; case "code-inline": super._insetAmboText(this.cm, "`"); break; case "indent": super.handleIndent(this.cm); break; case "hr": super.handleHr(this.cm); break; case "clean": super.handleClean(this.cm); break; case "ordered-list": super.handleOrdered(this.cm); break; case "unordered-list": super.handleUnordered(this.cm); break; case "quote": super.handleQuote(this.cm); break; case "download": super.handleDownload(this.cm); break; case "link": super.handleLink(this.cm); break; case "image": super.handleImage(this.cm); break; case "table": super.handleTable(this.cm); break; case "code-block": super.handleCodeBlock(this.cm); break; case "about": super.handleAbout(); break; case "character": super._createTableLists(this.cm, JoeConfig.characterAPI, "星星符号", "字符大全"); break; case "emoji": super._createTableLists(this.cm, JoeConfig.emojiAPI, "表情", "符号表情（需数据库支持）"); break; case "task-no": super.handleTask(this.cm, !1); break; case "task-yes": super.handleTask(this.cm, !0); break; case "netease-list": super.handleNetease(this.cm, !0); break; case "netease-single": super.handleNetease(this.cm, !1); break; case "bilibili": super.handleBilibili(this.cm); break; case "dplayer": super.handleDplayer(this.cm); break; case "draft": super.handleDraft(); break; case "expression": super.handleExpression(this.cm); break; case "mtitle": super.handleMtitle(this.cm); break; case "html": super.handleHtml(this.cm); break; case "abtn": super.handleAbtn(this.cm); break; case "anote": super.handleAnote(this.cm); break; case "dotted": super.handleDotted(this.cm); break; case "hide": super.handleHide(this.cm); break; case "card-default": super.handleCardDefault(this.cm); break; case "message": super.handleMessage(this.cm); break; case "progress": super.handleProgress(this.cm); break; case "callout": super.handleCallout(this.cm); break; case "mp3": super.handleMp3(this.cm); break; case "tabs": super.handleTabs(this.cm); break; case "card-list": super.handleCardList(this.cm); break; case "timeline": super.handleTimeline(this.cm); break; case "copy": super.handleCopy(this.cm); break; case "card-describe": super.handleCardDescribe(this.cm); break; case "lamp": super.handleLamp(this.cm); break; case "collapse": super.handleCollapse(this.cm); break; case "cloud": super.handleCloud(this.cm); break; case "gird": super.handleGird(this.cm); break; case "alert": super.handleAlert(this.cm); break; case "preview": i.toggleClass("active"), i.hasClass("active") ? window.JoeConfig.canPreview = !0 : window.JoeConfig.canPreview = !1, Vh(this.cm.state.doc.toString()) } }), $(".cm-tools").append(i) } }) } init_Insert() { Typecho.insertFileToEditor = (t, e, i) => { e = `${super._getLineCh(this.cm) ? "\n" : ""}${i ? "!" : ""}[${t}](${e})\n`; super._replaceSelection(this.cm, e), this.cm.focus() } } init_AutoSave() { if (1 === window.JoeConfig.autoSave) { const t = $("#text")[0].form; let n = $('input[name="cid"]').val(), r = null; setInterval(() => { $('input[name="cid"]').val(n), $("#text").val(this.cm.state.doc.toString()); let i = $(t).serialize(); i !== r && ($(".cm-autosave").addClass("active"), $.ajax({ url: t.action, type: "POST", data: i + "&do=save", dataType: "json", success: t => { n = t.cid, r = i; let e = setTimeout(() => { $(".cm-autosave").removeClass("active"), clearTimeout(e) }, 1e3) } })) }, 5e3) } }
	} document.addEventListener("DOMContentLoaded", () => new Yh)
}();
